!(function () { if (void 0 === window.Reflect || void 0 === window.customElements || window.customElements.polyfillWrapFlushCallback) return; const e = HTMLElement; const t = function () { return Reflect.construct(e, [], this.constructor) }; window.HTMLElement = t, HTMLElement.prototype = e.prototype, HTMLElement.prototype.constructor = HTMLElement, Object.setPrototypeOf(HTMLElement, e) }()), (function (e) { function t (e, t, i) { throw new e("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + t + '.', i) } typeof e.requestSubmit !== 'function' && (e.requestSubmit = function (e) { e ? (!(function (e, i) { e instanceof HTMLElement || t(TypeError, "parameter 1 is not of type 'HTMLElement'"), e.type == 'submit' || t(TypeError, 'The specified element is not a submit button'), e.form == i || t(DOMException, 'The specified element is not owned by this form element', 'NotFoundError') }(e, this)), e.click()) : ((e = document.createElement('input')).type = 'submit', e.hidden = !0, this.appendChild(e), e.click(), this.removeChild(e)) }) }(HTMLFormElement.prototype)); const e = new WeakMap(); function t (t) { const i = (function (e) { const t = e instanceof Element ? e : e instanceof Node ? e.parentElement : null; const i = t ? t.closest('input, button') : null; return (i == null ? void 0 : i.type) == 'submit' ? i : null }(t.target)); i && i.form && e.set(i.form, i) } let i, s, n, r, o, a; !(function () { if ('submitter' in Event.prototype) return; let i; if ('SubmitEvent' in window && /Apple Computer/.test(navigator.vendor))i = window.SubmitEvent.prototype; else { if ('SubmitEvent' in window) return; i = window.Event.prototype }addEventListener('click', t, !0), Object.defineProperty(i, 'submitter', { get () { if (this.type == 'submit' && this.target instanceof HTMLFormElement) return e.get(this.target) } }) }()), (function (e) { e.eager = 'eager', e.lazy = 'lazy' }(i || (i = {}))); class c extends HTMLElement {constructor () { super(), this.loaded = Promise.resolve(), this.delegate = new c.delegateConstructor(this) } static get observedAttributes () { return ['disabled', 'complete', 'loading', 'src'] }connectedCallback () { this.delegate.connect() }disconnectedCallback () { this.delegate.disconnect() }reload () { return this.delegate.sourceURLReloaded() }attributeChangedCallback (e) { e == 'loading' ? this.delegate.loadingStyleChanged() : e == 'complete' ? this.delegate.completeChanged() : e == 'src' ? this.delegate.sourceURLChanged() : this.delegate.disabledChanged() } get src () { return this.getAttribute('src') } set src (e) { e ? this.setAttribute('src', e) : this.removeAttribute('src') } get loading () { return (function (e) { if (e.toLowerCase() === 'lazy') return i.lazy; return i.eager }(this.getAttribute('loading') || '')) } set loading (e) { e ? this.setAttribute('loading', e) : this.removeAttribute('loading') } get disabled () { return this.hasAttribute('disabled') } set disabled (e) { e ? this.setAttribute('disabled', '') : this.removeAttribute('disabled') } get autoscroll () { return this.hasAttribute('autoscroll') } set autoscroll (e) { e ? this.setAttribute('autoscroll', '') : this.removeAttribute('autoscroll') } get complete () { return !this.delegate.isLoading } get isActive () { return this.ownerDocument === document && !this.isPreview } get isPreview () { let e, t; return (t = (e = this.ownerDocument) === null || void 0 === e ? void 0 : e.documentElement) === null || void 0 === t ? void 0 : t.hasAttribute('data-turbo-preview') }} function l (e) { return new URL(e.toString(), document.baseURI) } function h (e) { let t; return e.hash ? e.hash.slice(1) : (t = e.href.match(/#(.*)$/)) ? t[1] : void 0 } function d (e, t) { return l((t == null ? void 0 : t.getAttribute('formaction')) || e.getAttribute('action') || e.action) } function u (e) { return ((function (e) { return (function (e) { return e.pathname.split('/').slice(1) }(e)).slice(-1)[0] }(e)).match(/\.[^.]*$/) || [])[0] || '' } function m (e, t) { const i = (function (e) { return t = e.origin + e.pathname, t.endsWith('/') ? t : t + '/'; let t }(t)); return e.href === l(i).href || e.href.startsWith(i) } function p (e, t) { return m(e, t) && !!u(e).match(/^(?:|\.(?:htm|html|xhtml|php))$/) } function f (e) { const t = h(e); return t != null ? e.href.slice(0, -(t.length + 1)) : e.href } function g (e) { return f(e) } class b {constructor (e) { this.response = e } get succeeded () { return this.response.ok } get failed () { return !this.succeeded } get clientError () { return this.statusCode >= 400 && this.statusCode <= 499 } get serverError () { return this.statusCode >= 500 && this.statusCode <= 599 } get redirected () { return this.response.redirected } get location () { return l(this.response.url) } get isHTML () { return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/) } get statusCode () { return this.response.status } get contentType () { return this.header('Content-Type') } get responseText () { return this.response.clone().text() } get responseHTML () { return this.isHTML ? this.response.clone().text() : Promise.resolve(void 0) }header (e) { return this.response.headers.get(e) }} function v (e) { return e == 'advance' || e == 'replace' || e == 'restore' } function y (e) { if (e.getAttribute('data-turbo-eval') == 'false') return e; { const t = document.createElement('script'); const i = P('csp-nonce'); return i && (t.nonce = i), t.textContent = e.textContent, t.async = !1, (function (e, t) { for (const { name: i, value: s } of t.attributes)e.setAttribute(i, s) }(t, e)), t } } function w (e, { target: t, cancelable: i, detail: s } = {}) { const n = new CustomEvent(e, { cancelable: i, bubbles: !0, detail: s }); return t && t.isConnected ? t.dispatchEvent(n) : document.documentElement.dispatchEvent(n), n } function _ () { return new Promise(e => requestAnimationFrame(() => e())) } function E (e = '') { return (new DOMParser()).parseFromString(e, 'text/html') } function A (e, ...t) { const i = (function (e, t) { return e.reduce((e, i, s) => e + i + (t[s] == null ? '' : t[s]), '') }(e, t)).replace(/^\n/, '').split('\n'); const s = i[0].match(/^\s+/); const n = s ? s[0].length : 0; return i.map(e => e.slice(n)).join('\n') } function S () { return Array.from({ length: 36 }).map((e, t) => t == 8 || t == 13 || t == 18 || t == 23 ? '-' : t == 14 ? '4' : t == 19 ? (Math.floor(4 * Math.random()) + 8).toString(16) : Math.floor(15 * Math.random()).toString(16)).join('') } function C (e, ...t) { for (const i of t.map(t => t == null ? void 0 : t.getAttribute(e))) if (typeof i === 'string') return i; return null } function k (...e) { for (const t of e)t.localName == 'turbo-frame' && t.setAttribute('busy', ''), t.setAttribute('aria-busy', 'true') } function T (...e) { for (const t of e)t.localName == 'turbo-frame' && t.removeAttribute('busy'), t.removeAttribute('aria-busy') } function L (e, t = 2e3) { return new Promise(i => { const s = () => { e.removeEventListener('error', s), e.removeEventListener('load', s), i() }; e.addEventListener('load', s, { once: !0 }), e.addEventListener('error', s, { once: !0 }), setTimeout(i, t) }) } function O (e) { switch (e) { case 'replace':return history.replaceState; case 'advance':case 'restore':return history.pushState } } function M (e) { return document.querySelector(`meta[name="${e}"]`) } function P (e) { const t = M(e); return t && t.content }!(function (e) { e[e.get = 0] = 'get', e[e.post = 1] = 'post', e[e.put = 2] = 'put', e[e.patch = 3] = 'patch', e[e.delete = 4] = 'delete' }(s || (s = {}))); class x {constructor (e, t, i, s = new URLSearchParams(), n = null) { this.abortController = new AbortController(), this.resolveRequestPromise = e => {}, this.delegate = e, this.method = t, this.headers = this.defaultHeaders, this.body = s, this.url = i, this.target = n } get location () { return this.url } get params () { return this.url.searchParams } get entries () { return this.body ? Array.from(this.body.entries()) : [] }cancel () { this.abortController.abort() } async perform () { let e, t; const { fetchOptions: i } = this; (t = (e = this.delegate).prepareHeadersForRequest) === null || void 0 === t || t.call(e, this.headers, this), await this.allowRequestToBeIntercepted(i); try { this.delegate.requestStarted(this); const e = await fetch(this.url.href, i); return await this.receive(e) } catch (e) { if (e.name !== 'AbortError') throw this.willDelegateErrorHandling(e) && this.delegate.requestErrored(this, e), e } finally { this.delegate.requestFinished(this) } } async receive (e) { const t = new b(e); return w('turbo:before-fetch-response', { cancelable: !0, detail: { fetchResponse: t }, target: this.target }).defaultPrevented ? this.delegate.requestPreventedHandlingResponse(this, t) : t.succeeded ? this.delegate.requestSucceededWithResponse(this, t) : this.delegate.requestFailedWithResponse(this, t), t } get fetchOptions () { let e; return { method: s[this.method].toUpperCase(), credentials: 'same-origin', headers: this.headers, redirect: 'follow', body: this.isIdempotent ? null : this.body, signal: this.abortSignal, referrer: (e = this.delegate.referrer) === null || void 0 === e ? void 0 : e.href } } get defaultHeaders () { return { Accept: 'text/html, application/xhtml+xml' } } get isIdempotent () { return this.method == s.get } get abortSignal () { return this.abortController.signal }acceptResponseType (e) { this.headers.Accept = [e, this.headers.Accept].join(', ') } async allowRequestToBeIntercepted (e) { const t = new Promise(e => this.resolveRequestPromise = e); w('turbo:before-fetch-request', { cancelable: !0, detail: { fetchOptions: e, url: this.url, resume: this.resolveRequestPromise }, target: this.target }).defaultPrevented && await t }willDelegateErrorHandling (e) { return !w('turbo:fetch-request-error', { target: this.target, cancelable: !0, detail: { request: this, error: e } }).defaultPrevented }} class I {constructor (e, t) { this.started = !1, this.intersect = e => { const t = e.slice(-1)[0]; (t == null ? void 0 : t.isIntersecting) && this.delegate.elementAppearedInViewport(this.element) }, this.delegate = e, this.element = t, this.intersectionObserver = new IntersectionObserver(this.intersect) }start () { this.started || (this.started = !0, this.intersectionObserver.observe(this.element)) }stop () { this.started && (this.started = !1, this.intersectionObserver.unobserve(this.element)) }} class R {constructor (e) { this.fragment = (function (e) { for (const t of e.querySelectorAll('turbo-stream')) { const e = document.importNode(t, !0); for (const t of e.templateElement.content.querySelectorAll('script'))t.replaceWith(y(t)); t.replaceWith(e) } return e }(e)) } static wrap (e) { return typeof e === 'string' ? new this(function (e) { const t = document.createElement('template'); return t.innerHTML = e, t.content }(e)) : e }}R.contentType = 'text/vnd.turbo-stream.html', (function (e) { e[e.initialized = 0] = 'initialized', e[e.requesting = 1] = 'requesting', e[e.waiting = 2] = 'waiting', e[e.receiving = 3] = 'receiving', e[e.stopping = 4] = 'stopping', e[e.stopped = 5] = 'stopped' }(n || (n = {}))), (function (e) { e.urlEncoded = 'application/x-www-form-urlencoded', e.multipart = 'multipart/form-data', e.plain = 'text/plain' }(r || (r = {}))); class N {constructor (e, t, i, r = !1) { this.state = n.initialized, this.delegate = e, this.formElement = t, this.submitter = i, this.formData = (function (e, t) { const i = new FormData(e); const s = t == null ? void 0 : t.getAttribute('name'); const n = t == null ? void 0 : t.getAttribute('value'); s && i.append(s, n || ''); return i }(t, i)), this.location = l(this.action), this.method == s.get && (function (e, t) { const i = new URLSearchParams(); for (const [e, s] of t)s instanceof File || i.append(e, s); e.search = i.toString() }(this.location, [...this.body.entries()])), this.fetchRequest = new x(this, this.method, this.location, this.body, this.formElement), this.mustRedirect = r } static confirmMethod (e, t, i) { return Promise.resolve(confirm(e)) } get method () { let e; return (function (e) { switch (e.toLowerCase()) { case 'get':return s.get; case 'post':return s.post; case 'put':return s.put; case 'patch':return s.patch; case 'delete':return s.delete } }((((e = this.submitter) === null || void 0 === e ? void 0 : e.getAttribute('formmethod')) || this.formElement.getAttribute('method') || '').toLowerCase())) || s.get } get action () { let e; const t = typeof this.formElement.action === 'string' ? this.formElement.action : null; return ((e = this.submitter) === null || void 0 === e ? void 0 : e.hasAttribute('formaction')) ? this.submitter.getAttribute('formaction') || '' : this.formElement.getAttribute('action') || t || '' } get body () { return this.enctype == r.urlEncoded || this.method == s.get ? new URLSearchParams(this.stringFormData) : this.formData } get enctype () { let e; return (function (e) { switch (e.toLowerCase()) { case r.multipart:return r.multipart; case r.plain:return r.plain; default:return r.urlEncoded } }(((e = this.submitter) === null || void 0 === e ? void 0 : e.getAttribute('formenctype')) || this.formElement.enctype)) } get isIdempotent () { return this.fetchRequest.isIdempotent } get stringFormData () { return [...this.formData].reduce((e, [t, i]) => e.concat(typeof i === 'string' ? [[t, i]] : []), []) } async start () { const { initialized: e, requesting: t } = n; const i = C('data-turbo-confirm', this.submitter, this.formElement); if (typeof i === 'string') { if (!await N.confirmMethod(i, this.formElement, this.submitter)) return } if (this.state == e) return this.state = t, this.fetchRequest.perform() }stop () { const { stopping: e, stopped: t } = n; if (this.state != e && this.state != t) return this.state = e, this.fetchRequest.cancel(), !0 }prepareHeadersForRequest (e, t) { if (!t.isIdempotent) { const t = (function (e) { if (e != null) { const t = (document.cookie ? document.cookie.split('; ') : []).find(t => t.startsWith(e)); if (t) { const e = t.split('=').slice(1).join('='); return e ? decodeURIComponent(e) : void 0 } } }(P('csrf-param'))) || P('csrf-token'); t && (e['X-CSRF-Token'] = t) } this.requestAcceptsTurboStreamResponse(t) && t.acceptResponseType(R.contentType) }requestStarted (e) { let t; this.state = n.waiting, (t = this.submitter) === null || void 0 === t || t.setAttribute('disabled', ''), w('turbo:submit-start', { target: this.formElement, detail: { formSubmission: this } }), this.delegate.formSubmissionStarted(this) }requestPreventedHandlingResponse (e, t) { this.result = { success: t.succeeded, fetchResponse: t } }requestSucceededWithResponse (e, t) { if (t.clientError || t.serverError) this.delegate.formSubmissionFailedWithResponse(this, t); else if (this.requestMustRedirect(e) && (function (e) { return e.statusCode == 200 && !e.redirected }(t))) { const e = new Error('Form responses must redirect to another location'); this.delegate.formSubmissionErrored(this, e) } else this.state = n.receiving, this.result = { success: !0, fetchResponse: t }, this.delegate.formSubmissionSucceededWithResponse(this, t) }requestFailedWithResponse (e, t) { this.result = { success: !1, fetchResponse: t }, this.delegate.formSubmissionFailedWithResponse(this, t) }requestErrored (e, t) { this.result = { success: !1, error: t }, this.delegate.formSubmissionErrored(this, t) }requestFinished (e) { let t; this.state = n.stopped, (t = this.submitter) === null || void 0 === t || t.removeAttribute('disabled'), w('turbo:submit-end', { target: this.formElement, detail: Object.assign({ formSubmission: this }, this.result) }), this.delegate.formSubmissionFinished(this) }requestMustRedirect (e) { return !e.isIdempotent && this.mustRedirect }requestAcceptsTurboStreamResponse (e) { return !e.isIdempotent || (function (e, ...t) { return t.some(t => t && t.hasAttribute(e)) }('data-turbo-stream', this.submitter, this.formElement)) }} class F {constructor (e) { this.element = e } get activeElement () { return this.element.ownerDocument.activeElement } get children () { return [...this.element.children] }hasAnchor (e) { return this.getElementForAnchor(e) != null }getElementForAnchor (e) { return e ? this.element.querySelector(`[id='${e}'], a[name='${e}']`) : null } get isConnected () { return this.element.isConnected } get firstAutofocusableElement () { for (const e of this.element.querySelectorAll('[autofocus]')) if (e.closest('[inert], :disabled, [hidden], details:not([open]), dialog:not([open])') == null) return e; return null } get permanentElements () { return B(this.element) }getPermanentElementById (e) { return D(this.element, e) }getPermanentElementMapForSnapshot (e) { const t = {}; for (const i of this.permanentElements) { const { id: s } = i; const n = e.getPermanentElementById(s); n && (t[s] = [i, n]) } return t }} function D (e, t) { return e.querySelector(`#${t}[data-turbo-permanent]`) } function B (e) { return e.querySelectorAll('[id][data-turbo-permanent]') } class $ {constructor (e, t) { this.started = !1, this.submitCaptured = () => { this.eventTarget.removeEventListener('submit', this.submitBubbled, !1), this.eventTarget.addEventListener('submit', this.submitBubbled, !1) }, this.submitBubbled = e => { if (!e.defaultPrevented) { const t = e.target instanceof HTMLFormElement ? e.target : void 0; const i = e.submitter || void 0; t && (function (e, t) { const i = (t == null ? void 0 : t.getAttribute('formmethod')) || e.getAttribute('method'); return i != 'dialog' }(t, i)) && (function (e, t) { const i = (t == null ? void 0 : t.getAttribute('formtarget')) || e.target; for (const e of document.getElementsByName(i)) if (e instanceof HTMLIFrameElement) return !1; return !0 }(t, i)) && this.delegate.willSubmitForm(t, i) && (e.preventDefault(), e.stopImmediatePropagation(), this.delegate.formSubmitted(t, i)) } }, this.delegate = e, this.eventTarget = t }start () { this.started || (this.eventTarget.addEventListener('submit', this.submitCaptured, !0), this.started = !0) }stop () { this.started && (this.eventTarget.removeEventListener('submit', this.submitCaptured, !0), this.started = !1) }} class j {constructor (e, t) { this.resolveRenderPromise = e => {}, this.resolveInterceptionPromise = e => {}, this.delegate = e, this.element = t }scrollToAnchor (e) { const t = this.snapshot.getElementForAnchor(e); t ? (this.scrollToElement(t), this.focusElement(t)) : this.scrollToPosition({ x: 0, y: 0 }) }scrollToAnchorFromLocation (e) { this.scrollToAnchor(h(e)) }scrollToElement (e) { e.scrollIntoView() }focusElement (e) { e instanceof HTMLElement && (e.hasAttribute('tabindex') ? e.focus() : (e.setAttribute('tabindex', '-1'), e.focus(), e.removeAttribute('tabindex'))) }scrollToPosition ({ x: e, y: t }) { this.scrollRoot.scrollTo(e, t) }scrollToTop () { this.scrollToPosition({ x: 0, y: 0 }) } get scrollRoot () { return window } async render (e) { const { isPreview: t, shouldRender: i, newSnapshot: s } = e; if (i) try { this.renderPromise = new Promise(e => this.resolveRenderPromise = e), this.renderer = e, await this.prepareToRenderSnapshot(e); const i = new Promise(e => this.resolveInterceptionPromise = e); const n = { resume: this.resolveInterceptionPromise, render: this.renderer.renderElement }; this.delegate.allowsImmediateRender(s, n) || await i, await this.renderSnapshot(e), this.delegate.viewRenderedSnapshot(s, t), this.delegate.preloadOnLoadLinksForView(this.element), this.finishRenderingSnapshot(e) } finally { delete this.renderer, this.resolveRenderPromise(void 0), delete this.renderPromise } else this.invalidate(e.reloadReason) }invalidate (e) { this.delegate.viewInvalidated(e) } async prepareToRenderSnapshot (e) { this.markAsPreview(e.isPreview), await e.prepareToRender() }markAsPreview (e) { e ? this.element.setAttribute('data-turbo-preview', '') : this.element.removeAttribute('data-turbo-preview') } async renderSnapshot (e) { await e.render() }finishRenderingSnapshot (e) { e.finishRendering() }} class H extends j {invalidate () { this.element.innerHTML = '' } get snapshot () { return new F(this.element) }} class q {constructor (e, t) { this.clickBubbled = e => { this.respondsToEventTarget(e.target) ? this.clickEvent = e : delete this.clickEvent }, this.linkClicked = e => { this.clickEvent && this.respondsToEventTarget(e.target) && e.target instanceof Element && this.delegate.shouldInterceptLinkClick(e.target, e.detail.url, e.detail.originalEvent) && (this.clickEvent.preventDefault(), e.preventDefault(), this.delegate.linkClickIntercepted(e.target, e.detail.url, e.detail.originalEvent)), delete this.clickEvent }, this.willVisit = e => { delete this.clickEvent }, this.delegate = e, this.element = t }start () { this.element.addEventListener('click', this.clickBubbled), document.addEventListener('turbo:click', this.linkClicked), document.addEventListener('turbo:before-visit', this.willVisit) }stop () { this.element.removeEventListener('click', this.clickBubbled), document.removeEventListener('turbo:click', this.linkClicked), document.removeEventListener('turbo:before-visit', this.willVisit) }respondsToEventTarget (e) { const t = e instanceof Element ? e : e instanceof Node ? e.parentElement : null; return t && t.closest('turbo-frame, html') == this.element }} class V {constructor (e, t) { this.started = !1, this.clickCaptured = () => { this.eventTarget.removeEventListener('click', this.clickBubbled, !1), this.eventTarget.addEventListener('click', this.clickBubbled, !1) }, this.clickBubbled = e => { if (e instanceof MouseEvent && this.clickEventIsSignificant(e)) { const t = e.composedPath && e.composedPath()[0] || e.target; const i = this.findLinkFromClickTarget(t); if (i && (function (e) { for (const t of document.getElementsByName(e.target)) if (t instanceof HTMLIFrameElement) return !1; return !0 }(i))) { const t = this.getLocationForLink(i); this.delegate.willFollowLinkToLocation(i, t, e) && (e.preventDefault(), this.delegate.followedLinkToLocation(i, t)) } } }, this.delegate = e, this.eventTarget = t }start () { this.started || (this.eventTarget.addEventListener('click', this.clickCaptured, !0), this.started = !0) }stop () { this.started && (this.eventTarget.removeEventListener('click', this.clickCaptured, !0), this.started = !1) }clickEventIsSignificant (e) { return !(e.target && e.target.isContentEditable || e.defaultPrevented || e.which > 1 || e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) }findLinkFromClickTarget (e) { if (e instanceof Element) return e.closest('a[href]:not([target^=_]):not([download])') }getLocationForLink (e) { return l(e.getAttribute('href') || '') }} class W {constructor (e, t) { this.delegate = e, this.linkInterceptor = new V(this, t) }start () { this.linkInterceptor.start() }stop () { this.linkInterceptor.stop() }willFollowLinkToLocation (e, t, i) { return this.delegate.willSubmitFormLinkToLocation(e, t, i) && e.hasAttribute('data-turbo-method') }followedLinkToLocation (e, t) { const i = t.href; const s = document.createElement('form'); s.setAttribute('data-turbo', 'true'), s.setAttribute('action', i), s.setAttribute('hidden', ''); const n = e.getAttribute('data-turbo-method'); n && s.setAttribute('method', n); const r = e.getAttribute('data-turbo-frame'); r && s.setAttribute('data-turbo-frame', r); const o = e.getAttribute('data-turbo-action'); o && s.setAttribute('data-turbo-action', o); const a = e.getAttribute('data-turbo-confirm'); a && s.setAttribute('data-turbo-confirm', a); e.hasAttribute('data-turbo-stream') && s.setAttribute('data-turbo-stream', ''), this.delegate.submittedFormLinkToLocation(e, t, s), document.body.appendChild(s), s.addEventListener('turbo:submit-end', () => s.remove(), { once: !0 }), requestAnimationFrame(() => s.requestSubmit()) }} class K {constructor (e, t) { this.delegate = e, this.permanentElementMap = t } static preservingPermanentElements (e, t, i) { const s = new this(e, t); s.enter(), i(), s.leave() }enter () { for (const e in this.permanentElementMap) { const [t, i] = this.permanentElementMap[e]; this.delegate.enteringBardo(t, i), this.replaceNewPermanentElementWithPlaceholder(i) } }leave () { for (const e in this.permanentElementMap) { const [t] = this.permanentElementMap[e]; this.replaceCurrentPermanentElementWithClone(t), this.replacePlaceholderWithPermanentElement(t), this.delegate.leavingBardo(t) } }replaceNewPermanentElementWithPlaceholder (e) { const t = (function (e) { const t = document.createElement('meta'); return t.setAttribute('name', 'turbo-permanent-placeholder'), t.setAttribute('content', e.id), t }(e)); e.replaceWith(t) }replaceCurrentPermanentElementWithClone (e) { const t = e.cloneNode(!0); e.replaceWith(t) }replacePlaceholderWithPermanentElement (e) { const t = this.getPlaceholderById(e.id); t == null || t.replaceWith(e) }getPlaceholderById (e) { return this.placeholders.find(t => t.content == e) } get placeholders () { return [...document.querySelectorAll('meta[name=turbo-permanent-placeholder][content]')] }} class z {constructor (e, t, i, s, n = !0) { this.activeElement = null, this.currentSnapshot = e, this.newSnapshot = t, this.isPreview = s, this.willRender = n, this.renderElement = i, this.promise = new Promise((e, t) => this.resolvingFunctions = { resolve: e, reject: t }) } get shouldRender () { return !0 } get reloadReason () {}prepareToRender () {}finishRendering () { this.resolvingFunctions && (this.resolvingFunctions.resolve(), delete this.resolvingFunctions) }preservingPermanentElements (e) { K.preservingPermanentElements(this, this.permanentElementMap, e) }focusFirstAutofocusableElement () { const e = this.connectedSnapshot.firstAutofocusableElement; (function (e) { return e && typeof e.focus === 'function' })(e) && e.focus() }enteringBardo (e) { this.activeElement || e.contains(this.currentSnapshot.activeElement) && (this.activeElement = this.currentSnapshot.activeElement) }leavingBardo (e) { e.contains(this.activeElement) && this.activeElement instanceof HTMLElement && (this.activeElement.focus(), this.activeElement = null) } get connectedSnapshot () { return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot } get currentElement () { return this.currentSnapshot.element } get newElement () { return this.newSnapshot.element } get permanentElementMap () { return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot) }} class U extends z {constructor (e, t, i, s, n, r = !0) { super(t, i, s, n, r), this.delegate = e } static renderElement (e, t) { let i; const s = document.createRange(); s.selectNodeContents(e), s.deleteContents(); const n = t; const r = (i = n.ownerDocument) === null || void 0 === i ? void 0 : i.createRange(); r && (r.selectNodeContents(n), e.appendChild(r.extractContents())) } get shouldRender () { return !0 } async render () { await _(), this.preservingPermanentElements(() => { this.loadFrameElement() }), this.scrollFrameIntoView(), await _(), this.focusFirstAutofocusableElement(), await _(), this.activateScriptElements() }loadFrameElement () { this.delegate.willRenderFrame(this.currentElement, this.newElement), this.renderElement(this.currentElement, this.newElement) }scrollFrameIntoView () { if (this.currentElement.autoscroll || this.newElement.autoscroll) { const i = this.currentElement.firstElementChild; const s = (e = this.currentElement.getAttribute('data-autoscroll-block'), t = 'end', e == 'end' || e == 'start' || e == 'center' || e == 'nearest' ? e : t); const n = (function (e, t) { return e == 'auto' || e == 'smooth' ? e : t }(this.currentElement.getAttribute('data-autoscroll-behavior'), 'auto')); if (i) return i.scrollIntoView({ block: s, behavior: n }), !0 } let e, t; return !1 }activateScriptElements () { for (const e of this.newScriptElements) { const t = y(e); e.replaceWith(t) } } get newScriptElements () { return this.currentElement.querySelectorAll('script') }} class G {
  constructor () { this.hiding = !1, this.value = 0, this.visible = !1, this.trickle = () => { this.setValue(this.value + Math.random() / 100) }, this.stylesheetElement = this.createStylesheetElement(), this.progressElement = this.createProgressElement(), this.installStylesheetElement(), this.setValue(0) } static get defaultCSS () {
    return A`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${G.animationDuration}ms ease-out,
          opacity ${G.animationDuration / 2}ms ${G.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `
  }

  show () { this.visible || (this.visible = !0, this.installProgressElement(), this.startTrickling()) }hide () { this.visible && !this.hiding && (this.hiding = !0, this.fadeProgressElement(() => { this.uninstallProgressElement(), this.stopTrickling(), this.visible = !1, this.hiding = !1 })) }setValue (e) { this.value = e, this.refresh() }installStylesheetElement () { document.head.insertBefore(this.stylesheetElement, document.head.firstChild) }installProgressElement () { this.progressElement.style.width = '0', this.progressElement.style.opacity = '1', document.documentElement.insertBefore(this.progressElement, document.body), this.refresh() }fadeProgressElement (e) { this.progressElement.style.opacity = '0', setTimeout(e, 1.5 * G.animationDuration) }uninstallProgressElement () { this.progressElement.parentNode && document.documentElement.removeChild(this.progressElement) }startTrickling () { this.trickleInterval || (this.trickleInterval = window.setInterval(this.trickle, G.animationDuration)) }stopTrickling () { window.clearInterval(this.trickleInterval), delete this.trickleInterval }refresh () { requestAnimationFrame(() => { this.progressElement.style.width = 10 + 90 * this.value + '%' }) }createStylesheetElement () { const e = document.createElement('style'); return e.type = 'text/css', e.textContent = G.defaultCSS, this.cspNonce && (e.nonce = this.cspNonce), e }createProgressElement () { const e = document.createElement('div'); return e.className = 'turbo-progress-bar', e } get cspNonce () { return P('csp-nonce') }
}G.animationDuration = 300; class X extends F {constructor () { super(...arguments), this.detailsByOuterHTML = this.children.filter(e => !(function (e) { const t = e.localName; return t == 'noscript' }(e))).map(e => (function (e) { e.hasAttribute('nonce') && e.setAttribute('nonce', ''); return e }(e))).reduce((e, t) => { const { outerHTML: i } = t; const s = i in e ? e[i] : { type: Q(t), tracked: Y(t), elements: [] }; return Object.assign(Object.assign({}, e), { [i]: Object.assign(Object.assign({}, s), { elements: [...s.elements, t] }) }) }, {}) } get trackedElementSignature () { return Object.keys(this.detailsByOuterHTML).filter(e => this.detailsByOuterHTML[e].tracked).join('') }getScriptElementsNotInSnapshot (e) { return this.getElementsMatchingTypeNotInSnapshot('script', e) }getStylesheetElementsNotInSnapshot (e) { return this.getElementsMatchingTypeNotInSnapshot('stylesheet', e) }getElementsMatchingTypeNotInSnapshot (e, t) { return Object.keys(this.detailsByOuterHTML).filter(e => !(e in t.detailsByOuterHTML)).map(e => this.detailsByOuterHTML[e]).filter(({ type: t }) => t == e).map(({ elements: [e] }) => e) } get provisionalElements () { return Object.keys(this.detailsByOuterHTML).reduce((e, t) => { const { type: i, tracked: s, elements: n } = this.detailsByOuterHTML[t]; return i != null || s ? n.length > 1 ? [...e, ...n.slice(1)] : e : [...e, ...n] }, []) }getMetaValue (e) { const t = this.findMetaElementByName(e); return t ? t.getAttribute('content') : null }findMetaElementByName (e) { return Object.keys(this.detailsByOuterHTML).reduce((t, i) => { const { elements: [s] } = this.detailsByOuterHTML[i]; return (function (e, t) { const i = e.localName; return i == 'meta' && e.getAttribute('name') == t }(s, e)) ? s : t }, void 0) }} function Q (e) { return (function (e) { const t = e.localName; return t == 'script' }(e)) ? 'script' : (function (e) { const t = e.localName; return t == 'style' || t == 'link' && e.getAttribute('rel') == 'stylesheet' }(e)) ? 'stylesheet' : void 0 } function Y (e) { return e.getAttribute('data-turbo-track') == 'reload' } class J extends F {constructor (e, t) { super(e), this.headSnapshot = t } static fromHTMLString (e = '') { return this.fromDocument(E(e)) } static fromElement (e) { return this.fromDocument(e.ownerDocument) } static fromDocument ({ head: e, body: t }) { return new this(t, new X(e)) }clone () { const e = this.element.cloneNode(!0); const t = this.element.querySelectorAll('select'); const i = e.querySelectorAll('select'); for (const [e, s] of t.entries()) { const t = i[e]; for (const e of t.selectedOptions)e.selected = !1; for (const e of s.selectedOptions)t.options[e.index].selected = !0 } for (const t of e.querySelectorAll('input[type="password"]'))t.value = ''; return new J(e, this.headSnapshot) } get headElement () { return this.headSnapshot.element } get rootLocation () { let e; return l((e = this.getSetting('root')) !== null && void 0 !== e ? e : '/') } get cacheControlValue () { return this.getSetting('cache-control') } get isPreviewable () { return this.cacheControlValue != 'no-preview' } get isCacheable () { return this.cacheControlValue != 'no-cache' } get isVisitable () { return this.getSetting('visit-control') != 'reload' }getSetting (e) { return this.headSnapshot.getMetaValue(`turbo-${e}`) }}!(function (e) { e.visitStart = 'visitStart', e.requestStart = 'requestStart', e.requestEnd = 'requestEnd', e.visitEnd = 'visitEnd' }(o || (o = {}))), (function (e) { e.initialized = 'initialized', e.started = 'started', e.canceled = 'canceled', e.failed = 'failed', e.completed = 'completed' }(a || (a = {}))); const Z = { action: 'advance', historyChanged: !1, visitCachedSnapshot: () => {}, willRender: !0, updateHistory: !0, shouldCacheSnapshot: !0, acceptsStreamResponse: !1 }; let ee, te; !(function (e) { e[e.networkFailure = 0] = 'networkFailure', e[e.timeoutFailure = -1] = 'timeoutFailure', e[e.contentTypeMismatch = -2] = 'contentTypeMismatch' }(ee || (ee = {}))); class ie {constructor (e, t, i, s = {}) { this.identifier = S(), this.timingMetrics = {}, this.followedRedirect = !1, this.historyChanged = !1, this.scrolled = !1, this.shouldCacheSnapshot = !0, this.acceptsStreamResponse = !1, this.snapshotCached = !1, this.state = a.initialized, this.delegate = e, this.location = t, this.restorationIdentifier = i || S(); const { action: n, historyChanged: r, referrer: o, snapshot: c, snapshotHTML: l, response: h, visitCachedSnapshot: d, willRender: u, updateHistory: m, shouldCacheSnapshot: p, acceptsStreamResponse: f } = Object.assign(Object.assign({}, Z), s); this.action = n, this.historyChanged = r, this.referrer = o, this.snapshot = c, this.snapshotHTML = l, this.response = h, this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action), this.visitCachedSnapshot = d, this.willRender = u, this.updateHistory = m, this.scrolled = !u, this.shouldCacheSnapshot = p, this.acceptsStreamResponse = f } get adapter () { return this.delegate.adapter } get view () { return this.delegate.view } get history () { return this.delegate.history } get restorationData () { return this.history.getRestorationDataForIdentifier(this.restorationIdentifier) } get silent () { return this.isSamePage }start () { this.state == a.initialized && (this.recordTimingMetric(o.visitStart), this.state = a.started, this.adapter.visitStarted(this), this.delegate.visitStarted(this)) }cancel () { this.state == a.started && (this.request && this.request.cancel(), this.cancelRender(), this.state = a.canceled) }complete () { this.state == a.started && (this.recordTimingMetric(o.visitEnd), this.state = a.completed, this.followRedirect(), this.followedRedirect || (this.adapter.visitCompleted(this), this.delegate.visitCompleted(this))) }fail () { this.state == a.started && (this.state = a.failed, this.adapter.visitFailed(this)) }changeHistory () { let e; if (!this.historyChanged && this.updateHistory) { const t = O(this.location.href === ((e = this.referrer) === null || void 0 === e ? void 0 : e.href) ? 'replace' : this.action); this.history.update(t, this.location, this.restorationIdentifier), this.historyChanged = !0 } }issueRequest () { this.hasPreloadedResponse() ? this.simulateRequest() : this.shouldIssueRequest() && !this.request && (this.request = new x(this, s.get, this.location), this.request.perform()) }simulateRequest () { this.response && (this.startRequest(), this.recordResponse(), this.finishRequest()) }startRequest () { this.recordTimingMetric(o.requestStart), this.adapter.visitRequestStarted(this) }recordResponse (e = this.response) { if (this.response = e, e) { const { statusCode: t } = e; se(t) ? this.adapter.visitRequestCompleted(this) : this.adapter.visitRequestFailedWithStatusCode(this, t) } }finishRequest () { this.recordTimingMetric(o.requestEnd), this.adapter.visitRequestFinished(this) }loadResponse () { if (this.response) { const { statusCode: e, responseHTML: t } = this.response; this.render(async () => { this.shouldCacheSnapshot && this.cacheSnapshot(), this.view.renderPromise && await this.view.renderPromise, se(e) && t != null ? (await this.view.renderPage(J.fromHTMLString(t), !1, this.willRender, this), this.performScroll(), this.adapter.visitRendered(this), this.complete()) : (await this.view.renderError(J.fromHTMLString(t), this), this.adapter.visitRendered(this), this.fail()) }) } }getCachedSnapshot () { const e = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot(); if (e && (!h(this.location) || e.hasAnchor(h(this.location))) && (this.action == 'restore' || e.isPreviewable)) return e }getPreloadedSnapshot () { if (this.snapshotHTML) return J.fromHTMLString(this.snapshotHTML) }hasCachedSnapshot () { return this.getCachedSnapshot() != null }loadCachedSnapshot () { const e = this.getCachedSnapshot(); if (e) { const t = this.shouldIssueRequest(); this.render(async () => { this.cacheSnapshot(), this.isSamePage ? this.adapter.visitRendered(this) : (this.view.renderPromise && await this.view.renderPromise, await this.view.renderPage(e, t, this.willRender, this), this.performScroll(), this.adapter.visitRendered(this), t || this.complete()) }) } }followRedirect () { let e; this.redirectedToLocation && !this.followedRedirect && ((e = this.response) === null || void 0 === e ? void 0 : e.redirected) && (this.adapter.visitProposedToLocation(this.redirectedToLocation, { action: 'replace', response: this.response }), this.followedRedirect = !0) }goToSamePageAnchor () { this.isSamePage && this.render(async () => { this.cacheSnapshot(), this.performScroll(), this.changeHistory(), this.adapter.visitRendered(this) }) }prepareHeadersForRequest (e, t) { this.acceptsStreamResponse && t.acceptResponseType(R.contentType) }requestStarted () { this.startRequest() }requestPreventedHandlingResponse (e, t) {} async requestSucceededWithResponse (e, t) { const i = await t.responseHTML; const { redirected: s, statusCode: n } = t; i == null ? this.recordResponse({ statusCode: ee.contentTypeMismatch, redirected: s }) : (this.redirectedToLocation = t.redirected ? t.location : void 0, this.recordResponse({ statusCode: n, responseHTML: i, redirected: s })) } async requestFailedWithResponse (e, t) { const i = await t.responseHTML; const { redirected: s, statusCode: n } = t; i == null ? this.recordResponse({ statusCode: ee.contentTypeMismatch, redirected: s }) : this.recordResponse({ statusCode: n, responseHTML: i, redirected: s }) }requestErrored (e, t) { this.recordResponse({ statusCode: ee.networkFailure, redirected: !1 }) }requestFinished () { this.finishRequest() }performScroll () { this.scrolled || this.view.forceReloaded || (this.action == 'restore' ? this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop() : this.scrollToAnchor() || this.view.scrollToTop(), this.isSamePage && this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location), this.scrolled = !0) }scrollToRestoredPosition () { const { scrollPosition: e } = this.restorationData; if (e) return this.view.scrollToPosition(e), !0 }scrollToAnchor () { const e = h(this.location); if (e != null) return this.view.scrollToAnchor(e), !0 }recordTimingMetric (e) { this.timingMetrics[e] = (new Date()).getTime() }getTimingMetrics () { return Object.assign({}, this.timingMetrics) }getHistoryMethodForAction (e) { switch (e) { case 'replace':return history.replaceState; case 'advance':case 'restore':return history.pushState } }hasPreloadedResponse () { return typeof this.response === 'object' }shouldIssueRequest () { return !this.isSamePage && (this.action == 'restore' ? !this.hasCachedSnapshot() : this.willRender) }cacheSnapshot () { this.snapshotCached || (this.view.cacheSnapshot(this.snapshot).then(e => e && this.visitCachedSnapshot(e)), this.snapshotCached = !0) } async render (e) { this.cancelRender(), await new Promise(e => { this.frame = requestAnimationFrame(() => e()) }), await e(), delete this.frame }cancelRender () { this.frame && (cancelAnimationFrame(this.frame), delete this.frame) }} function se (e) { return e >= 200 && e < 300 } class ne {constructor (e) { this.progressBar = new G(), this.showProgressBar = () => { this.progressBar.show() }, this.session = e }visitProposedToLocation (e, t) { this.navigator.startVisit(e, (t == null ? void 0 : t.restorationIdentifier) || S(), t) }visitStarted (e) { this.location = e.location, e.loadCachedSnapshot(), e.issueRequest(), e.goToSamePageAnchor() }visitRequestStarted (e) { this.progressBar.setValue(0), e.hasCachedSnapshot() || e.action != 'restore' ? this.showVisitProgressBarAfterDelay() : this.showProgressBar() }visitRequestCompleted (e) { e.loadResponse() }visitRequestFailedWithStatusCode (e, t) { switch (t) { case ee.networkFailure:case ee.timeoutFailure:case ee.contentTypeMismatch:return this.reload({ reason: 'request_failed', context: { statusCode: t } }); default:return e.loadResponse() } }visitRequestFinished (e) { this.progressBar.setValue(1), this.hideVisitProgressBar() }visitCompleted (e) {}pageInvalidated (e) { this.reload(e) }visitFailed (e) {}visitRendered (e) {}formSubmissionStarted (e) { this.progressBar.setValue(0), this.showFormProgressBarAfterDelay() }formSubmissionFinished (e) { this.progressBar.setValue(1), this.hideFormProgressBar() }showVisitProgressBarAfterDelay () { this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay) }hideVisitProgressBar () { this.progressBar.hide(), this.visitProgressBarTimeout != null && (window.clearTimeout(this.visitProgressBarTimeout), delete this.visitProgressBarTimeout) }showFormProgressBarAfterDelay () { this.formProgressBarTimeout == null && (this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay)) }hideFormProgressBar () { this.progressBar.hide(), this.formProgressBarTimeout != null && (window.clearTimeout(this.formProgressBarTimeout), delete this.formProgressBarTimeout) }reload (e) { let t; w('turbo:reload', { detail: e }), window.location.href = ((t = this.location) === null || void 0 === t ? void 0 : t.toString()) || window.location.href } get navigator () { return this.session.navigator }} class re {constructor () { this.started = !1, this.removeStaleElements = e => { const t = [...document.querySelectorAll('[data-turbo-cache="false"]')]; for (const e of t)e.remove() } }start () { this.started || (this.started = !0, addEventListener('turbo:before-cache', this.removeStaleElements, !1)) }stop () { this.started && (this.started = !1, removeEventListener('turbo:before-cache', this.removeStaleElements, !1)) }} class oe {constructor (e, t) { this.session = e, this.element = t, this.linkInterceptor = new q(this, t), this.formSubmitObserver = new $(this, t) }start () { this.linkInterceptor.start(), this.formSubmitObserver.start() }stop () { this.linkInterceptor.stop(), this.formSubmitObserver.stop() }shouldInterceptLinkClick (e, t, i) { return this.shouldRedirect(e) }linkClickIntercepted (e, t, i) { const s = this.findFrameElement(e); s && s.delegate.linkClickIntercepted(e, t, i) }willSubmitForm (e, t) { return e.closest('turbo-frame') == null && this.shouldSubmit(e, t) && this.shouldRedirect(e, t) }formSubmitted (e, t) { const i = this.findFrameElement(e, t); i && i.delegate.formSubmitted(e, t) }shouldSubmit (e, t) { let i; const s = d(e, t); const n = this.element.ownerDocument.querySelector('meta[name="turbo-root"]'); const r = l((i = n == null ? void 0 : n.content) !== null && void 0 !== i ? i : '/'); return this.shouldRedirect(e, t) && p(s, r) }shouldRedirect (e, t) { if (e instanceof HTMLFormElement ? this.session.submissionIsNavigatable(e, t) : this.session.elementIsNavigatable(e)) { const i = this.findFrameElement(e, t); return !!i && i != e.closest('turbo-frame') } return !1 }findFrameElement (e, t) { const i = (t == null ? void 0 : t.getAttribute('data-turbo-frame')) || e.getAttribute('data-turbo-frame'); if (i && i != '_top') { const e = this.element.querySelector(`#${i}:not([disabled])`); if (e instanceof c) return e } }} class ae {constructor (e) { this.restorationIdentifier = S(), this.restorationData = {}, this.started = !1, this.pageLoaded = !1, this.onPopState = e => { if (this.shouldHandlePopState()) { const { turbo: t } = e.state || {}; if (t) { this.location = new URL(window.location.href); const { restorationIdentifier: e } = t; this.restorationIdentifier = e, this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, e) } } }, this.onPageLoad = async e => { await Promise.resolve(), this.pageLoaded = !0 }, this.delegate = e }start () { this.started || (addEventListener('popstate', this.onPopState, !1), addEventListener('load', this.onPageLoad, !1), this.started = !0, this.replace(new URL(window.location.href))) }stop () { this.started && (removeEventListener('popstate', this.onPopState, !1), removeEventListener('load', this.onPageLoad, !1), this.started = !1) }push (e, t) { this.update(history.pushState, e, t) }replace (e, t) { this.update(history.replaceState, e, t) }update (e, t, i = S()) { const s = { turbo: { restorationIdentifier: i } }; e.call(history, s, '', t.href), this.location = t, this.restorationIdentifier = i }getRestorationDataForIdentifier (e) { return this.restorationData[e] || {} }updateRestorationData (e) { const { restorationIdentifier: t } = this; const i = this.restorationData[t]; this.restorationData[t] = Object.assign(Object.assign({}, i), e) }assumeControlOfScrollRestoration () { let e; this.previousScrollRestoration || (this.previousScrollRestoration = (e = history.scrollRestoration) !== null && void 0 !== e ? e : 'auto', history.scrollRestoration = 'manual') }relinquishControlOfScrollRestoration () { this.previousScrollRestoration && (history.scrollRestoration = this.previousScrollRestoration, delete this.previousScrollRestoration) }shouldHandlePopState () { return this.pageIsLoaded() }pageIsLoaded () { return this.pageLoaded || document.readyState == 'complete' }} class ce {constructor (e) { this.delegate = e }proposeVisit (e, t = {}) { this.delegate.allowsVisitingLocationWithAction(e, t.action) && (p(e, this.view.snapshot.rootLocation) ? this.delegate.visitProposedToLocation(e, t) : window.location.href = e.toString()) }startVisit (e, t, i = {}) { this.stop(), this.currentVisit = new ie(this, l(e), t, Object.assign({ referrer: this.location }, i)), this.currentVisit.start() }submitForm (e, t) { this.stop(), this.formSubmission = new N(this, e, t, !0), this.formSubmission.start() }stop () { this.formSubmission && (this.formSubmission.stop(), delete this.formSubmission), this.currentVisit && (this.currentVisit.cancel(), delete this.currentVisit) } get adapter () { return this.delegate.adapter } get view () { return this.delegate.view } get history () { return this.delegate.history }formSubmissionStarted (e) { typeof this.adapter.formSubmissionStarted === 'function' && this.adapter.formSubmissionStarted(e) } async formSubmissionSucceededWithResponse (e, t) { if (e == this.formSubmission) { const i = await t.responseHTML; if (i) { const n = e.method == s.get; n || this.view.clearSnapshotCache(); const { statusCode: r, redirected: o } = t; const a = { action: this.getActionForFormSubmission(e), shouldCacheSnapshot: n, response: { statusCode: r, responseHTML: i, redirected: o } }; this.proposeVisit(t.location, a) } } } async formSubmissionFailedWithResponse (e, t) { const i = await t.responseHTML; if (i) { const e = J.fromHTMLString(i); t.serverError ? await this.view.renderError(e, this.currentVisit) : await this.view.renderPage(e, !1, !0, this.currentVisit), this.view.scrollToTop(), this.view.clearSnapshotCache() } }formSubmissionErrored (e, t) { console.error(t) }formSubmissionFinished (e) { typeof this.adapter.formSubmissionFinished === 'function' && this.adapter.formSubmissionFinished(e) }visitStarted (e) { this.delegate.visitStarted(e) }visitCompleted (e) { this.delegate.visitCompleted(e) }locationWithActionIsSamePage (e, t) { const i = h(e); const s = h(this.view.lastRenderedLocation); const n = t === 'restore' && void 0 === i; return t !== 'replace' && f(e) === f(this.view.lastRenderedLocation) && (n || i != null && i !== s) }visitScrolledToSamePageLocation (e, t) { this.delegate.visitScrolledToSamePageLocation(e, t) } get location () { return this.history.location } get restorationIdentifier () { return this.history.restorationIdentifier }getActionForFormSubmission (e) { const { formElement: t, submitter: i } = e; const s = C('data-turbo-action', i, t); return v(s) ? s : 'advance' }}!(function (e) { e[e.initial = 0] = 'initial', e[e.loading = 1] = 'loading', e[e.interactive = 2] = 'interactive', e[e.complete = 3] = 'complete' }(te || (te = {}))); class le {constructor (e) { this.stage = te.initial, this.started = !1, this.interpretReadyState = () => { const { readyState: e } = this; e == 'interactive' ? this.pageIsInteractive() : e == 'complete' && this.pageIsComplete() }, this.pageWillUnload = () => { this.delegate.pageWillUnload() }, this.delegate = e }start () { this.started || (this.stage == te.initial && (this.stage = te.loading), document.addEventListener('readystatechange', this.interpretReadyState, !1), addEventListener('pagehide', this.pageWillUnload, !1), this.started = !0) }stop () { this.started && (document.removeEventListener('readystatechange', this.interpretReadyState, !1), removeEventListener('pagehide', this.pageWillUnload, !1), this.started = !1) }pageIsInteractive () { this.stage == te.loading && (this.stage = te.interactive, this.delegate.pageBecameInteractive()) }pageIsComplete () { this.pageIsInteractive(), this.stage == te.interactive && (this.stage = te.complete, this.delegate.pageLoaded()) } get readyState () { return document.readyState }} class he {constructor (e) { this.started = !1, this.onScroll = () => { this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset }) }, this.delegate = e }start () { this.started || (addEventListener('scroll', this.onScroll, !1), this.onScroll(), this.started = !0) }stop () { this.started && (removeEventListener('scroll', this.onScroll, !1), this.started = !1) }updatePosition (e) { this.delegate.scrollPositionChanged(e) }} class de {render ({ fragment: e }) { K.preservingPermanentElements(this, (function (e) { const t = B(document.documentElement); const i = {}; for (const s of t) { const { id: t } = s; for (const n of e.querySelectorAll('turbo-stream')) { const e = D(n.templateElement.content, t); e && (i[t] = [s, e]) } } return i }(e)), () => document.documentElement.appendChild(e)) }enteringBardo (e, t) { t.replaceWith(e.cloneNode(!0)) }leavingBardo () {}} class ue {constructor (e) { this.sources = new Set(), this.started = !1, this.inspectFetchResponse = e => { const t = (function (e) { let t; const i = (t = e.detail) === null || void 0 === t ? void 0 : t.fetchResponse; if (i instanceof b) return i }(e)); t && (function (e) { let t; const i = (t = e.contentType) !== null && void 0 !== t ? t : ''; return i.startsWith(R.contentType) }(t)) && (e.preventDefault(), this.receiveMessageResponse(t)) }, this.receiveMessageEvent = e => { this.started && typeof e.data === 'string' && this.receiveMessageHTML(e.data) }, this.delegate = e }start () { this.started || (this.started = !0, addEventListener('turbo:before-fetch-response', this.inspectFetchResponse, !1)) }stop () { this.started && (this.started = !1, removeEventListener('turbo:before-fetch-response', this.inspectFetchResponse, !1)) }connectStreamSource (e) { this.streamSourceIsConnected(e) || (this.sources.add(e), e.addEventListener('message', this.receiveMessageEvent, !1)) }disconnectStreamSource (e) { this.streamSourceIsConnected(e) && (this.sources.delete(e), e.removeEventListener('message', this.receiveMessageEvent, !1)) }streamSourceIsConnected (e) { return this.sources.has(e) } async receiveMessageResponse (e) { const t = await e.responseHTML; t && this.receiveMessageHTML(t) }receiveMessageHTML (e) { this.delegate.receivedMessageFromStream(R.wrap(e)) }} class me extends z {static renderElement (e, t) { const { documentElement: i, body: s } = document; i.replaceChild(t, s) } async render () { this.replaceHeadAndBody(), this.activateScriptElements() }replaceHeadAndBody () { const { documentElement: e, head: t } = document; e.replaceChild(this.newHead, t), this.renderElement(this.currentElement, this.newElement) }activateScriptElements () { for (const e of this.scriptElements) { const t = e.parentNode; if (t) { const i = y(e); t.replaceChild(i, e) } } } get newHead () { return this.newSnapshot.headSnapshot.element } get scriptElements () { return document.documentElement.querySelectorAll('script') }} class pe extends z {static renderElement (e, t) { document.body && t instanceof HTMLBodyElement ? document.body.replaceWith(t) : document.documentElement.appendChild(t) } get shouldRender () { return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical } get reloadReason () { return this.newSnapshot.isVisitable ? this.trackedElementsAreIdentical ? void 0 : { reason: 'tracked_element_mismatch' } : { reason: 'turbo_visit_control_is_reload' } } async prepareToRender () { await this.mergeHead() } async render () { this.willRender && this.replaceBody() }finishRendering () { super.finishRendering(), this.isPreview || this.focusFirstAutofocusableElement() } get currentHeadSnapshot () { return this.currentSnapshot.headSnapshot } get newHeadSnapshot () { return this.newSnapshot.headSnapshot } get newElement () { return this.newSnapshot.element } async mergeHead () { const e = this.copyNewHeadStylesheetElements(); this.copyNewHeadScriptElements(), this.removeCurrentHeadProvisionalElements(), this.copyNewHeadProvisionalElements(), await e }replaceBody () { this.preservingPermanentElements(() => { this.activateNewBody(), this.assignNewBody() }) } get trackedElementsAreIdentical () { return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature } async copyNewHeadStylesheetElements () { const e = []; for (const t of this.newHeadStylesheetElements)e.push(L(t)), document.head.appendChild(t); await Promise.all(e) }copyNewHeadScriptElements () { for (const e of this.newHeadScriptElements)document.head.appendChild(y(e)) }removeCurrentHeadProvisionalElements () { for (const e of this.currentHeadProvisionalElements)document.head.removeChild(e) }copyNewHeadProvisionalElements () { for (const e of this.newHeadProvisionalElements)document.head.appendChild(e) }activateNewBody () { document.adoptNode(this.newElement), this.activateNewBodyScriptElements() }activateNewBodyScriptElements () { for (const e of this.newBodyScriptElements) { const t = y(e); e.replaceWith(t) } }assignNewBody () { this.renderElement(this.currentElement, this.newElement) } get newHeadStylesheetElements () { return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot) } get newHeadScriptElements () { return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot) } get currentHeadProvisionalElements () { return this.currentHeadSnapshot.provisionalElements } get newHeadProvisionalElements () { return this.newHeadSnapshot.provisionalElements } get newBodyScriptElements () { return this.newElement.querySelectorAll('script') }} class fe {constructor (e) { this.keys = [], this.snapshots = {}, this.size = e }has (e) { return g(e) in this.snapshots }get (e) { if (this.has(e)) { const t = this.read(e); return this.touch(e), t } }put (e, t) { return this.write(e, t), this.touch(e), t }clear () { this.snapshots = {} }read (e) { return this.snapshots[g(e)] }write (e, t) { this.snapshots[g(e)] = t }touch (e) { const t = g(e); const i = this.keys.indexOf(t); i > -1 && this.keys.splice(i, 1), this.keys.unshift(t), this.trim() }trim () { for (const e of this.keys.splice(this.size)) delete this.snapshots[e] }} class ge extends j {constructor () { super(...arguments), this.snapshotCache = new fe(10), this.lastRenderedLocation = new URL(location.href), this.forceReloaded = !1 }renderPage (e, t = !1, i = !0, s) { const n = new pe(this.snapshot, e, pe.renderElement, t, i); return n.shouldRender ? s == null || s.changeHistory() : this.forceReloaded = !0, this.render(n) }renderError (e, t) { t == null || t.changeHistory(); const i = new me(this.snapshot, e, me.renderElement, !1); return this.render(i) }clearSnapshotCache () { this.snapshotCache.clear() } async cacheSnapshot (e = this.snapshot) { if (e.isCacheable) { this.delegate.viewWillCacheSnapshot(); const { lastRenderedLocation: t } = this; await new Promise(e => setTimeout(() => e(), 0)); const i = e.clone(); return this.snapshotCache.put(t, i), i } }getCachedSnapshotForLocation (e) { return this.snapshotCache.get(e) } get snapshot () { return J.fromElement(this.element) }} class be {constructor (e) { this.selector = 'a[data-turbo-preload]', this.delegate = e } get snapshotCache () { return this.delegate.navigator.view.snapshotCache }start () { if (document.readyState === 'loading') return document.addEventListener('DOMContentLoaded', () => { this.preloadOnLoadLinksForView(document.body) }); this.preloadOnLoadLinksForView(document.body) }preloadOnLoadLinksForView (e) { for (const t of e.querySelectorAll(this.selector)) this.preloadURL(t) } async preloadURL (e) { const t = new URL(e.href); if (!this.snapshotCache.has(t)) try { const e = await fetch(t.toString(), { headers: { 'VND.PREFETCH': 'true', Accept: 'text/html' } }); const i = await e.text(); const s = J.fromHTMLString(i); this.snapshotCache.put(t, s) } catch (e) {} }} function ve (e) { Object.defineProperties(e, ye) } const ye = { absoluteURL: { get () { return this.toString() } } }; const we = { after () { this.targetElements.forEach(e => { let t; return (t = e.parentElement) === null || void 0 === t ? void 0 : t.insertBefore(this.templateContent, e.nextSibling) }) }, append () { this.removeDuplicateTargetChildren(), this.targetElements.forEach(e => e.append(this.templateContent)) }, before () { this.targetElements.forEach(e => { let t; return (t = e.parentElement) === null || void 0 === t ? void 0 : t.insertBefore(this.templateContent, e) }) }, prepend () { this.removeDuplicateTargetChildren(), this.targetElements.forEach(e => e.prepend(this.templateContent)) }, remove () { this.targetElements.forEach(e => e.remove()) }, replace () { this.targetElements.forEach(e => e.replaceWith(this.templateContent)) }, update () { this.targetElements.forEach(e => e.replaceChildren(this.templateContent)) } }; const _e = new class {constructor () { this.navigator = new ce(this), this.history = new ae(this), this.preloader = new be(this), this.view = new ge(this, document.documentElement), this.adapter = new ne(this), this.pageObserver = new le(this), this.cacheObserver = new re(), this.linkClickObserver = new V(this, window), this.formSubmitObserver = new $(this, document), this.scrollObserver = new he(this), this.streamObserver = new ue(this), this.formLinkClickObserver = new W(this, document.documentElement), this.frameRedirector = new oe(this, document.documentElement), this.streamMessageRenderer = new de(), this.drive = !0, this.enabled = !0, this.progressBarDelay = 500, this.started = !1, this.formMode = 'on' }start () { this.started || (this.pageObserver.start(), this.cacheObserver.start(), this.formLinkClickObserver.start(), this.linkClickObserver.start(), this.formSubmitObserver.start(), this.scrollObserver.start(), this.streamObserver.start(), this.frameRedirector.start(), this.history.start(), this.preloader.start(), this.started = !0, this.enabled = !0) }disable () { this.enabled = !1 }stop () { this.started && (this.pageObserver.stop(), this.cacheObserver.stop(), this.formLinkClickObserver.stop(), this.linkClickObserver.stop(), this.formSubmitObserver.stop(), this.scrollObserver.stop(), this.streamObserver.stop(), this.frameRedirector.stop(), this.history.stop(), this.started = !1) }registerAdapter (e) { this.adapter = e }visit (e, t = {}) { const i = t.frame ? document.getElementById(t.frame) : null; i instanceof c ? (i.src = e.toString(), i.loaded) : this.navigator.proposeVisit(l(e), t) }connectStreamSource (e) { this.streamObserver.connectStreamSource(e) }disconnectStreamSource (e) { this.streamObserver.disconnectStreamSource(e) }renderStreamMessage (e) { this.streamMessageRenderer.render(R.wrap(e)) }clearCache () { this.view.clearSnapshotCache() }setProgressBarDelay (e) { this.progressBarDelay = e }setFormMode (e) { this.formMode = e } get location () { return this.history.location } get restorationIdentifier () { return this.history.restorationIdentifier }historyPoppedToLocationWithRestorationIdentifier (e, t) { this.enabled ? this.navigator.startVisit(e, t, { action: 'restore', historyChanged: !0 }) : this.adapter.pageInvalidated({ reason: 'turbo_disabled' }) }scrollPositionChanged (e) { this.history.updateRestorationData({ scrollPosition: e }) }willSubmitFormLinkToLocation (e, t) { return this.elementIsNavigatable(e) && p(t, this.snapshot.rootLocation) }submittedFormLinkToLocation () {}willFollowLinkToLocation (e, t, i) { return this.elementIsNavigatable(e) && p(t, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(e, t, i) }followedLinkToLocation (e, t) { const i = this.getActionForLink(e); const s = e.hasAttribute('data-turbo-stream'); this.visit(t.href, { action: i, acceptsStreamResponse: s }) }allowsVisitingLocationWithAction (e, t) { return this.locationWithActionIsSamePage(e, t) || this.applicationAllowsVisitingLocation(e) }visitProposedToLocation (e, t) { ve(e), this.adapter.visitProposedToLocation(e, t) }visitStarted (e) { e.acceptsStreamResponse || k(document.documentElement), ve(e.location), e.silent || this.notifyApplicationAfterVisitingLocation(e.location, e.action) }visitCompleted (e) { T(document.documentElement), this.notifyApplicationAfterPageLoad(e.getTimingMetrics()) }locationWithActionIsSamePage (e, t) { return this.navigator.locationWithActionIsSamePage(e, t) }visitScrolledToSamePageLocation (e, t) { this.notifyApplicationAfterVisitingSamePageLocation(e, t) }willSubmitForm (e, t) { const i = d(e, t); return this.submissionIsNavigatable(e, t) && p(l(i), this.snapshot.rootLocation) }formSubmitted (e, t) { this.navigator.submitForm(e, t) }pageBecameInteractive () { this.view.lastRenderedLocation = this.location, this.notifyApplicationAfterPageLoad() }pageLoaded () { this.history.assumeControlOfScrollRestoration() }pageWillUnload () { this.history.relinquishControlOfScrollRestoration() }receivedMessageFromStream (e) { this.renderStreamMessage(e) }viewWillCacheSnapshot () { let e; ((e = this.navigator.currentVisit) === null || void 0 === e ? void 0 : e.silent) || this.notifyApplicationBeforeCachingSnapshot() }allowsImmediateRender ({ element: e }, t) { const i = this.notifyApplicationBeforeRender(e, t); const { defaultPrevented: s, detail: { render: n } } = i; return this.view.renderer && n && (this.view.renderer.renderElement = n), !s }viewRenderedSnapshot (e, t) { this.view.lastRenderedLocation = this.history.location, this.notifyApplicationAfterRender() }preloadOnLoadLinksForView (e) { this.preloader.preloadOnLoadLinksForView(e) }viewInvalidated (e) { this.adapter.pageInvalidated(e) }frameLoaded (e) { this.notifyApplicationAfterFrameLoad(e) }frameRendered (e, t) { this.notifyApplicationAfterFrameRender(e, t) }applicationAllowsFollowingLinkToLocation (e, t, i) { return !this.notifyApplicationAfterClickingLinkToLocation(e, t, i).defaultPrevented }applicationAllowsVisitingLocation (e) { return !this.notifyApplicationBeforeVisitingLocation(e).defaultPrevented }notifyApplicationAfterClickingLinkToLocation (e, t, i) { return w('turbo:click', { target: e, detail: { url: t.href, originalEvent: i }, cancelable: !0 }) }notifyApplicationBeforeVisitingLocation (e) { return w('turbo:before-visit', { detail: { url: e.href }, cancelable: !0 }) }notifyApplicationAfterVisitingLocation (e, t) { return w('turbo:visit', { detail: { url: e.href, action: t } }) }notifyApplicationBeforeCachingSnapshot () { return w('turbo:before-cache') }notifyApplicationBeforeRender (e, t) { return w('turbo:before-render', { detail: Object.assign({ newBody: e }, t), cancelable: !0 }) }notifyApplicationAfterRender () { return w('turbo:render') }notifyApplicationAfterPageLoad (e = {}) { return w('turbo:load', { detail: { url: this.location.href, timing: e } }) }notifyApplicationAfterVisitingSamePageLocation (e, t) { dispatchEvent(new HashChangeEvent('hashchange', { oldURL: e.toString(), newURL: t.toString() })) }notifyApplicationAfterFrameLoad (e) { return w('turbo:frame-load', { target: e }) }notifyApplicationAfterFrameRender (e, t) { return w('turbo:frame-render', { detail: { fetchResponse: e }, target: t, cancelable: !0 }) }submissionIsNavigatable (e, t) { if (this.formMode == 'off') return !1; { const i = !t || this.elementIsNavigatable(t); return this.formMode == 'optin' ? i && e.closest('[data-turbo="true"]') != null : i && this.elementIsNavigatable(e) } }elementIsNavigatable (e) { const t = e.closest('[data-turbo]'); const i = e.closest('turbo-frame'); return this.drive || i ? !t || t.getAttribute('data-turbo') != 'false' : !!t && t.getAttribute('data-turbo') == 'true' }getActionForLink (e) { const t = e.getAttribute('data-turbo-action'); return v(t) ? t : 'advance' } get snapshot () { return this.view.snapshot }}(); const Ee = new class {constructor (e) { this.session = e }clear () { this.session.clearCache() }resetCacheControl () { this.setCacheControl('') }exemptPageFromCache () { this.setCacheControl('no-cache') }exemptPageFromPreview () { this.setCacheControl('no-preview') }setCacheControl (e) { !(function (e, t) { let i = M(e); i || (i = document.createElement('meta'), i.setAttribute('name', e), document.head.appendChild(i)), i.setAttribute('content', t) }('turbo-cache-control', e)) }}(_e); const { navigator: Ae } = _e; function Se () { _e.start() } function Ce (e) { _e.connectStreamSource(e) } function ke (e) { _e.disconnectStreamSource(e) } const Te = Object.freeze({ __proto__: null, navigator: Ae, session: _e, cache: Ee, PageRenderer: pe, PageSnapshot: J, FrameRenderer: U, start: Se, registerAdapter: function (e) { _e.registerAdapter(e) }, visit: function (e, t) { _e.visit(e, t) }, connectStreamSource: Ce, disconnectStreamSource: ke, renderStreamMessage: function (e) { _e.renderStreamMessage(e) }, clearCache: function () { console.warn('Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`'), _e.clearCache() }, setProgressBarDelay: function (e) { _e.setProgressBarDelay(e) }, setConfirmMethod: function (e) { N.confirmMethod = e }, setFormMode: function (e) { _e.setFormMode(e) }, StreamActions: we }); function Le (e) { if (e != null) { const t = document.getElementById(e); if (t instanceof c) return t } } function Oe (e, t) { if (e) { const i = e.getAttribute('src'); if (i != null && t != null && (function (e, t) { return l(e).href == l(t).href }(i, t))) throw new Error(`Matching <turbo-frame id="${e.id}"> element has a source URL which references itself`); if (e.ownerDocument !== document && (e = document.importNode(e, !0)), e instanceof c) return e.connectedCallback(), e.disconnectedCallback(), e } } class Me extends HTMLElement {static async renderElement (e) { await e.performAction() } async connectedCallback () { try { await this.render() } catch (e) { console.error(e) } finally { this.disconnect() } } async render () { let e; return (e = this.renderPromise) !== null && void 0 !== e ? e : this.renderPromise = (async () => { const e = this.beforeRenderEvent; this.dispatchEvent(e) && (await _(), await e.detail.render(this)) })() }disconnect () { try { this.remove() } catch (e) {} }removeDuplicateTargetChildren () { this.duplicateChildren.forEach(e => e.remove()) } get duplicateChildren () { let e; const t = this.targetElements.flatMap(e => [...e.children]).filter(e => !!e.id); const i = [...((e = this.templateContent) === null || void 0 === e ? void 0 : e.children) || []].filter(e => !!e.id).map(e => e.id); return t.filter(e => i.includes(e.id)) } get performAction () { if (this.action) { const e = we[this.action]; if (e) return e; this.raise('unknown action') } this.raise('action attribute is missing') } get targetElements () { return this.target ? this.targetElementsById : this.targets ? this.targetElementsByQuery : void this.raise('target or targets attribute is missing') } get templateContent () { return this.templateElement.content.cloneNode(!0) } get templateElement () { if (this.firstElementChild === null) { const e = this.ownerDocument.createElement('template'); return this.appendChild(e), e } if (this.firstElementChild instanceof HTMLTemplateElement) return this.firstElementChild; this.raise('first child element must be a <template> element') } get action () { return this.getAttribute('action') } get target () { return this.getAttribute('target') } get targets () { return this.getAttribute('targets') }raise (e) { throw new Error(`${this.description}: ${e}`) } get description () { let e, t; return (t = ((e = this.outerHTML.match(/<[^>]+>/)) !== null && void 0 !== e ? e : [])[0]) !== null && void 0 !== t ? t : '<turbo-stream>' } get beforeRenderEvent () { return new CustomEvent('turbo:before-stream-render', { bubbles: !0, cancelable: !0, detail: { newStream: this, render: Me.renderElement } }) } get targetElementsById () { let e; const t = (e = this.ownerDocument) === null || void 0 === e ? void 0 : e.getElementById(this.target); return t !== null ? [t] : [] } get targetElementsByQuery () { let e; const t = (e = this.ownerDocument) === null || void 0 === e ? void 0 : e.querySelectorAll(this.targets); return t.length !== 0 ? Array.prototype.slice.call(t) : [] }} class Pe extends HTMLElement {constructor () { super(...arguments), this.streamSource = null }connectedCallback () { this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src), Ce(this.streamSource) }disconnectedCallback () { this.streamSource && ke(this.streamSource) } get src () { return this.getAttribute('src') || '' }} let xe; async function Ie () { return xe || Re((async function () { const { createConsumer: e } = await Promise.resolve().then(function () { return Sh }); return e() }()).then(Re)) } function Re (e) { return xe = e } function Ne (e) { return e && typeof e === 'object' ? e instanceof Date || e instanceof RegExp ? e : Array.isArray(e) ? e.map(Ne) : Object.keys(e).reduce(function (t, i) { return t[i[0].toLowerCase() + i.slice(1).replace(/([A-Z]+)/g, function (e, t) { return '_' + t.toLowerCase() })] = Ne(e[i]), t }, {}) : e }c.delegateConstructor = class {constructor (e) { this.fetchResponseLoaded = e => {}, this.currentFetchRequest = null, this.resolveVisitPromise = () => {}, this.connected = !1, this.hasBeenLoaded = !1, this.ignoredAttributes = new Set(), this.action = null, this.visitCachedSnapshot = ({ element: e }) => { const t = e.querySelector('#' + this.element.id); t && this.previousFrameElement && t.replaceChildren(...this.previousFrameElement.children), delete this.previousFrameElement }, this.element = e, this.view = new H(this, this.element), this.appearanceObserver = new I(this, this.element), this.formLinkClickObserver = new W(this, this.element), this.linkInterceptor = new q(this, this.element), this.restorationIdentifier = S(), this.formSubmitObserver = new $(this, this.element) }connect () { this.connected || (this.connected = !0, this.loadingStyle == i.lazy ? this.appearanceObserver.start() : this.loadSourceURL(), this.formLinkClickObserver.start(), this.linkInterceptor.start(), this.formSubmitObserver.start()) }disconnect () { this.connected && (this.connected = !1, this.appearanceObserver.stop(), this.formLinkClickObserver.stop(), this.linkInterceptor.stop(), this.formSubmitObserver.stop()) }disabledChanged () { this.loadingStyle == i.eager && this.loadSourceURL() }sourceURLChanged () { this.isIgnoringChangesTo('src') || (this.element.isConnected && (this.complete = !1), (this.loadingStyle == i.eager || this.hasBeenLoaded) && this.loadSourceURL()) }sourceURLReloaded () { const { src: e } = this.element; return this.ignoringChangesToAttribute('complete', () => { this.element.removeAttribute('complete') }), this.element.src = null, this.element.src = e, this.element.loaded }completeChanged () { this.isIgnoringChangesTo('complete') || this.loadSourceURL() }loadingStyleChanged () { this.loadingStyle == i.lazy ? this.appearanceObserver.start() : (this.appearanceObserver.stop(), this.loadSourceURL()) } async loadSourceURL () { this.enabled && this.isActive && !this.complete && this.sourceURL && (this.element.loaded = this.visit(l(this.sourceURL)), this.appearanceObserver.stop(), await this.element.loaded, this.hasBeenLoaded = !0) } async loadResponse (e) { (e.redirected || e.succeeded && e.isHTML) && (this.sourceURL = e.response.url); try { const t = await e.responseHTML; if (t) { const { body: i } = E(t); const s = await this.extractForeignFrameElement(i); if (s) { const t = new F(s); const i = new U(this, this.view.snapshot, t, U.renderElement, !1, !1); this.view.renderPromise && await this.view.renderPromise, this.changeHistory(), await this.view.render(i), this.complete = !0, _e.frameRendered(e, this.element), _e.frameLoaded(this.element), this.fetchResponseLoaded(e) } else this.willHandleFrameMissingFromResponse(e) && (console.warn(`A matching frame for #${this.element.id} was missing from the response, transforming into full-page Visit.`), this.visitResponse(e.response)) } } catch (e) { console.error(e), this.view.invalidate() } finally { this.fetchResponseLoaded = () => {} } }elementAppearedInViewport (e) { this.loadSourceURL() }willSubmitFormLinkToLocation (e) { return this.shouldInterceptNavigation(e) }submittedFormLinkToLocation (e, t, i) { const s = this.findFrameElement(e); s && i.setAttribute('data-turbo-frame', s.id) }shouldInterceptLinkClick (e, t, i) { return this.shouldInterceptNavigation(e) }linkClickIntercepted (e, t) { this.navigateFrame(e, t) }willSubmitForm (e, t) { return e.closest('turbo-frame') == this.element && this.shouldInterceptNavigation(e, t) }formSubmitted (e, t) { this.formSubmission && this.formSubmission.stop(), this.formSubmission = new N(this, e, t); const { fetchRequest: i } = this.formSubmission; this.prepareHeadersForRequest(i.headers, i), this.formSubmission.start() }prepareHeadersForRequest (e, t) { let i; e['Turbo-Frame'] = this.id, ((i = this.currentNavigationElement) === null || void 0 === i ? void 0 : i.hasAttribute('data-turbo-stream')) && t.acceptResponseType(R.contentType) }requestStarted (e) { k(this.element) }requestPreventedHandlingResponse (e, t) { this.resolveVisitPromise() } async requestSucceededWithResponse (e, t) { await this.loadResponse(t), this.resolveVisitPromise() } async requestFailedWithResponse (e, t) { console.error(t), await this.loadResponse(t), this.resolveVisitPromise() }requestErrored (e, t) { console.error(t), this.resolveVisitPromise() }requestFinished (e) { T(this.element) }formSubmissionStarted ({ formElement: e }) { k(e, this.findFrameElement(e)) }formSubmissionSucceededWithResponse (e, t) { const i = this.findFrameElement(e.formElement, e.submitter); i.delegate.proposeVisitIfNavigatedWithAction(i, e.formElement, e.submitter), i.delegate.loadResponse(t) }formSubmissionFailedWithResponse (e, t) { this.element.delegate.loadResponse(t) }formSubmissionErrored (e, t) { console.error(t) }formSubmissionFinished ({ formElement: e }) { T(e, this.findFrameElement(e)) }allowsImmediateRender ({ element: e }, t) { const i = w('turbo:before-frame-render', { target: this.element, detail: Object.assign({ newFrame: e }, t), cancelable: !0 }); const { defaultPrevented: s, detail: { render: n } } = i; return this.view.renderer && n && (this.view.renderer.renderElement = n), !s }viewRenderedSnapshot (e, t) {}preloadOnLoadLinksForView (e) { _e.preloadOnLoadLinksForView(e) }viewInvalidated () {}willRenderFrame (e, t) { this.previousFrameElement = e.cloneNode(!0) } async visit (e) { let t; const i = new x(this, s.get, e, new URLSearchParams(), this.element); return (t = this.currentFetchRequest) === null || void 0 === t || t.cancel(), this.currentFetchRequest = i, new Promise(e => { this.resolveVisitPromise = () => { this.resolveVisitPromise = () => {}, this.currentFetchRequest = null, e() }, i.perform() }) }navigateFrame (e, t, i) { const s = this.findFrameElement(e, i); this.pageSnapshot = J.fromElement(s).clone(), s.delegate.proposeVisitIfNavigatedWithAction(s, e, i), this.withCurrentNavigationElement(e, () => { s.src = t }) }proposeVisitIfNavigatedWithAction (e, t, i) { if (this.action = (function (...e) { const t = C('data-turbo-action', ...e); return v(t) ? t : null }(i, t, e)), v(this.action)) { const { visitCachedSnapshot: t } = e.delegate; e.delegate.fetchResponseLoaded = i => { if (e.src) { const { statusCode: s, redirected: n } = i; const r = { response: { statusCode: s, redirected: n, responseHTML: e.ownerDocument.documentElement.outerHTML }, visitCachedSnapshot: t, willRender: !1, updateHistory: !1, restorationIdentifier: this.restorationIdentifier, snapshot: this.pageSnapshot }; this.action && (r.action = this.action), _e.visit(e.src, r) } } } }changeHistory () { if (this.action) { const e = O(this.action); _e.history.update(e, l(this.element.src || ''), this.restorationIdentifier) } }willHandleFrameMissingFromResponse (e) { this.element.setAttribute('complete', ''); const t = e.response; return !w('turbo:frame-missing', { target: this.element, detail: { response: t, visit: async (e, t = {}) => { e instanceof Response ? this.visitResponse(e) : _e.visit(e, t) } }, cancelable: !0 }).defaultPrevented } async visitResponse (e) { const t = new b(e); const i = await t.responseHTML; const { location: s, redirected: n, statusCode: r } = t; return _e.visit(s, { response: { redirected: n, statusCode: r, responseHTML: i } }) }findFrameElement (e, t) { let i; return (i = Le(C('data-turbo-frame', t, e) || this.element.getAttribute('target'))) !== null && void 0 !== i ? i : this.element } async extractForeignFrameElement (e) { let t; const i = CSS.escape(this.id); try { if (t = Oe(e.querySelector(`turbo-frame#${i}`), this.sourceURL), t) return t; if (t = Oe(e.querySelector(`turbo-frame[src][recurse~=${i}]`), this.sourceURL), t) return await t.loaded, await this.extractForeignFrameElement(t) } catch (e) { return console.error(e), new c() } return null }formActionIsVisitable (e, t) { return p(l(d(e, t)), this.rootLocation) }shouldInterceptNavigation (e, t) { const i = C('data-turbo-frame', t, e) || this.element.getAttribute('target'); if (e instanceof HTMLFormElement && !this.formActionIsVisitable(e, t)) return !1; if (!this.enabled || i == '_top') return !1; if (i) { const e = Le(i); if (e) return !e.disabled } return !!_e.elementIsNavigatable(e) && !(t && !_e.elementIsNavigatable(t)) } get id () { return this.element.id } get enabled () { return !this.element.disabled } get sourceURL () { if (this.element.src) return this.element.src } set sourceURL (e) { this.ignoringChangesToAttribute('src', () => { this.element.src = e != null ? e : null }) } get loadingStyle () { return this.element.loading } get isLoading () { return void 0 !== this.formSubmission || void 0 !== this.resolveVisitPromise() } get complete () { return this.element.hasAttribute('complete') } set complete (e) { this.ignoringChangesToAttribute('complete', () => { e ? this.element.setAttribute('complete', '') : this.element.removeAttribute('complete') }) } get isActive () { return this.element.isActive && this.connected } get rootLocation () { let e; const t = this.element.ownerDocument.querySelector('meta[name="turbo-root"]'); return l((e = t == null ? void 0 : t.content) !== null && void 0 !== e ? e : '/') }isIgnoringChangesTo (e) { return this.ignoredAttributes.has(e) }ignoringChangesToAttribute (e, t) { this.ignoredAttributes.add(e), t(), this.ignoredAttributes.delete(e) }withCurrentNavigationElement (e, t) { this.currentNavigationElement = e, t(), delete this.currentNavigationElement }}, void 0 === customElements.get('turbo-frame') && customElements.define('turbo-frame', c), void 0 === customElements.get('turbo-stream') && customElements.define('turbo-stream', Me), void 0 === customElements.get('turbo-stream-source') && customElements.define('turbo-stream-source', Pe), (() => {
  let e = document.currentScript; if (e && !e.hasAttribute('data-turbo-suppress-warning')) {
    for (e = e.parentElement; e;) {
      if (e == document.body) {
        return console.warn(A`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, e.outerHTML)
      } e = e.parentElement
    }
  }
})(), window.Turbo = Te, Se(); class Fe extends HTMLElement {async connectedCallback () { Ce(this), this.subscription = await (async function (e, t) { const { subscriptions: i } = await Ie(); return i.create(e, t) }(this.channel, { received: this.dispatchMessageEvent.bind(this) })) }disconnectedCallback () { ke(this), this.subscription && this.subscription.unsubscribe() }dispatchMessageEvent (e) { const t = new MessageEvent('message', { data: e }); return this.dispatchEvent(t) } get channel () { return { channel: this.getAttribute('channel'), signed_stream_name: this.getAttribute('signed-stream-name'), ...Ne({ ...this.dataset }) } }}customElements.define('turbo-cable-stream-source', Fe), addEventListener('turbo:before-fetch-request', function (e) { if (e.target instanceof HTMLFormElement) { const { target: t, detail: { fetchOptions: i } } = e; t.addEventListener('turbo:submit-start', ({ detail: { formSubmission: { submitter: e } } }) => { const s = e && e.formMethod || i.body && i.body.get('_method') || t.getAttribute('method'); /get/i.test(s) || (/post/i.test(s) ? i.body.delete('_method') : i.body.set('_method', s), i.method = 'post') }, { once: !0 }) } }); const De = 'top'; const Be = 'bottom'; const $e = 'right'; const je = 'left'; const He = 'auto'; const qe = [De, Be, $e, je]; const Ve = 'start'; const We = 'end'; const Ke = 'clippingParents'; const ze = 'viewport'; const Ue = 'popper'; const Ge = 'reference'; const Xe = qe.reduce(function (e, t) { return e.concat([t + '-' + Ve, t + '-' + We]) }, []); const Qe = [].concat(qe, [He]).reduce(function (e, t) { return e.concat([t, t + '-' + Ve, t + '-' + We]) }, []); const Ye = 'beforeRead'; const Je = 'read'; const Ze = 'afterRead'; const et = 'beforeMain'; const tt = 'main'; const it = 'afterMain'; const st = 'beforeWrite'; const nt = 'write'; const rt = 'afterWrite'; const ot = [Ye, Je, Ze, et, tt, it, st, nt, rt]; function at (e) { return e ? (e.nodeName || '').toLowerCase() : null } function ct (e) { if (e == null) return window; if (e.toString() !== '[object Window]') { const t = e.ownerDocument; return t && t.defaultView || window } return e } function lt (e) { return e instanceof ct(e).Element || e instanceof Element } function ht (e) { return e instanceof ct(e).HTMLElement || e instanceof HTMLElement } function dt (e) { return typeof ShadowRoot !== 'undefined' && (e instanceof ct(e).ShadowRoot || e instanceof ShadowRoot) } const ut = { name: 'applyStyles', enabled: !0, phase: 'write', fn: function (e) { const t = e.state; Object.keys(t.elements).forEach(function (e) { const i = t.styles[e] || {}; const s = t.attributes[e] || {}; const n = t.elements[e]; ht(n) && at(n) && (Object.assign(n.style, i), Object.keys(s).forEach(function (e) { const t = s[e]; !1 === t ? n.removeAttribute(e) : n.setAttribute(e, !0 === t ? '' : t) })) }) }, effect: function (e) { const t = e.state; const i = { popper: { position: t.options.strategy, left: '0', top: '0', margin: '0' }, arrow: { position: 'absolute' }, reference: {} }; return Object.assign(t.elements.popper.style, i.popper), t.styles = i, t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow), function () { Object.keys(t.elements).forEach(function (e) { const s = t.elements[e]; const n = t.attributes[e] || {}; const r = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce(function (e, t) { return e[t] = '', e }, {}); ht(s) && at(s) && (Object.assign(s.style, r), Object.keys(n).forEach(function (e) { s.removeAttribute(e) })) }) } }, requires: ['computeStyles'] }; function mt (e) { return e.split('-')[0] } const pt = Math.max; const ft = Math.min; const gt = Math.round; function bt () { const e = navigator.userAgentData; return e != null && e.brands ? e.brands.map(function (e) { return e.brand + '/' + e.version }).join(' ') : navigator.userAgent } function vt () { return !/^((?!chrome|android).)*safari/i.test(bt()) } function yt (e, t, i) { void 0 === t && (t = !1), void 0 === i && (i = !1); const s = e.getBoundingClientRect(); let n = 1; let r = 1; t && ht(e) && (n = e.offsetWidth > 0 && gt(s.width) / e.offsetWidth || 1, r = e.offsetHeight > 0 && gt(s.height) / e.offsetHeight || 1); const o = (lt(e) ? ct(e) : window).visualViewport; const a = !vt() && i; const c = (s.left + (a && o ? o.offsetLeft : 0)) / n; const l = (s.top + (a && o ? o.offsetTop : 0)) / r; const h = s.width / n; const d = s.height / r; return { width: h, height: d, top: l, right: c + h, bottom: l + d, left: c, x: c, y: l } } function wt (e) { const t = yt(e); let i = e.offsetWidth; let s = e.offsetHeight; return Math.abs(t.width - i) <= 1 && (i = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), { x: e.offsetLeft, y: e.offsetTop, width: i, height: s } } function _t (e, t) { const i = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (i && dt(i)) { let s = t; do { if (s && e.isSameNode(s)) return !0; s = s.parentNode || s.host } while (s) } return !1 } function Et (e) { return ct(e).getComputedStyle(e) } function At (e) { return ['table', 'td', 'th'].indexOf(at(e)) >= 0 } function St (e) { return ((lt(e) ? e.ownerDocument : e.document) || window.document).documentElement } function Ct (e) { return at(e) === 'html' ? e : e.assignedSlot || e.parentNode || (dt(e) ? e.host : null) || St(e) } function kt (e) { return ht(e) && Et(e).position !== 'fixed' ? e.offsetParent : null } function Tt (e) { for (var t = ct(e), i = kt(e); i && At(i) && Et(i).position === 'static';)i = kt(i); return i && (at(i) === 'html' || at(i) === 'body' && Et(i).position === 'static') ? t : i || (function (e) { const t = /firefox/i.test(bt()); if (/Trident/i.test(bt()) && ht(e) && Et(e).position === 'fixed') return null; let i = Ct(e); for (dt(i) && (i = i.host); ht(i) && ['html', 'body'].indexOf(at(i)) < 0;) { const s = Et(i); if (s.transform !== 'none' || s.perspective !== 'none' || s.contain === 'paint' || ['transform', 'perspective'].indexOf(s.willChange) !== -1 || t && s.willChange === 'filter' || t && s.filter && s.filter !== 'none') return i; i = i.parentNode } return null }(e)) || t } function Lt (e) { return ['top', 'bottom'].indexOf(e) >= 0 ? 'x' : 'y' } function Ot (e, t, i) { return pt(e, ft(t, i)) } function Mt (e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function Pt (e, t) { return t.reduce(function (t, i) { return t[i] = e, t }, {}) } const xt = { name: 'arrow', enabled: !0, phase: 'main', fn: function (e) { let t; const i = e.state; const s = e.name; const n = e.options; const r = i.elements.arrow; const o = i.modifiersData.popperOffsets; const a = mt(i.placement); const c = Lt(a); const l = [je, $e].indexOf(a) >= 0 ? 'height' : 'width'; if (r && o) { const h = (function (e, t) { return Mt(typeof (e = typeof e === 'function' ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) !== 'number' ? e : Pt(e, qe)) }(n.padding, i)); const d = wt(r); const u = c === 'y' ? De : je; const m = c === 'y' ? Be : $e; const p = i.rects.reference[l] + i.rects.reference[c] - o[c] - i.rects.popper[l]; const f = o[c] - i.rects.reference[c]; const g = Tt(r); const b = g ? c === 'y' ? g.clientHeight || 0 : g.clientWidth || 0 : 0; const v = p / 2 - f / 2; const y = h[u]; const w = b - d[l] - h[m]; const _ = b / 2 - d[l] / 2 + v; const E = Ot(y, _, w); const A = c; i.modifiersData[s] = ((t = {})[A] = E, t.centerOffset = E - _, t) } }, effect: function (e) { const t = e.state; const i = e.options.element; let s = void 0 === i ? '[data-popper-arrow]' : i; s != null && (typeof s !== 'string' || (s = t.elements.popper.querySelector(s))) && (process.env.NODE_ENV !== 'production' && (ht(s) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '))), _t(t.elements.popper, s) ? t.elements.arrow = s : process.env.NODE_ENV !== 'production' && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '))) }, requires: ['popperOffsets'], requiresIfExists: ['preventOverflow'] }; function It (e) { return e.split('-')[1] } const Rt = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }; function Nt (e) { let t; const i = e.popper; const s = e.popperRect; const n = e.placement; const r = e.variation; const o = e.offsets; const a = e.position; const c = e.gpuAcceleration; const l = e.adaptive; const h = e.roundOffsets; const d = e.isFixed; const u = o.x; let m = void 0 === u ? 0 : u; const p = o.y; let f = void 0 === p ? 0 : p; const g = typeof h === 'function' ? h({ x: m, y: f }) : { x: m, y: f }; m = g.x, f = g.y; const b = o.hasOwnProperty('x'); const v = o.hasOwnProperty('y'); let y = je; let w = De; const _ = window; if (l) { let E = Tt(i); let A = 'clientHeight'; let S = 'clientWidth'; if (E === ct(i) && Et(E = St(i)).position !== 'static' && a === 'absolute' && (A = 'scrollHeight', S = 'scrollWidth'), n === De || (n === je || n === $e) && r === We)w = Be, f -= (d && E === _ && _.visualViewport ? _.visualViewport.height : E[A]) - s.height, f *= c ? 1 : -1; if (n === je || (n === De || n === Be) && r === We)y = $e, m -= (d && E === _ && _.visualViewport ? _.visualViewport.width : E[S]) - s.width, m *= c ? 1 : -1 } let C; const k = Object.assign({ position: a }, l && Rt); const T = !0 === h ? (function (e) { const t = e.x; const i = e.y; const s = window.devicePixelRatio || 1; return { x: gt(t * s) / s || 0, y: gt(i * s) / s || 0 } }({ x: m, y: f })) : { x: m, y: f }; return m = T.x, f = T.y, c ? Object.assign({}, k, ((C = {})[w] = v ? '0' : '', C[y] = b ? '0' : '', C.transform = (_.devicePixelRatio || 1) <= 1 ? 'translate(' + m + 'px, ' + f + 'px)' : 'translate3d(' + m + 'px, ' + f + 'px, 0)', C)) : Object.assign({}, k, ((t = {})[w] = v ? f + 'px' : '', t[y] = b ? m + 'px' : '', t.transform = '', t)) } const Ft = { name: 'computeStyles', enabled: !0, phase: 'beforeWrite', fn: function (e) { const t = e.state; const i = e.options; const s = i.gpuAcceleration; const n = void 0 === s || s; const r = i.adaptive; const o = void 0 === r || r; const a = i.roundOffsets; const c = void 0 === a || a; if (process.env.NODE_ENV !== 'production') { const l = Et(t.elements.popper).transitionProperty || ''; o && ['transform', 'top', 'right', 'bottom', 'left'].some(function (e) { return l.indexOf(e) >= 0 }) && console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' ')) } const h = { placement: mt(t.placement), variation: It(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: n, isFixed: t.options.strategy === 'fixed' }; t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Nt(Object.assign({}, h, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: c })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Nt(Object.assign({}, h, { offsets: t.modifiersData.arrow, position: 'absolute', adaptive: !1, roundOffsets: c })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-placement': t.placement }) }, data: {} }; const Dt = { passive: !0 }; const Bt = { name: 'eventListeners', enabled: !0, phase: 'write', fn: function () {}, effect: function (e) { const t = e.state; const i = e.instance; const s = e.options; const n = s.scroll; const r = void 0 === n || n; const o = s.resize; const a = void 0 === o || o; const c = ct(t.elements.popper); const l = [].concat(t.scrollParents.reference, t.scrollParents.popper); return r && l.forEach(function (e) { e.addEventListener('scroll', i.update, Dt) }), a && c.addEventListener('resize', i.update, Dt), function () { r && l.forEach(function (e) { e.removeEventListener('scroll', i.update, Dt) }), a && c.removeEventListener('resize', i.update, Dt) } }, data: {} }; const $t = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; function jt (e) { return e.replace(/left|right|bottom|top/g, function (e) { return $t[e] }) } const Ht = { start: 'end', end: 'start' }; function qt (e) { return e.replace(/start|end/g, function (e) { return Ht[e] }) } function Vt (e) { const t = ct(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function Wt (e) { return yt(St(e)).left + Vt(e).scrollLeft } function Kt (e) { const t = Et(e); const i = t.overflow; const s = t.overflowX; const n = t.overflowY; return /auto|scroll|overlay|hidden/.test(i + n + s) } function zt (e) { return ['html', 'body', '#document'].indexOf(at(e)) >= 0 ? e.ownerDocument.body : ht(e) && Kt(e) ? e : zt(Ct(e)) } function Ut (e, t) { let i; void 0 === t && (t = []); const s = zt(e); const n = s === ((i = e.ownerDocument) == null ? void 0 : i.body); const r = ct(s); const o = n ? [r].concat(r.visualViewport || [], Kt(s) ? s : []) : s; const a = t.concat(o); return n ? a : a.concat(Ut(Ct(o))) } function Gt (e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Xt (e, t, i) { return t === ze ? Gt(function (e, t) { const i = ct(e); const s = St(e); const n = i.visualViewport; let r = s.clientWidth; let o = s.clientHeight; let a = 0; let c = 0; if (n) { r = n.width, o = n.height; const l = vt(); (l || !l && t === 'fixed') && (a = n.offsetLeft, c = n.offsetTop) } return { width: r, height: o, x: a + Wt(e), y: c } }(e, i)) : lt(t) ? (function (e, t) { const i = yt(e, !1, t === 'fixed'); return i.top = i.top + e.clientTop, i.left = i.left + e.clientLeft, i.bottom = i.top + e.clientHeight, i.right = i.left + e.clientWidth, i.width = e.clientWidth, i.height = e.clientHeight, i.x = i.left, i.y = i.top, i }(t, i)) : Gt(function (e) { let t; const i = St(e); const s = Vt(e); const n = (t = e.ownerDocument) == null ? void 0 : t.body; const r = pt(i.scrollWidth, i.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0); const o = pt(i.scrollHeight, i.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0); let a = -s.scrollLeft + Wt(e); const c = -s.scrollTop; return Et(n || i).direction === 'rtl' && (a += pt(i.clientWidth, n ? n.clientWidth : 0) - r), { width: r, height: o, x: a, y: c } }(St(e))) } function Qt (e, t, i, s) { const n = t === 'clippingParents' ? (function (e) { const t = Ut(Ct(e)); const i = ['absolute', 'fixed'].indexOf(Et(e).position) >= 0 && ht(e) ? Tt(e) : e; return lt(i) ? t.filter(function (e) { return lt(e) && _t(e, i) && at(e) !== 'body' }) : [] }(e)) : [].concat(t); const r = [].concat(n, [i]); const o = r[0]; const a = r.reduce(function (t, i) { const n = Xt(e, i, s); return t.top = pt(n.top, t.top), t.right = ft(n.right, t.right), t.bottom = ft(n.bottom, t.bottom), t.left = pt(n.left, t.left), t }, Xt(e, o, s)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function Yt (e) { let t; const i = e.reference; const s = e.element; const n = e.placement; const r = n ? mt(n) : null; const o = n ? It(n) : null; const a = i.x + i.width / 2 - s.width / 2; const c = i.y + i.height / 2 - s.height / 2; switch (r) { case De:t = { x: a, y: i.y - s.height }; break; case Be:t = { x: a, y: i.y + i.height }; break; case $e:t = { x: i.x + i.width, y: c }; break; case je:t = { x: i.x - s.width, y: c }; break; default:t = { x: i.x, y: i.y } } const l = r ? Lt(r) : null; if (l != null) { const h = l === 'y' ? 'height' : 'width'; switch (o) { case Ve:t[l] = t[l] - (i[h] / 2 - s[h] / 2); break; case We:t[l] = t[l] + (i[h] / 2 - s[h] / 2) } } return t } function Jt (e, t) { void 0 === t && (t = {}); const i = t; const s = i.placement; const n = void 0 === s ? e.placement : s; const r = i.strategy; const o = void 0 === r ? e.strategy : r; const a = i.boundary; const c = void 0 === a ? Ke : a; const l = i.rootBoundary; const h = void 0 === l ? ze : l; const d = i.elementContext; const u = void 0 === d ? Ue : d; const m = i.altBoundary; const p = void 0 !== m && m; const f = i.padding; const g = void 0 === f ? 0 : f; const b = Mt(typeof g !== 'number' ? g : Pt(g, qe)); const v = u === Ue ? Ge : Ue; const y = e.rects.popper; const w = e.elements[p ? v : u]; const _ = Qt(lt(w) ? w : w.contextElement || St(e.elements.popper), c, h, o); const E = yt(e.elements.reference); const A = Yt({ reference: E, element: y, strategy: 'absolute', placement: n }); const S = Gt(Object.assign({}, y, A)); const C = u === Ue ? S : E; const k = { top: _.top - C.top + b.top, bottom: C.bottom - _.bottom + b.bottom, left: _.left - C.left + b.left, right: C.right - _.right + b.right }; const T = e.modifiersData.offset; if (u === Ue && T) { const L = T[n]; Object.keys(k).forEach(function (e) { const t = [$e, Be].indexOf(e) >= 0 ? 1 : -1; const i = [De, Be].indexOf(e) >= 0 ? 'y' : 'x'; k[e] += L[i] * t }) } return k } function Zt (e, t) { void 0 === t && (t = {}); const i = t; const s = i.placement; const n = i.boundary; const r = i.rootBoundary; const o = i.padding; const a = i.flipVariations; const c = i.allowedAutoPlacements; const l = void 0 === c ? Qe : c; const h = It(s); const d = h ? a ? Xe : Xe.filter(function (e) { return It(e) === h }) : qe; let u = d.filter(function (e) { return l.indexOf(e) >= 0 }); u.length === 0 && (u = d, process.env.NODE_ENV !== 'production' && console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '))); const m = u.reduce(function (t, i) { return t[i] = Jt(e, { placement: i, boundary: n, rootBoundary: r, padding: o })[mt(i)], t }, {}); return Object.keys(m).sort(function (e, t) { return m[e] - m[t] }) } const ei = { name: 'flip', enabled: !0, phase: 'main', fn: function (e) { const t = e.state; const i = e.options; const s = e.name; if (!t.modifiersData[s]._skip) { for (var n = i.mainAxis, r = void 0 === n || n, o = i.altAxis, a = void 0 === o || o, c = i.fallbackPlacements, l = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, m = i.flipVariations, p = void 0 === m || m, f = i.allowedAutoPlacements, g = t.options.placement, b = mt(g), v = c || (b === g || !p ? [jt(g)] : (function (e) { if (mt(e) === He) return []; const t = jt(e); return [qt(e), t, qt(t)] }(g))), y = [g].concat(v).reduce(function (e, i) { return e.concat(mt(i) === He ? Zt(t, { placement: i, boundary: h, rootBoundary: d, padding: l, flipVariations: p, allowedAutoPlacements: f }) : i) }, []), w = t.rects.reference, _ = t.rects.popper, E = new Map(), A = !0, S = y[0], C = 0; C < y.length; C++) { const k = y[C]; const T = mt(k); const L = It(k) === Ve; const O = [De, Be].indexOf(T) >= 0; const M = O ? 'width' : 'height'; const P = Jt(t, { placement: k, boundary: h, rootBoundary: d, altBoundary: u, padding: l }); let x = O ? L ? $e : je : L ? Be : De; w[M] > _[M] && (x = jt(x)); const I = jt(x); const R = []; if (r && R.push(P[T] <= 0), a && R.push(P[x] <= 0, P[I] <= 0), R.every(function (e) { return e })) { S = k, A = !1; break }E.set(k, R) } if (A) for (let N = function (e) { const t = y.find(function (t) { const i = E.get(t); if (i) return i.slice(0, e).every(function (e) { return e }) }); if (t) return S = t, 'break' }, F = p ? 3 : 1; F > 0; F--) { if (N(F) === 'break') break }t.placement !== S && (t.modifiersData[s]._skip = !0, t.placement = S, t.reset = !0) } }, requiresIfExists: ['offset'], data: { _skip: !1 } }; function ti (e, t, i) { return void 0 === i && (i = { x: 0, y: 0 }), { top: e.top - t.height - i.y, right: e.right - t.width + i.x, bottom: e.bottom - t.height + i.y, left: e.left - t.width - i.x } } function ii (e) { return [De, $e, Be, je].some(function (t) { return e[t] >= 0 }) } const si = { name: 'hide', enabled: !0, phase: 'main', requiresIfExists: ['preventOverflow'], fn: function (e) { const t = e.state; const i = e.name; const s = t.rects.reference; const n = t.rects.popper; const r = t.modifiersData.preventOverflow; const o = Jt(t, { elementContext: 'reference' }); const a = Jt(t, { altBoundary: !0 }); const c = ti(o, s); const l = ti(a, n, r); const h = ii(c); const d = ii(l); t.modifiersData[i] = { referenceClippingOffsets: c, popperEscapeOffsets: l, isReferenceHidden: h, hasPopperEscaped: d }, t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-reference-hidden': h, 'data-popper-escaped': d }) } }; const ni = { name: 'offset', enabled: !0, phase: 'main', requires: ['popperOffsets'], fn: function (e) { const t = e.state; const i = e.options; const s = e.name; const n = i.offset; const r = void 0 === n ? [0, 0] : n; const o = Qe.reduce(function (e, i) { return e[i] = (function (e, t, i) { const s = mt(e); const n = [je, De].indexOf(s) >= 0 ? -1 : 1; const r = typeof i==='function' ? i(Object.assign({}, t, { placement: e })) : i; let o = r[0]; let a = r[1]; return o = o || 0, a = (a || 0) * n, [je, $e].indexOf(s) >= 0 ? { x: a, y: o } : { x: o, y: a } }(i, t.rects, r)), e }, {}); const a = o[t.placement]; const c = a.x; const l = a.y; t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c, t.modifiersData.popperOffsets.y += l), t.modifiersData[s] = o } }; const ri = { name: 'popperOffsets', enabled: !0, phase: 'read', fn: function (e) { const t = e.state; const i = e.name; t.modifiersData[i] = Yt({ reference: t.rects.reference, element: t.rects.popper, strategy: 'absolute', placement: t.placement }) }, data: {} }; const oi = { name: 'preventOverflow', enabled: !0, phase: 'main', fn: function (e) { const t = e.state; const i = e.options; const s = e.name; const n = i.mainAxis; const r = void 0 === n || n; const o = i.altAxis; const a = void 0 !== o && o; const c = i.boundary; const l = i.rootBoundary; const h = i.altBoundary; const d = i.padding; const u = i.tether; const m = void 0 === u || u; const p = i.tetherOffset; const f = void 0 === p ? 0 : p; const g = Jt(t, { boundary: c, rootBoundary: l, padding: d, altBoundary: h }); const b = mt(t.placement); const v = It(t.placement); const y = !v; const w = Lt(b); const _ = w === 'x' ? 'y' : 'x'; const E = t.modifiersData.popperOffsets; const A = t.rects.reference; const S = t.rects.popper; const C = typeof f === 'function' ? f(Object.assign({}, t.rects, { placement: t.placement })) : f; const k = typeof C === 'number' ? { mainAxis: C, altAxis: C } : Object.assign({ mainAxis: 0, altAxis: 0 }, C); const T = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null; const L = { x: 0, y: 0 }; if (E) { if (r) { let O; const M = w === 'y' ? De : je; const P = w === 'y' ? Be : $e; const x = w === 'y' ? 'height' : 'width'; const I = E[w]; const R = I + g[M]; const N = I - g[P]; const F = m ? -S[x] / 2 : 0; const D = v === Ve ? A[x] : S[x]; const B = v === Ve ? -S[x] : -A[x]; const $ = t.elements.arrow; const j = m && $ ? wt($) : { width: 0, height: 0 }; const H = t.modifiersData['arrow#persistent'] ? t.modifiersData['arrow#persistent'].padding : { top: 0, right: 0, bottom: 0, left: 0 }; const q = H[M]; const V = H[P]; const W = Ot(0, A[x], j[x]); const K = y ? A[x] / 2 - F - W - q - k.mainAxis : D - W - q - k.mainAxis; const z = y ? -A[x] / 2 + F + W + V + k.mainAxis : B + W + V + k.mainAxis; const U = t.elements.arrow && Tt(t.elements.arrow); const G = U ? w === 'y' ? U.clientTop || 0 : U.clientLeft || 0 : 0; const X = (O = T == null ? void 0 : T[w]) != null ? O : 0; const Q = I + z - X; const Y = Ot(m ? ft(R, I + K - X - G) : R, I, m ? pt(N, Q) : N); E[w] = Y, L[w] = Y - I } if (a) { let J; const Z = w === 'x' ? De : je; const ee = w === 'x' ? Be : $e; const te = E[_]; const ie = _ === 'y' ? 'height' : 'width'; const se = te + g[Z]; const ne = te - g[ee]; const re = [De, je].indexOf(b) !== -1; const oe = (J = T == null ? void 0 : T[_]) != null ? J : 0; const ae = re ? se : te - A[ie] - S[ie] - oe + k.altAxis; const ce = re ? te + A[ie] + S[ie] - oe - k.altAxis : ne; const le = m && re ? (function (e, t, i) { const s = Ot(e, t, i); return s > i ? i : s }(ae, te, ce)) : Ot(m ? ae : se, te, m ? ce : ne); E[_] = le, L[_] = le - te }t.modifiersData[s] = L } }, requiresIfExists: ['offset'] }; function ai (e, t, i) { void 0 === i && (i = !1); let s; let n; const r = ht(t); const o = ht(t) && (function (e) { const t = e.getBoundingClientRect(); const i = gt(t.width) / e.offsetWidth || 1; const s = gt(t.height) / e.offsetHeight || 1; return i !== 1 || s !== 1 }(t)); const a = St(t); const c = yt(e, o, i); let l = { scrollLeft: 0, scrollTop: 0 }; let h = { x: 0, y: 0 }; return (r || !r && !i) && ((at(t) !== 'body' || Kt(a)) && (l = (s = t) !== ct(s) && ht(s) ? { scrollLeft: (n = s).scrollLeft, scrollTop: n.scrollTop } : Vt(s)), ht(t) ? ((h = yt(t, !0)).x += t.clientLeft, h.y += t.clientTop) : a && (h.x = Wt(a))), { x: c.left + l.scrollLeft - h.x, y: c.top + l.scrollTop - h.y, width: c.width, height: c.height } } function ci (e) { const t = new Map(); const i = new Set(); const s = []; function n (e) { i.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) { if (!i.has(e)) { const s = t.get(e); s && n(s) } }), s.push(e) } return e.forEach(function (e) { t.set(e.name, e) }), e.forEach(function (e) { i.has(e.name) || n(e) }), s } function li (e) { for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)i[s - 1] = arguments[s]; return [].concat(i).reduce(function (e, t) { return e.replace(/%s/, t) }, e) } const hi = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s'; const di = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options']; const ui = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.'; const mi = { placement: 'bottom', modifiers: [], strategy: 'absolute' }; function pi () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return !t.some(function (e) { return !(e && typeof e.getBoundingClientRect === 'function') }) } function fi (e) { void 0 === e && (e = {}); const t = e; const i = t.defaultModifiers; const s = void 0 === i ? [] : i; const n = t.defaultOptions; const r = void 0 === n ? mi : n; return function (e, t, i) { void 0 === i && (i = r); let n; let o; let a = { placement: 'bottom', orderedModifiers: [], options: Object.assign({}, mi, r), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }; let c = []; let l = !1; var h = { state: a, setOptions: function (i) { const n = typeof i === 'function' ? i(a.options) : i; d(), a.options = Object.assign({}, r, a.options, n), a.scrollParents = { reference: lt(e) ? Ut(e) : e.contextElement ? Ut(e.contextElement) : [], popper: Ut(t) }; let o; let l; let u; const m = (function (e) { const t = ci(e); return ot.reduce(function (e, i) { return e.concat(t.filter(function (e) { return e.phase === i })) }, []) }(function (e) { const t = e.reduce(function (e, t) { const i = e[t.name]; return e[t.name] = i ? Object.assign({}, i, t, { options: Object.assign({}, i.options, t.options), data: Object.assign({}, i.data, t.data) }) : t, e }, {}); return Object.keys(t).map(function (e) { return t[e] }) }([].concat(s, a.options.modifiers)))); if (a.orderedModifiers = m.filter(function (e) { return e.enabled }), process.env.NODE_ENV !== 'production') { if ((function (e) { e.forEach(function (t) { [].concat(Object.keys(t), di).filter(function (e, t, i) { return i.indexOf(e) === t }).forEach(function (i) { switch (i) { case 'name':typeof t.name !== 'string' && console.error(li(hi, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"')); break; case 'enabled':typeof t.enabled !== 'boolean' && console.error(li(hi, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"')); break; case 'phase':ot.indexOf(t.phase) < 0 && console.error(li(hi, t.name, '"phase"', 'either ' + ot.join(', '), '"' + String(t.phase) + '"')); break; case 'fn':typeof t.fn !== 'function' && console.error(li(hi, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"')); break; case 'effect':t.effect != null && typeof t.effect !== 'function' && console.error(li(hi, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"')); break; case 'requires':t.requires == null || Array.isArray(t.requires) || console.error(li(hi, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"')); break; case 'requiresIfExists':Array.isArray(t.requiresIfExists) || console.error(li(hi, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"')); break; case 'options':case 'data':break; default:console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + di.map(function (e) { return '"' + e + '"' }).join(', ') + '; but "' + i + '" was provided.') }t.requires && t.requires.forEach(function (i) { e.find(function (e) { return e.name === i }) == null && console.error(li('Popper: modifier "%s" requires "%s", but "%s" modifier is not available', String(t.name), i, i)) }) }) }) }((o = [].concat(m, a.options.modifiers), l = function (e) { return e.name }, u = new Set(), o.filter(function (e) { const t = l(e); if (!u.has(t)) return u.add(t), !0 })))), mt(a.options.placement) === He)a.orderedModifiers.find(function (e) { return e.name === 'flip' }) || console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' ')); const p = Et(t); [p.marginTop, p.marginRight, p.marginBottom, p.marginLeft].some(function (e) { return parseFloat(e) }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' ')) } return a.orderedModifiers.forEach(function (e) { const t = e.name; const i = e.options; const s = void 0 === i ? {} : i; const n = e.effect; if (typeof n === 'function') { const r = n({ state: a, name: t, instance: h, options: s }); const o = function () {}; c.push(r || o) } }), h.update() }, forceUpdate: function () { if (!l) { const e = a.elements; const t = e.reference; const i = e.popper; if (pi(t, i)) { a.rects = { reference: ai(t, Tt(i), a.options.strategy === 'fixed'), popper: wt(i) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (e) { return a.modifiersData[e.name] = Object.assign({}, e.data) }); for (let s = 0, n = 0; n < a.orderedModifiers.length; n++) { if (process.env.NODE_ENV !== 'production' && (s += 1) > 100) { console.error('Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.'); break } if (!0 !== a.reset) { const r = a.orderedModifiers[n]; const o = r.fn; const c = r.options; const d = void 0 === c ? {} : c; const u = r.name; typeof o === 'function' && (a = o({ state: a, options: d, name: u, instance: h }) || a) } else a.reset = !1, n = -1 } } else process.env.NODE_ENV !== 'production' && console.error(ui) } }, update: (n = function () { return new Promise(function (e) { h.forceUpdate(), e(a) }) }, function () { return o || (o = new Promise(function (e) { Promise.resolve().then(function () { o = void 0, e(n()) }) })), o }), destroy: function () { d(), l = !0 } }; if (!pi(e, t)) return process.env.NODE_ENV !== 'production' && console.error(ui), h; function d () { c.forEach(function (e) { return e() }), c = [] } return h.setOptions(i).then(function (e) { !l && i.onFirstUpdate && i.onFirstUpdate(e) }), h } } const gi = fi(); const bi = fi({ defaultModifiers: [Bt, ri, Ft, ut] }); const vi = fi({ defaultModifiers: [Bt, ri, Ft, ut, ni, ei, oi, xt, si] }); const yi = Object.freeze({ __proto__: null, popperGenerator: fi, detectOverflow: Jt, createPopperBase: gi, createPopper: vi, createPopperLite: bi, top: De, bottom: Be, right: $e, left: je, auto: He, basePlacements: qe, start: Ve, end: We, clippingParents: Ke, viewport: ze, popper: Ue, reference: Ge, variationPlacements: Xe, placements: Qe, beforeRead: Ye, read: Je, afterRead: Ze, beforeMain: et, main: tt, afterMain: it, beforeWrite: st, write: nt, afterWrite: rt, modifierPhases: ot, applyStyles: ut, arrow: xt, computeStyles: Ft, eventListeners: Bt, flip: ei, hide: si, offset: ni, popperOffsets: ri, preventOverflow: oi })
/*!
  * Bootstrap v5.2.3 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
const wi = 'transitionend'; const _i = e => { let t = e.getAttribute('data-bs-target'); if (!t || t === '#') { let i = e.getAttribute('href'); if (!i || !i.includes('#') && !i.startsWith('.')) return null; i.includes('#') && !i.startsWith('#') && (i = `#${i.split('#')[1]}`), t = i && i !== '#' ? i.trim() : null } return t }; const Ei = e => { const t = _i(e); return t && document.querySelector(t) ? t : null }; const Ai = e => { const t = _i(e); return t ? document.querySelector(t) : null }; const Si = e => { e.dispatchEvent(new Event(wi)) }; const Ci = e => !(!e || typeof e !== 'object') && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType); const ki = e => Ci(e) ? e.jquery ? e[0] : e : typeof e === 'string' && e.length > 0 ? document.querySelector(e) : null; const Ti = e => { if (!Ci(e) || e.getClientRects().length === 0) return !1; const t = getComputedStyle(e).getPropertyValue('visibility') === 'visible'; const i = e.closest('details:not([open])'); if (!i) return t; if (i !== e) { const t = e.closest('summary'); if (t && t.parentNode !== i) return !1; if (t === null) return !1 } return t }; const Li = e => !e || e.nodeType !== Node.ELEMENT_NODE || (!!e.classList.contains('disabled') || (void 0 !== e.disabled ? e.disabled : e.hasAttribute('disabled') && e.getAttribute('disabled') !== 'false')); const Oi = e => { if (!document.documentElement.attachShadow) return null; if (typeof e.getRootNode === 'function') { const t = e.getRootNode(); return t instanceof ShadowRoot ? t : null } return e instanceof ShadowRoot ? e : e.parentNode ? Oi(e.parentNode) : null }; const Mi = () => {}; const Pi = e => { e.offsetHeight }; const xi = () => window.jQuery && !document.body.hasAttribute('data-bs-no-jquery') ? window.jQuery : null; const Ii = []; const Ri = () => document.documentElement.dir === 'rtl'; const Ni = e => { let t; t = () => { const t = xi(); if (t) { const i = e.NAME; const s = t.fn[i]; t.fn[i] = e.jQueryInterface, t.fn[i].Constructor = e, t.fn[i].noConflict = () => (t.fn[i] = s, e.jQueryInterface) } }, document.readyState === 'loading' ? (Ii.length || document.addEventListener('DOMContentLoaded', () => { for (const e of Ii)e() }), Ii.push(t)) : t() }; const Fi = e => { typeof e === 'function' && e() }; const Di = (e, t, i = !0) => { if (!i) return void Fi(e); const s = (e => { if (!e) return 0; let { transitionDuration: t, transitionDelay: i } = window.getComputedStyle(e); const s = Number.parseFloat(t); const n = Number.parseFloat(i); return s || n ? (t = t.split(',')[0], i = i.split(',')[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(i))) : 0 })(t) + 5; let n = !1; const r = ({ target: i }) => { i === t && (n = !0, t.removeEventListener(wi, r), Fi(e)) }; t.addEventListener(wi, r), setTimeout(() => { n || Si(t) }, s) }; const Bi = (e, t, i, s) => { const n = e.length; let r = e.indexOf(t); return r === -1 ? !i && s ? e[n - 1] : e[0] : (r += i ? 1 : -1, s && (r = (r + n) % n), e[Math.max(0, Math.min(r, n - 1))]) }; const $i = /[^.]*(?=\..*)\.|.*/; const ji = /\..*/; const Hi = /::\d+$/; const qi = {}; let Vi = 1; const Wi = { mouseenter: 'mouseover', mouseleave: 'mouseout' }; const Ki = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']); function zi (e, t) { return t && `${t}::${Vi++}` || e.uidEvent || Vi++ } function Ui (e) { const t = zi(e); return e.uidEvent = t, qi[t] = qi[t] || {}, qi[t] } function Gi (e, t, i = null) { return Object.values(e).find(e => e.callable === t && e.delegationSelector === i) } function Xi (e, t, i) { const s = typeof t === 'string'; const n = s ? i : t || i; let r = Zi(e); return Ki.has(r) || (r = e), [s, n, r] } function Qi (e, t, i, s, n) { if (typeof t !== 'string' || !e) return; let [r, o, a] = Xi(t, i, s); if (t in Wi) { const e = e => function (t) { if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t) }; o = e(o) } const c = Ui(e); const l = c[a] || (c[a] = {}); const h = Gi(l, o, r ? i : null); if (h) return void (h.oneOff = h.oneOff && n); const d = zi(o, t.replace($i, '')); const u = r ? (function (e, t, i) { return function s (n) { const r = e.querySelectorAll(t); for (let { target: o } = n; o && o !== this; o = o.parentNode) for (const a of r) if (a === o) return ts(n, { delegateTarget: o }), s.oneOff && es.off(e, n.type, t, i), i.apply(o, [n]) } }(e, i, o)) : (function (e, t) { return function i (s) { return ts(s, { delegateTarget: e }), i.oneOff && es.off(e, s.type, t), t.apply(e, [s]) } }(e, o)); u.delegationSelector = r ? i : null, u.callable = o, u.oneOff = n, u.uidEvent = d, l[d] = u, e.addEventListener(a, u, r) } function Yi (e, t, i, s, n) { const r = Gi(t[i], s, n); r && (e.removeEventListener(i, r, Boolean(n)), delete t[i][r.uidEvent]) } function Ji (e, t, i, s) { const n = t[i] || {}; for (const r of Object.keys(n)) if (r.includes(s)) { const s = n[r]; Yi(e, t, i, s.callable, s.delegationSelector) } } function Zi (e) { return e = e.replace(ji, ''), Wi[e] || e } const es = { on (e, t, i, s) { Qi(e, t, i, s, !1) }, one (e, t, i, s) { Qi(e, t, i, s, !0) }, off (e, t, i, s) { if (typeof t !== 'string' || !e) return; const [n, r, o] = Xi(t, i, s); const a = o !== t; const c = Ui(e); const l = c[o] || {}; const h = t.startsWith('.'); if (void 0 === r) { if (h) for (const i of Object.keys(c))Ji(e, c, i, t.slice(1)); for (const i of Object.keys(l)) { const s = i.replace(Hi, ''); if (!a || t.includes(s)) { const t = l[i]; Yi(e, c, o, t.callable, t.delegationSelector) } } } else { if (!Object.keys(l).length) return; Yi(e, c, o, r, n ? i : null) } }, trigger (e, t, i) { if (typeof t !== 'string' || !e) return null; const s = xi(); let n = null; let r = !0; let o = !0; let a = !1; t !== Zi(t) && s && (n = s.Event(t, i), s(e).trigger(n), r = !n.isPropagationStopped(), o = !n.isImmediatePropagationStopped(), a = n.isDefaultPrevented()); let c = new Event(t, { bubbles: r, cancelable: !0 }); return c = ts(c, i), a && c.preventDefault(), o && e.dispatchEvent(c), c.defaultPrevented && n && n.preventDefault(), c } }; function ts (e, t) { for (const [i, s] of Object.entries(t || {})) try { e[i] = s } catch (t) { Object.defineProperty(e, i, { configurable: !0, get: () => s }) } return e } const is = new Map(); const ss = { set (e, t, i) { is.has(e) || is.set(e, new Map()); const s = is.get(e); s.has(t) || s.size === 0 ? s.set(t, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`) }, get: (e, t) => is.has(e) && is.get(e).get(t) || null, remove (e, t) { if (!is.has(e)) return; const i = is.get(e); i.delete(t), i.size === 0 && is.delete(e) } }; function ns (e) { if (e === 'true') return !0; if (e === 'false') return !1; if (e === Number(e).toString()) return Number(e); if (e === '' || e === 'null') return null; if (typeof e !== 'string') return e; try { return JSON.parse(decodeURIComponent(e)) } catch (t) { return e } } function rs (e) { return e.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`) } const os = { setDataAttribute (e, t, i) { e.setAttribute(`data-bs-${rs(t)}`, i) }, removeDataAttribute (e, t) { e.removeAttribute(`data-bs-${rs(t)}`) }, getDataAttributes (e) { if (!e) return {}; const t = {}; const i = Object.keys(e.dataset).filter(e => e.startsWith('bs') && !e.startsWith('bsConfig')); for (const s of i) { let i = s.replace(/^bs/, ''); i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = ns(e.dataset[s]) } return t }, getDataAttribute: (e, t) => ns(e.getAttribute(`data-bs-${rs(t)}`)) }; class as {static get Default () { return {} } static get DefaultType () { return {} } static get NAME () { throw new Error('You have to implement the static method "NAME", for each component!') }_getConfig (e) { return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e }_configAfterMerge (e) { return e }_mergeConfigObj (e, t) { const i = Ci(t) ? os.getDataAttribute(t, 'config') : {}; return { ...this.constructor.Default, ...typeof i === 'object' ? i : {}, ...Ci(t) ? os.getDataAttributes(t) : {}, ...typeof e === 'object' ? e : {} } }_typeCheckConfig (e, t = this.constructor.DefaultType) { for (const s of Object.keys(t)) { const n = t[s]; const r = e[s]; const o = Ci(r) ? 'element' : (i = r) == null ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(n).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${n}".`) } let i }} class cs extends as {constructor (e, t) { super(), (e = ki(e)) && (this._element = e, this._config = this._getConfig(t), ss.set(this._element, this.constructor.DATA_KEY, this)) }dispose () { ss.remove(this._element, this.constructor.DATA_KEY), es.off(this._element, this.constructor.EVENT_KEY); for (const e of Object.getOwnPropertyNames(this)) this[e] = null }_queueCallback (e, t, i = !0) { Di(e, t, i) }_getConfig (e) { return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } static getInstance (e) { return ss.get(ki(e), this.DATA_KEY) } static getOrCreateInstance (e, t = {}) { return this.getInstance(e) || new this(e, typeof t === 'object' ? t : null) } static get VERSION () { return '5.2.3' } static get DATA_KEY () { return `bs.${this.NAME}` } static get EVENT_KEY () { return `.${this.DATA_KEY}` } static eventName (e) { return `${e}${this.EVENT_KEY}` }} const ls = (e, t = 'hide') => { const i = `click.dismiss${e.EVENT_KEY}`; const s = e.NAME; es.on(document, i, `[data-bs-dismiss="${s}"]`, function (i) { if (['A', 'AREA'].includes(this.tagName) && i.preventDefault(), Li(this)) return; const n = Ai(this) || this.closest(`.${s}`); e.getOrCreateInstance(n)[t]() }) }; const hs = '.bs.alert'; const ds = `close${hs}`; const us = `closed${hs}`; class ms extends cs {static get NAME () { return 'alert' }close () { if (es.trigger(this._element, ds).defaultPrevented) return; this._element.classList.remove('show'); const e = this._element.classList.contains('fade'); this._queueCallback(() => this._destroyElement(), this._element, e) }_destroyElement () { this._element.remove(), es.trigger(this._element, us), this.dispose() } static jQueryInterface (e) { return this.each(function () { const t = ms.getOrCreateInstance(this); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}ls(ms, 'close'), Ni(ms); const ps = '[data-bs-toggle="button"]'; class fs extends cs {static get NAME () { return 'button' }toggle () { this._element.setAttribute('aria-pressed', this._element.classList.toggle('active')) } static jQueryInterface (e) { return this.each(function () { const t = fs.getOrCreateInstance(this); e === 'toggle' && t[e]() }) }}es.on(document, 'click.bs.button.data-api', ps, e => { e.preventDefault(); const t = e.target.closest(ps); fs.getOrCreateInstance(t).toggle() }), Ni(fs); const gs = { find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)), findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e), children: (e, t) => [].concat(...e.children).filter(e => e.matches(t)), parents (e, t) { const i = []; let s = e.parentNode.closest(t); for (;s;)i.push(s), s = s.parentNode.closest(t); return i }, prev (e, t) { let i = e.previousElementSibling; for (;i;) { if (i.matches(t)) return [i]; i = i.previousElementSibling } return [] }, next (e, t) { let i = e.nextElementSibling; for (;i;) { if (i.matches(t)) return [i]; i = i.nextElementSibling } return [] }, focusableChildren (e) { const t = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(e => `${e}:not([tabindex^="-"])`).join(','); return this.find(t, e).filter(e => !Li(e) && Ti(e)) } }; const bs = '.bs.swipe'; const vs = `touchstart${bs}`; const ys = `touchmove${bs}`; const ws = `touchend${bs}`; const _s = `pointerdown${bs}`; const Es = `pointerup${bs}`; const As = { endCallback: null, leftCallback: null, rightCallback: null }; const Ss = { endCallback: '(function|null)', leftCallback: '(function|null)', rightCallback: '(function|null)' }; class Cs extends as {constructor (e, t) { super(), this._element = e, e && Cs.isSupported() && (this._config = this._getConfig(t), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents()) } static get Default () { return As } static get DefaultType () { return Ss } static get NAME () { return 'swipe' }dispose () { es.off(this._element, bs) }_start (e) { this._supportPointerEvents ? this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) : this._deltaX = e.touches[0].clientX }_end (e) { this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), Fi(this._config.endCallback) }_move (e) { this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX }_handleSwipe () { const e = Math.abs(this._deltaX); if (e <= 40) return; const t = e / this._deltaX; this._deltaX = 0, t && Fi(t > 0 ? this._config.rightCallback : this._config.leftCallback) }_initEvents () { this._supportPointerEvents ? (es.on(this._element, _s, e => this._start(e)), es.on(this._element, Es, e => this._end(e)), this._element.classList.add('pointer-event')) : (es.on(this._element, vs, e => this._start(e)), es.on(this._element, ys, e => this._move(e)), es.on(this._element, ws, e => this._end(e))) }_eventIsPointerPenTouch (e) { return this._supportPointerEvents && (e.pointerType === 'pen' || e.pointerType === 'touch') } static isSupported () { return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0 }} const ks = '.bs.carousel'; const Ts = '.data-api'; const Ls = 'next'; const Os = 'prev'; const Ms = 'left'; const Ps = 'right'; const xs = `slide${ks}`; const Is = `slid${ks}`; const Rs = `keydown${ks}`; const Ns = `mouseenter${ks}`; const Fs = `mouseleave${ks}`; const Ds = `dragstart${ks}`; const Bs = `load${ks}${Ts}`; const $s = `click${ks}${Ts}`; const js = 'carousel'; const Hs = 'active'; const qs = '.active'; const Vs = '.carousel-item'; const Ws = qs + Vs; const Ks = { ArrowLeft: Ps, ArrowRight: Ms }; const zs = { interval: 5e3, keyboard: !0, pause: 'hover', ride: !1, touch: !0, wrap: !0 }; const Us = { interval: '(number|boolean)', keyboard: 'boolean', pause: '(string|boolean)', ride: '(boolean|string)', touch: 'boolean', wrap: 'boolean' }; class Gs extends cs {constructor (e, t) { super(e, t), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = gs.findOne('.carousel-indicators', this._element), this._addEventListeners(), this._config.ride === js && this.cycle() } static get Default () { return zs } static get DefaultType () { return Us } static get NAME () { return 'carousel' }next () { this._slide(Ls) }nextWhenVisible () { !document.hidden && Ti(this._element) && this.next() }prev () { this._slide(Os) }pause () { this._isSliding && Si(this._element), this._clearInterval() }cycle () { this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval) }_maybeEnableCycle () { this._config.ride && (this._isSliding ? es.one(this._element, Is, () => this.cycle()) : this.cycle()) }to (e) { const t = this._getItems(); if (e > t.length - 1 || e < 0) return; if (this._isSliding) return void es.one(this._element, Is, () => this.to(e)); const i = this._getItemIndex(this._getActive()); if (i === e) return; const s = e > i ? Ls : Os; this._slide(s, t[e]) }dispose () { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() }_configAfterMerge (e) { return e.defaultInterval = e.interval, e }_addEventListeners () { this._config.keyboard && es.on(this._element, Rs, e => this._keydown(e)), this._config.pause === 'hover' && (es.on(this._element, Ns, () => this.pause()), es.on(this._element, Fs, () => this._maybeEnableCycle())), this._config.touch && Cs.isSupported() && this._addTouchEventListeners() }_addTouchEventListeners () { for (const e of gs.find('.carousel-item img', this._element))es.on(e, Ds, e => e.preventDefault()); const e = { leftCallback: () => this._slide(this._directionToOrder(Ms)), rightCallback: () => this._slide(this._directionToOrder(Ps)), endCallback: () => { this._config.pause === 'hover' && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval)) } }; this._swipeHelper = new Cs(this._element, e) }_keydown (e) { if (/input|textarea/i.test(e.target.tagName)) return; const t = Ks[e.key]; t && (e.preventDefault(), this._slide(this._directionToOrder(t))) }_getItemIndex (e) { return this._getItems().indexOf(e) }_setActiveIndicatorElement (e) { if (!this._indicatorsElement) return; const t = gs.findOne(qs, this._indicatorsElement); t.classList.remove(Hs), t.removeAttribute('aria-current'); const i = gs.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement); i && (i.classList.add(Hs), i.setAttribute('aria-current', 'true')) }_updateInterval () { const e = this._activeElement || this._getActive(); if (!e) return; const t = Number.parseInt(e.getAttribute('data-bs-interval'), 10); this._config.interval = t || this._config.defaultInterval }_slide (e, t = null) { if (this._isSliding) return; const i = this._getActive(); const s = e === Ls; const n = t || Bi(this._getItems(), i, s, this._config.wrap); if (n === i) return; const r = this._getItemIndex(n); const o = t => es.trigger(this._element, t, { relatedTarget: n, direction: this._orderToDirection(e), from: this._getItemIndex(i), to: r }); if (o(xs).defaultPrevented) return; if (!i || !n) return; const a = Boolean(this._interval); this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(r), this._activeElement = n; const c = s ? 'carousel-item-start' : 'carousel-item-end'; const l = s ? 'carousel-item-next' : 'carousel-item-prev'; n.classList.add(l), Pi(n), i.classList.add(c), n.classList.add(c); this._queueCallback(() => { n.classList.remove(c, l), n.classList.add(Hs), i.classList.remove(Hs, l, c), this._isSliding = !1, o(Is) }, i, this._isAnimated()), a && this.cycle() }_isAnimated () { return this._element.classList.contains('slide') }_getActive () { return gs.findOne(Ws, this._element) }_getItems () { return gs.find(Vs, this._element) }_clearInterval () { this._interval && (clearInterval(this._interval), this._interval = null) }_directionToOrder (e) { return Ri() ? e === Ms ? Os : Ls : e === Ms ? Ls : Os }_orderToDirection (e) { return Ri() ? e === Os ? Ms : Ps : e === Os ? Ps : Ms } static jQueryInterface (e) { return this.each(function () { const t = Gs.getOrCreateInstance(this, e); if (typeof e !== 'number') { if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } } else t.to(e) }) }}es.on(document, $s, '[data-bs-slide], [data-bs-slide-to]', function (e) { const t = Ai(this); if (!t || !t.classList.contains(js)) return; e.preventDefault(); const i = Gs.getOrCreateInstance(t); const s = this.getAttribute('data-bs-slide-to'); return s ? (i.to(s), void i._maybeEnableCycle()) : os.getDataAttribute(this, 'slide') === 'next' ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle()) }), es.on(window, Bs, () => { const e = gs.find('[data-bs-ride="carousel"]'); for (const t of e)Gs.getOrCreateInstance(t) }), Ni(Gs); const Xs = '.bs.collapse'; const Qs = `show${Xs}`; const Ys = `shown${Xs}`; const Js = `hide${Xs}`; const Zs = `hidden${Xs}`; const en = `click${Xs}.data-api`; const tn = 'show'; const sn = 'collapse'; const nn = 'collapsing'; const rn = `:scope .${sn} .${sn}`; const on = '[data-bs-toggle="collapse"]'; const an = { parent: null, toggle: !0 }; const cn = { parent: '(null|element)', toggle: 'boolean' }; class ln extends cs {constructor (e, t) { super(e, t), this._isTransitioning = !1, this._triggerArray = []; const i = gs.find(on); for (const e of i) { const t = Ei(e); const i = gs.find(t).filter(e => e === this._element); t !== null && i.length && this._triggerArray.push(e) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default () { return an } static get DefaultType () { return cn } static get NAME () { return 'collapse' }toggle () { this._isShown() ? this.hide() : this.show() }show () { if (this._isTransitioning || this._isShown()) return; let e = []; if (this._config.parent && (e = this._getFirstLevelChildren('.collapse.show, .collapse.collapsing').filter(e => e !== this._element).map(e => ln.getOrCreateInstance(e, { toggle: !1 }))), e.length && e[0]._isTransitioning) return; if (es.trigger(this._element, Qs).defaultPrevented) return; for (const t of e)t.hide(); const t = this._getDimension(); this._element.classList.remove(sn), this._element.classList.add(nn), this._element.style[t] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const i = `scroll${t[0].toUpperCase() + t.slice(1)}`; this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove(nn), this._element.classList.add(sn, tn), this._element.style[t] = '', es.trigger(this._element, Ys) }, this._element, !0), this._element.style[t] = `${this._element[i]}px` }hide () { if (this._isTransitioning || !this._isShown()) return; if (es.trigger(this._element, Js).defaultPrevented) return; const e = this._getDimension(); this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Pi(this._element), this._element.classList.add(nn), this._element.classList.remove(sn, tn); for (const e of this._triggerArray) { const t = Ai(e); t && !this._isShown(t) && this._addAriaAndCollapsedClass([e], !1) } this._isTransitioning = !0; this._element.style[e] = '', this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove(nn), this._element.classList.add(sn), es.trigger(this._element, Zs) }, this._element, !0) }_isShown (e = this._element) { return e.classList.contains(tn) }_configAfterMerge (e) { return e.toggle = Boolean(e.toggle), e.parent = ki(e.parent), e }_getDimension () { return this._element.classList.contains('collapse-horizontal') ? 'width' : 'height' }_initializeChildren () { if (!this._config.parent) return; const e = this._getFirstLevelChildren(on); for (const t of e) { const e = Ai(t); e && this._addAriaAndCollapsedClass([t], this._isShown(e)) } }_getFirstLevelChildren (e) { const t = gs.find(rn, this._config.parent); return gs.find(e, this._config.parent).filter(e => !t.includes(e)) }_addAriaAndCollapsedClass (e, t) { if (e.length) for (const i of e)i.classList.toggle('collapsed', !t), i.setAttribute('aria-expanded', t) } static jQueryInterface (e) { const t = {}; return typeof e === 'string' && /show|hide/.test(e) && (t.toggle = !1), this.each(function () { const i = ln.getOrCreateInstance(this, t); if (typeof e === 'string') { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e]() } }) }}es.on(document, en, on, function (e) { (e.target.tagName === 'A' || e.delegateTarget && e.delegateTarget.tagName === 'A') && e.preventDefault(); const t = Ei(this); const i = gs.find(t); for (const e of i)ln.getOrCreateInstance(e, { toggle: !1 }).toggle() }), Ni(ln); const hn = 'dropdown'; const dn = '.bs.dropdown'; const un = '.data-api'; const mn = 'ArrowUp'; const pn = 'ArrowDown'; const fn = `hide${dn}`; const gn = `hidden${dn}`; const bn = `show${dn}`; const vn = `shown${dn}`; const yn = `click${dn}${un}`; const wn = `keydown${dn}${un}`; const _n = `keyup${dn}${un}`; const En = 'show'; const An = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)'; const Sn = `${An}.${En}`; const Cn = '.dropdown-menu'; const kn = Ri() ? 'top-end' : 'top-start'; const Tn = Ri() ? 'top-start' : 'top-end'; const Ln = Ri() ? 'bottom-end' : 'bottom-start'; const On = Ri() ? 'bottom-start' : 'bottom-end'; const Mn = Ri() ? 'left-start' : 'right-start'; const Pn = Ri() ? 'right-start' : 'left-start'; const xn = { autoClose: !0, boundary: 'clippingParents', display: 'dynamic', offset: [0, 2], popperConfig: null, reference: 'toggle' }; const In = { autoClose: '(boolean|string)', boundary: '(string|element)', display: 'string', offset: '(array|string|function)', popperConfig: '(null|object|function)', reference: '(string|element|object)' }; class Rn extends cs {constructor (e, t) { super(e, t), this._popper = null, this._parent = this._element.parentNode, this._menu = gs.next(this._element, Cn)[0] || gs.prev(this._element, Cn)[0] || gs.findOne(Cn, this._parent), this._inNavbar = this._detectNavbar() } static get Default () { return xn } static get DefaultType () { return In } static get NAME () { return hn }toggle () { return this._isShown() ? this.hide() : this.show() }show () { if (Li(this._element) || this._isShown()) return; const e = { relatedTarget: this._element }; if (!es.trigger(this._element, bn, e).defaultPrevented) { if (this._createPopper(), 'ontouchstart' in document.documentElement && !this._parent.closest('.navbar-nav')) for (const e of [].concat(...document.body.children))es.on(e, 'mouseover', Mi); this._element.focus(), this._element.setAttribute('aria-expanded', !0), this._menu.classList.add(En), this._element.classList.add(En), es.trigger(this._element, vn, e) } }hide () { if (Li(this._element) || !this._isShown()) return; const e = { relatedTarget: this._element }; this._completeHide(e) }dispose () { this._popper && this._popper.destroy(), super.dispose() }update () { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() }_completeHide (e) { if (!es.trigger(this._element, fn, e).defaultPrevented) { if ('ontouchstart' in document.documentElement) for (const e of [].concat(...document.body.children))es.off(e, 'mouseover', Mi); this._popper && this._popper.destroy(), this._menu.classList.remove(En), this._element.classList.remove(En), this._element.setAttribute('aria-expanded', 'false'), os.removeDataAttribute(this._menu, 'popper'), es.trigger(this._element, gn, e) } }_getConfig (e) { if (typeof (e = super._getConfig(e)).reference === 'object' && !Ci(e.reference) && typeof e.reference.getBoundingClientRect !== 'function') throw new TypeError(`${hn.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return e }_createPopper () { if (void 0 === yi) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; this._config.reference === 'parent' ? e = this._parent : Ci(this._config.reference) ? e = ki(this._config.reference) : typeof this._config.reference === 'object' && (e = this._config.reference); const t = this._getPopperConfig(); this._popper = vi(e, this._menu, t) }_isShown () { return this._menu.classList.contains(En) }_getPlacement () { const e = this._parent; if (e.classList.contains('dropend')) return Mn; if (e.classList.contains('dropstart')) return Pn; if (e.classList.contains('dropup-center')) return 'top'; if (e.classList.contains('dropdown-center')) return 'bottom'; const t = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end'; return e.classList.contains('dropup') ? t ? Tn : kn : t ? On : Ln }_detectNavbar () { return this._element.closest('.navbar') !== null }_getOffset () { const { offset: e } = this._config; return typeof e === 'string' ? e.split(',').map(e => Number.parseInt(e, 10)) : typeof e === 'function' ? t => e(t, this._element) : e }_getPopperConfig () { const e = { placement: this._getPlacement(), modifiers: [{ name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'offset', options: { offset: this._getOffset() } }] }; return (this._inNavbar || this._config.display === 'static') && (os.setDataAttribute(this._menu, 'popper', 'static'), e.modifiers = [{ name: 'applyStyles', enabled: !1 }]), { ...e, ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(e) : this._config.popperConfig } }_selectMenuItem ({ key: e, target: t }) { const i = gs.find('.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)', this._menu).filter(e => Ti(e)); i.length && Bi(i, t, e === pn, !i.includes(t)).focus() } static jQueryInterface (e) { return this.each(function () { const t = Rn.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } }) } static clearMenus (e) { if (e.button === 2 || e.type === 'keyup' && e.key !== 'Tab') return; const t = gs.find(Sn); for (const i of t) { const t = Rn.getInstance(i); if (!t || !1 === t._config.autoClose) continue; const s = e.composedPath(); const n = s.includes(t._menu); if (s.includes(t._element) || t._config.autoClose === 'inside' && !n || t._config.autoClose === 'outside' && n) continue; if (t._menu.contains(e.target) && (e.type === 'keyup' && e.key === 'Tab' || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; const r = { relatedTarget: t._element }; e.type === 'click' && (r.clickEvent = e), t._completeHide(r) } } static dataApiKeydownHandler (e) { const t = /input|textarea/i.test(e.target.tagName); const i = e.key === 'Escape'; const s = [mn, pn].includes(e.key); if (!s && !i) return; if (t && !i) return; e.preventDefault(); const n = this.matches(An) ? this : gs.prev(this, An)[0] || gs.next(this, An)[0] || gs.findOne(An, e.delegateTarget.parentNode); const r = Rn.getOrCreateInstance(n); if (s) return e.stopPropagation(), r.show(), void r._selectMenuItem(e); r._isShown() && (e.stopPropagation(), r.hide(), n.focus()) }}es.on(document, wn, An, Rn.dataApiKeydownHandler), es.on(document, wn, Cn, Rn.dataApiKeydownHandler), es.on(document, yn, Rn.clearMenus), es.on(document, _n, Rn.clearMenus), es.on(document, yn, An, function (e) { e.preventDefault(), Rn.getOrCreateInstance(this).toggle() }), Ni(Rn); const Nn = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'; const Fn = '.sticky-top'; const Dn = 'padding-right'; const Bn = 'margin-right'; class $n {constructor () { this._element = document.body }getWidth () { const e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e) }hide () { const e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, Dn, t => t + e), this._setElementAttributes(Nn, Dn, t => t + e), this._setElementAttributes(Fn, Bn, t => t - e) }reset () { this._resetElementAttributes(this._element, 'overflow'), this._resetElementAttributes(this._element, Dn), this._resetElementAttributes(Nn, Dn), this._resetElementAttributes(Fn, Bn) }isOverflowing () { return this.getWidth() > 0 }_disableOverFlow () { this._saveInitialAttribute(this._element, 'overflow'), this._element.style.overflow = 'hidden' }_setElementAttributes (e, t, i) { const s = this.getWidth(); this._applyManipulationCallback(e, e => { if (e !== this._element && window.innerWidth > e.clientWidth + s) return; this._saveInitialAttribute(e, t); const n = window.getComputedStyle(e).getPropertyValue(t); e.style.setProperty(t, `${i(Number.parseFloat(n))}px`) }) }_saveInitialAttribute (e, t) { const i = e.style.getPropertyValue(t); i && os.setDataAttribute(e, t, i) }_resetElementAttributes (e, t) { this._applyManipulationCallback(e, e => { const i = os.getDataAttribute(e, t); i !== null ? (os.removeDataAttribute(e, t), e.style.setProperty(t, i)) : e.style.removeProperty(t) }) }_applyManipulationCallback (e, t) { if (Ci(e))t(e); else for (const i of gs.find(e, this._element))t(i) }} const jn = 'backdrop'; const Hn = 'show'; const qn = `mousedown.bs.${jn}`; const Vn = { className: 'modal-backdrop', clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: 'body' }; const Wn = { className: 'string', clickCallback: '(function|null)', isAnimated: 'boolean', isVisible: 'boolean', rootElement: '(element|string)' }; class Kn extends as {constructor (e) { super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null } static get Default () { return Vn } static get DefaultType () { return Wn } static get NAME () { return jn }show (e) { if (!this._config.isVisible) return void Fi(e); this._append(); const t = this._getElement(); this._config.isAnimated && Pi(t), t.classList.add(Hn), this._emulateAnimation(() => { Fi(e) }) }hide (e) { this._config.isVisible ? (this._getElement().classList.remove(Hn), this._emulateAnimation(() => { this.dispose(), Fi(e) })) : Fi(e) }dispose () { this._isAppended && (es.off(this._element, qn), this._element.remove(), this._isAppended = !1) }_getElement () { if (!this._element) { const e = document.createElement('div'); e.className = this._config.className, this._config.isAnimated && e.classList.add('fade'), this._element = e } return this._element }_configAfterMerge (e) { return e.rootElement = ki(e.rootElement), e }_append () { if (this._isAppended) return; const e = this._getElement(); this._config.rootElement.append(e), es.on(e, qn, () => { Fi(this._config.clickCallback) }), this._isAppended = !0 }_emulateAnimation (e) { Di(e, this._getElement(), this._config.isAnimated) }} const zn = '.bs.focustrap'; const Un = `focusin${zn}`; const Gn = `keydown.tab${zn}`; const Xn = 'backward'; const Qn = { autofocus: !0, trapElement: null }; const Yn = { autofocus: 'boolean', trapElement: 'element' }; class Jn extends as {constructor (e) { super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null } static get Default () { return Qn } static get DefaultType () { return Yn } static get NAME () { return 'focustrap' }activate () { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), es.off(document, zn), es.on(document, Un, e => this._handleFocusin(e)), es.on(document, Gn, e => this._handleKeydown(e)), this._isActive = !0) }deactivate () { this._isActive && (this._isActive = !1, es.off(document, zn)) }_handleFocusin (e) { const { trapElement: t } = this._config; if (e.target === document || e.target === t || t.contains(e.target)) return; const i = gs.focusableChildren(t); i.length === 0 ? t.focus() : this._lastTabNavDirection === Xn ? i[i.length - 1].focus() : i[0].focus() }_handleKeydown (e) { e.key === 'Tab' && (this._lastTabNavDirection = e.shiftKey ? Xn : 'forward') }} const Zn = '.bs.modal'; const er = `hide${Zn}`; const tr = `hidePrevented${Zn}`; const ir = `hidden${Zn}`; const sr = `show${Zn}`; const nr = `shown${Zn}`; const rr = `resize${Zn}`; const or = `click.dismiss${Zn}`; const ar = `mousedown.dismiss${Zn}`; const cr = `keydown.dismiss${Zn}`; const lr = `click${Zn}.data-api`; const hr = 'modal-open'; const dr = 'show'; const ur = 'modal-static'; const mr = { backdrop: !0, focus: !0, keyboard: !0 }; const pr = { backdrop: '(boolean|string)', focus: 'boolean', keyboard: 'boolean' }; class fr extends cs {constructor (e, t) { super(e, t), this._dialog = gs.findOne('.modal-dialog', this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new $n(), this._addEventListeners() } static get Default () { return mr } static get DefaultType () { return pr } static get NAME () { return 'modal' }toggle (e) { return this._isShown ? this.hide() : this.show(e) }show (e) { if (this._isShown || this._isTransitioning) return; es.trigger(this._element, sr, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(hr), this._adjustDialog(), this._backdrop.show(() => this._showElement(e))) }hide () { if (!this._isShown || this._isTransitioning) return; es.trigger(this._element, er).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(dr), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())) }dispose () { for (const e of [window, this._dialog])es.off(e, Zn); this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() }handleUpdate () { this._adjustDialog() }_initializeBackDrop () { return new Kn({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) }_initializeFocusTrap () { return new Jn({ trapElement: this._element }) }_showElement (e) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.scrollTop = 0; const t = gs.findOne('.modal-body', this._dialog); t && (t.scrollTop = 0), Pi(this._element), this._element.classList.add(dr); this._queueCallback(() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, es.trigger(this._element, nr, { relatedTarget: e }) }, this._dialog, this._isAnimated()) }_addEventListeners () { es.on(this._element, cr, e => { if (e.key === 'Escape') return this._config.keyboard ? (e.preventDefault(), void this.hide()) : void this._triggerBackdropTransition() }), es.on(window, rr, () => { this._isShown && !this._isTransitioning && this._adjustDialog() }), es.on(this._element, ar, e => { es.one(this._element, or, t => { this._element === e.target && this._element === t.target && (this._config.backdrop !== 'static' ? this._config.backdrop && this.hide() : this._triggerBackdropTransition()) }) }) }_hideModal () { this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove(hr), this._resetAdjustments(), this._scrollBar.reset(), es.trigger(this._element, ir) }) }_isAnimated () { return this._element.classList.contains('fade') }_triggerBackdropTransition () { if (es.trigger(this._element, tr).defaultPrevented) return; const e = this._element.scrollHeight > document.documentElement.clientHeight; const t = this._element.style.overflowY; t === 'hidden' || this._element.classList.contains(ur) || (e || (this._element.style.overflowY = 'hidden'), this._element.classList.add(ur), this._queueCallback(() => { this._element.classList.remove(ur), this._queueCallback(() => { this._element.style.overflowY = t }, this._dialog) }, this._dialog), this._element.focus()) }_adjustDialog () { const e = this._element.scrollHeight > document.documentElement.clientHeight; const t = this._scrollBar.getWidth(); const i = t > 0; if (i && !e) { const e = Ri() ? 'paddingLeft' : 'paddingRight'; this._element.style[e] = `${t}px` } if (!i && e) { const e = Ri() ? 'paddingRight' : 'paddingLeft'; this._element.style[e] = `${t}px` } }_resetAdjustments () { this._element.style.paddingLeft = '', this._element.style.paddingRight = '' } static jQueryInterface (e, t) { return this.each(function () { const i = fr.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e](t) } }) }}es.on(document, lr, '[data-bs-toggle="modal"]', function (e) { const t = Ai(this); ['A', 'AREA'].includes(this.tagName) && e.preventDefault(), es.one(t, sr, e => { e.defaultPrevented || es.one(t, ir, () => { Ti(this) && this.focus() }) }); const i = gs.findOne('.modal.show'); i && fr.getInstance(i).hide(); fr.getOrCreateInstance(t).toggle(this) }), ls(fr), Ni(fr); const gr = '.bs.offcanvas'; const br = '.data-api'; const vr = `load${gr}${br}`; const yr = 'show'; const wr = 'showing'; const _r = 'hiding'; const Er = '.offcanvas.show'; const Ar = `show${gr}`; const Sr = `shown${gr}`; const Cr = `hide${gr}`; const kr = `hidePrevented${gr}`; const Tr = `hidden${gr}`; const Lr = `resize${gr}`; const Or = `click${gr}${br}`; const Mr = `keydown.dismiss${gr}`; const Pr = { backdrop: !0, keyboard: !0, scroll: !1 }; const xr = { backdrop: '(boolean|string)', keyboard: 'boolean', scroll: 'boolean' }; class Ir extends cs {constructor (e, t) { super(e, t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default () { return Pr } static get DefaultType () { return xr } static get NAME () { return 'offcanvas' }toggle (e) { return this._isShown ? this.hide() : this.show(e) }show (e) { if (this._isShown) return; if (es.trigger(this._element, Ar, { relatedTarget: e }).defaultPrevented) return; this._isShown = !0, this._backdrop.show(), this._config.scroll || (new $n()).hide(), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.classList.add(wr); this._queueCallback(() => { this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(yr), this._element.classList.remove(wr), es.trigger(this._element, Sr, { relatedTarget: e }) }, this._element, !0) }hide () { if (!this._isShown) return; if (es.trigger(this._element, Cr).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(_r), this._backdrop.hide(); this._queueCallback(() => { this._element.classList.remove(yr, _r), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._config.scroll || (new $n()).reset(), es.trigger(this._element, Tr) }, this._element, !0) }dispose () { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() }_initializeBackDrop () { const e = Boolean(this._config.backdrop); return new Kn({ className: 'offcanvas-backdrop', isVisible: e, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: e ? () => { this._config.backdrop !== 'static' ? this.hide() : es.trigger(this._element, kr) } : null }) }_initializeFocusTrap () { return new Jn({ trapElement: this._element }) }_addEventListeners () { es.on(this._element, Mr, e => { e.key === 'Escape' && (this._config.keyboard ? this.hide() : es.trigger(this._element, kr)) }) } static jQueryInterface (e) { return this.each(function () { const t = Ir.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}es.on(document, Or, '[data-bs-toggle="offcanvas"]', function (e) { const t = Ai(this); if (['A', 'AREA'].includes(this.tagName) && e.preventDefault(), Li(this)) return; es.one(t, Tr, () => { Ti(this) && this.focus() }); const i = gs.findOne(Er); i && i !== t && Ir.getInstance(i).hide(); Ir.getOrCreateInstance(t).toggle(this) }), es.on(window, vr, () => { for (const e of gs.find(Er))Ir.getOrCreateInstance(e).show() }), es.on(window, Lr, () => { for (const e of gs.find('[aria-modal][class*=show][class*=offcanvas-]'))getComputedStyle(e).position !== 'fixed' && Ir.getOrCreateInstance(e).hide() }), ls(Ir), Ni(Ir); const Rr = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']); const Nr = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i; const Fr = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; const Dr = (e, t) => { const i = e.nodeName.toLowerCase(); return t.includes(i) ? !Rr.has(i) || Boolean(Nr.test(e.nodeValue) || Fr.test(e.nodeValue)) : t.filter(e => e instanceof RegExp).some(e => e.test(i)) }; const Br = { '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i], a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'srcset', 'alt', 'title', 'width', 'height'], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; const $r = { allowList: Br, content: {}, extraClass: '', html: !1, sanitize: !0, sanitizeFn: null, template: '<div></div>' }; const jr = { allowList: 'object', content: 'object', extraClass: '(string|function)', html: 'boolean', sanitize: 'boolean', sanitizeFn: '(null|function)', template: 'string' }; const Hr = { entry: '(string|element|function|null)', selector: '(string|element)' }; class qr extends as {constructor (e) { super(), this._config = this._getConfig(e) } static get Default () { return $r } static get DefaultType () { return jr } static get NAME () { return 'TemplateFactory' }getContent () { return Object.values(this._config.content).map(e => this._resolvePossibleFunction(e)).filter(Boolean) }hasContent () { return this.getContent().length > 0 }changeContent (e) { return this._checkContent(e), this._config.content = { ...this._config.content, ...e }, this }toHtml () { const e = document.createElement('div'); e.innerHTML = this._maybeSanitize(this._config.template); for (const [t, i] of Object.entries(this._config.content)) this._setContent(e, i, t); const t = e.children[0]; const i = this._resolvePossibleFunction(this._config.extraClass); return i && t.classList.add(...i.split(' ')), t }_typeCheckConfig (e) { super._typeCheckConfig(e), this._checkContent(e.content) }_checkContent (e) { for (const [t, i] of Object.entries(e)) super._typeCheckConfig({ selector: t, entry: i }, Hr) }_setContent (e, t, i) { const s = gs.findOne(i, e); s && ((t = this._resolvePossibleFunction(t)) ? Ci(t) ? this._putElementInTemplate(ki(t), s) : this._config.html ? s.innerHTML = this._maybeSanitize(t) : s.textContent = t : s.remove()) }_maybeSanitize (e) { return this._config.sanitize ? (function (e, t, i) { if (!e.length) return e; if (i && typeof i === 'function') return i(e); const s = (new window.DOMParser()).parseFromString(e, 'text/html'); const n = [].concat(...s.body.querySelectorAll('*')); for (const e of n) { const i = e.nodeName.toLowerCase(); if (!Object.keys(t).includes(i)) { e.remove(); continue } const s = [].concat(...e.attributes); const n = [].concat(t['*'] || [], t[i] || []); for (const t of s)Dr(t, n) || e.removeAttribute(t.nodeName) } return s.body.innerHTML }(e, this._config.allowList, this._config.sanitizeFn)) : e }_resolvePossibleFunction (e) { return typeof e === 'function' ? e(this) : e }_putElementInTemplate (e, t) { if (this._config.html) return t.innerHTML = '', void t.append(e); t.textContent = e.textContent }} const Vr = new Set(['sanitize', 'allowList', 'sanitizeFn']); const Wr = 'fade'; const Kr = 'show'; const zr = '.modal'; const Ur = 'hide.bs.modal'; const Gr = 'hover'; const Xr = 'focus'; const Qr = { AUTO: 'auto', TOP: 'top', RIGHT: Ri() ? 'left' : 'right', BOTTOM: 'bottom', LEFT: Ri() ? 'right' : 'left' }; const Yr = { allowList: Br, animation: !0, boundary: 'clippingParents', container: !1, customClass: '', delay: 0, fallbackPlacements: ['top', 'right', 'bottom', 'left'], html: !1, offset: [0, 0], placement: 'top', popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: '', trigger: 'hover focus' }; const Jr = { allowList: 'object', animation: 'boolean', boundary: '(string|element)', container: '(string|element|boolean)', customClass: '(string|function)', delay: '(number|object)', fallbackPlacements: 'array', html: 'boolean', offset: '(array|string|function)', placement: '(string|function)', popperConfig: '(null|object|function)', sanitize: 'boolean', sanitizeFn: '(null|function)', selector: '(string|boolean)', template: 'string', title: '(string|element|function)', trigger: 'string' }; class Zr extends cs {constructor (e, t) { if (void 0 === yi) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(e, t), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle() } static get Default () { return Yr } static get DefaultType () { return Jr } static get NAME () { return 'tooltip' }enable () { this._isEnabled = !0 }disable () { this._isEnabled = !1 }toggleEnabled () { this._isEnabled = !this._isEnabled }toggle () { this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter()) }dispose () { clearTimeout(this._timeout), es.off(this._element.closest(zr), Ur, this._hideModalHandler), this._element.getAttribute('data-bs-original-title') && this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title')), this._disposePopper(), super.dispose() }show () { if (this._element.style.display === 'none') throw new Error('Please use show on visible elements'); if (!this._isWithContent() || !this._isEnabled) return; const e = es.trigger(this._element, this.constructor.eventName('show')); const t = (Oi(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (e.defaultPrevented || !t) return; this._disposePopper(); const i = this._getTipElement(); this._element.setAttribute('aria-describedby', i.getAttribute('id')); const { container: s } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(i), es.trigger(this._element, this.constructor.eventName('inserted'))), this._popper = this._createPopper(i), i.classList.add(Kr), 'ontouchstart' in document.documentElement) for (const e of [].concat(...document.body.children))es.on(e, 'mouseover', Mi); this._queueCallback(() => { es.trigger(this._element, this.constructor.eventName('shown')), !1 === this._isHovered && this._leave(), this._isHovered = !1 }, this.tip, this._isAnimated()) }hide () { if (!this._isShown()) return; if (es.trigger(this._element, this.constructor.eventName('hide')).defaultPrevented) return; if (this._getTipElement().classList.remove(Kr), 'ontouchstart' in document.documentElement) for (const e of [].concat(...document.body.children))es.off(e, 'mouseover', Mi); this._activeTrigger.click = !1, this._activeTrigger[Xr] = !1, this._activeTrigger[Gr] = !1, this._isHovered = null; this._queueCallback(() => { this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute('aria-describedby'), es.trigger(this._element, this.constructor.eventName('hidden'))) }, this.tip, this._isAnimated()) }update () { this._popper && this._popper.update() }_isWithContent () { return Boolean(this._getTitle()) }_getTipElement () { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip }_createTipElement (e) { const t = this._getTemplateFactory(e).toHtml(); if (!t) return null; t.classList.remove(Wr, Kr), t.classList.add(`bs-${this.constructor.NAME}-auto`); const i = (e => { do { e += Math.floor(1e6 * Math.random()) } while (document.getElementById(e)); return e })(this.constructor.NAME).toString(); return t.setAttribute('id', i), this._isAnimated() && t.classList.add(Wr), t }setContent (e) { this._newContent = e, this._isShown() && (this._disposePopper(), this.show()) }_getTemplateFactory (e) { return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new qr({ ...this._config, content: e, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory }_getContentForTemplate () { return { '.tooltip-inner': this._getTitle() } }_getTitle () { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title') }_initializeOnDelegatedTarget (e) { return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig()) }_isAnimated () { return this._config.animation || this.tip && this.tip.classList.contains(Wr) }_isShown () { return this.tip && this.tip.classList.contains(Kr) }_createPopper (e) { const t = typeof this._config.placement === 'function' ? this._config.placement.call(this, e, this._element) : this._config.placement; const i = Qr[t.toUpperCase()]; return vi(this._element, e, this._getPopperConfig(i)) }_getOffset () { const { offset: e } = this._config; return typeof e === 'string' ? e.split(',').map(e => Number.parseInt(e, 10)) : typeof e === 'function' ? t => e(t, this._element) : e }_resolvePossibleFunction (e) { return typeof e === 'function' ? e.call(this._element) : e }_getPopperConfig (e) { const t = { placement: e, modifiers: [{ name: 'flip', options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: 'offset', options: { offset: this._getOffset() } }, { name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'arrow', options: { element: `.${this.constructor.NAME}-arrow` } }, { name: 'preSetPlacement', enabled: !0, phase: 'beforeMain', fn: e => { this._getTipElement().setAttribute('data-popper-placement', e.state.placement) } }] }; return { ...t, ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(t) : this._config.popperConfig } }_setListeners () { const e = this._config.trigger.split(' '); for (const t of e) if (t === 'click')es.on(this._element, this.constructor.eventName('click'), this._config.selector, e => { this._initializeOnDelegatedTarget(e).toggle() }); else if (t !== 'manual') { const e = t === Gr ? this.constructor.eventName('mouseenter') : this.constructor.eventName('focusin'); const i = t === Gr ? this.constructor.eventName('mouseleave') : this.constructor.eventName('focusout'); es.on(this._element, e, this._config.selector, e => { const t = this._initializeOnDelegatedTarget(e); t._activeTrigger[e.type === 'focusin' ? Xr : Gr] = !0, t._enter() }), es.on(this._element, i, this._config.selector, e => { const t = this._initializeOnDelegatedTarget(e); t._activeTrigger[e.type === 'focusout' ? Xr : Gr] = t._element.contains(e.relatedTarget), t._leave() }) } this._hideModalHandler = () => { this._element && this.hide() }, es.on(this._element.closest(zr), Ur, this._hideModalHandler) }_fixTitle () { const e = this._element.getAttribute('title'); e && (this._element.getAttribute('aria-label') || this._element.textContent.trim() || this._element.setAttribute('aria-label', e), this._element.setAttribute('data-bs-original-title', e), this._element.removeAttribute('title')) }_enter () { this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(() => { this._isHovered && this.show() }, this._config.delay.show)) }_leave () { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => { this._isHovered || this.hide() }, this._config.delay.hide)) }_setTimeout (e, t) { clearTimeout(this._timeout), this._timeout = setTimeout(e, t) }_isWithActiveTrigger () { return Object.values(this._activeTrigger).includes(!0) }_getConfig (e) { const t = os.getDataAttributes(this._element); for (const e of Object.keys(t))Vr.has(e) && delete t[e]; return e = { ...t, ...typeof e === 'object' && e ? e : {} }, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e }_configAfterMerge (e) { return e.container = !1 === e.container ? document.body : ki(e.container), typeof e.delay === 'number' && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title === 'number' && (e.title = e.title.toString()), typeof e.content === 'number' && (e.content = e.content.toString()), e }_getDelegateConfig () { const e = {}; for (const t in this._config) this.constructor.Default[t] !== this._config[t] && (e[t] = this._config[t]); return e.selector = !1, e.trigger = 'manual', e }_disposePopper () { this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null) } static jQueryInterface (e) { return this.each(function () { const t = Zr.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } }) }}Ni(Zr); const eo = { ...Zr.Default, content: '', offset: [0, 8], placement: 'right', template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: 'click' }; const to = { ...Zr.DefaultType, content: '(null|string|element|function)' }; class io extends Zr {static get Default () { return eo } static get DefaultType () { return to } static get NAME () { return 'popover' }_isWithContent () { return this._getTitle() || this._getContent() }_getContentForTemplate () { return { '.popover-header': this._getTitle(), '.popover-body': this._getContent() } }_getContent () { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface (e) { return this.each(function () { const t = io.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } }) }}Ni(io); const so = '.bs.scrollspy'; const no = `activate${so}`; const ro = `click${so}`; const oo = `load${so}.data-api`; const ao = 'active'; const co = '[href]'; const lo = '.nav-link'; const ho = `${lo}, .nav-item > ${lo}, .list-group-item`; const uo = { offset: null, rootMargin: '0px 0px -25%', smoothScroll: !1, target: null, threshold: [0.1, 0.5, 1] }; const mo = { offset: '(number|null)', rootMargin: 'string', smoothScroll: 'boolean', target: 'element', threshold: 'array' }; class po extends cs {constructor (e, t) { super(e, t), this._targetLinks = new Map(), this._observableSections = new Map(), this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default () { return uo } static get DefaultType () { return mo } static get NAME () { return 'scrollspy' }refresh () { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const e of this._observableSections.values()) this._observer.observe(e) }dispose () { this._observer.disconnect(), super.dispose() }_configAfterMerge (e) { return e.target = ki(e.target) || document.body, e.rootMargin = e.offset ? `${e.offset}px 0px -30%` : e.rootMargin, typeof e.threshold === 'string' && (e.threshold = e.threshold.split(',').map(e => Number.parseFloat(e))), e }_maybeEnableSmoothScroll () { this._config.smoothScroll && (es.off(this._config.target, ro), es.on(this._config.target, ro, co, e => { const t = this._observableSections.get(e.target.hash); if (t) { e.preventDefault(); const i = this._rootElement || window; const s = t.offsetTop - this._element.offsetTop; if (i.scrollTo) return void i.scrollTo({ top: s, behavior: 'smooth' }); i.scrollTop = s } })) }_getNewObserver () { const e = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver(e => this._observerCallback(e), e) }_observerCallback (e) { const t = e => this._targetLinks.get(`#${e.target.id}`); const i = e => { this._previousScrollData.visibleEntryTop = e.target.offsetTop, this._process(t(e)) }; const s = (this._rootElement || document.documentElement).scrollTop; const n = s >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = s; for (const r of e) { if (!r.isIntersecting) { this._activeTarget = null, this._clearActiveClass(t(r)); continue } const e = r.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (n && e) { if (i(r), !s) return } else n || e || i(r) } }_initializeTargetsAndObservables () { this._targetLinks = new Map(), this._observableSections = new Map(); const e = gs.find(co, this._config.target); for (const t of e) { if (!t.hash || Li(t)) continue; const e = gs.findOne(t.hash, this._element); Ti(e) && (this._targetLinks.set(t.hash, t), this._observableSections.set(t.hash, e)) } }_process (e) { this._activeTarget !== e && (this._clearActiveClass(this._config.target), this._activeTarget = e, e.classList.add(ao), this._activateParents(e), es.trigger(this._element, no, { relatedTarget: e })) }_activateParents (e) { if (e.classList.contains('dropdown-item'))gs.findOne('.dropdown-toggle', e.closest('.dropdown')).classList.add(ao); else for (const t of gs.parents(e, '.nav, .list-group')) for (const e of gs.prev(t, ho))e.classList.add(ao) }_clearActiveClass (e) { e.classList.remove(ao); const t = gs.find(`${co}.${ao}`, e); for (const e of t)e.classList.remove(ao) } static jQueryInterface (e) { return this.each(function () { const t = po.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}es.on(window, oo, () => { for (const e of gs.find('[data-bs-spy="scroll"]'))po.getOrCreateInstance(e) }), Ni(po); const fo = '.bs.tab'; const go = `hide${fo}`; const bo = `hidden${fo}`; const vo = `show${fo}`; const yo = `shown${fo}`; const wo = `click${fo}`; const _o = `keydown${fo}`; const Eo = `load${fo}`; const Ao = 'ArrowLeft'; const So = 'ArrowRight'; const Co = 'ArrowUp'; const ko = 'ArrowDown'; const To = 'active'; const Lo = 'fade'; const Oo = 'show'; const Mo = ':not(.dropdown-toggle)'; const Po = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; const xo = `${`.nav-link${Mo}, .list-group-item${Mo}, [role="tab"]${Mo}`}, ${Po}`; const Io = `.${To}[data-bs-toggle="tab"], .${To}[data-bs-toggle="pill"], .${To}[data-bs-toggle="list"]`; class Ro extends cs {constructor (e) { super(e), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), es.on(this._element, _o, e => this._keydown(e))) } static get NAME () { return 'tab' }show () { const e = this._element; if (this._elemIsActive(e)) return; const t = this._getActiveElem(); const i = t ? es.trigger(t, go, { relatedTarget: e }) : null; es.trigger(e, vo, { relatedTarget: t }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(t, e), this._activate(e, t)) }_activate (e, t) { if (!e) return; e.classList.add(To), this._activate(Ai(e)); this._queueCallback(() => { e.getAttribute('role') === 'tab' ? (e.removeAttribute('tabindex'), e.setAttribute('aria-selected', !0), this._toggleDropDown(e, !0), es.trigger(e, yo, { relatedTarget: t })) : e.classList.add(Oo) }, e, e.classList.contains(Lo)) }_deactivate (e, t) { if (!e) return; e.classList.remove(To), e.blur(), this._deactivate(Ai(e)); this._queueCallback(() => { e.getAttribute('role') === 'tab' ? (e.setAttribute('aria-selected', !1), e.setAttribute('tabindex', '-1'), this._toggleDropDown(e, !1), es.trigger(e, bo, { relatedTarget: t })) : e.classList.remove(Oo) }, e, e.classList.contains(Lo)) }_keydown (e) { if (![Ao, So, Co, ko].includes(e.key)) return; e.stopPropagation(), e.preventDefault(); const t = [So, ko].includes(e.key); const i = Bi(this._getChildren().filter(e => !Li(e)), e.target, t, !0); i && (i.focus({ preventScroll: !0 }), Ro.getOrCreateInstance(i).show()) }_getChildren () { return gs.find(xo, this._parent) }_getActiveElem () { return this._getChildren().find(e => this._elemIsActive(e)) || null }_setInitialAttributes (e, t) { this._setAttributeIfNotExists(e, 'role', 'tablist'); for (const e of t) this._setInitialAttributesOnChild(e) }_setInitialAttributesOnChild (e) { e = this._getInnerElement(e); const t = this._elemIsActive(e); const i = this._getOuterElement(e); e.setAttribute('aria-selected', t), i !== e && this._setAttributeIfNotExists(i, 'role', 'presentation'), t || e.setAttribute('tabindex', '-1'), this._setAttributeIfNotExists(e, 'role', 'tab'), this._setInitialAttributesOnTargetPanel(e) }_setInitialAttributesOnTargetPanel (e) { const t = Ai(e); t && (this._setAttributeIfNotExists(t, 'role', 'tabpanel'), e.id && this._setAttributeIfNotExists(t, 'aria-labelledby', `#${e.id}`)) }_toggleDropDown (e, t) { const i = this._getOuterElement(e); if (!i.classList.contains('dropdown')) return; const s = (e, s) => { const n = gs.findOne(e, i); n && n.classList.toggle(s, t) }; s('.dropdown-toggle', To), s('.dropdown-menu', Oo), i.setAttribute('aria-expanded', t) }_setAttributeIfNotExists (e, t, i) { e.hasAttribute(t) || e.setAttribute(t, i) }_elemIsActive (e) { return e.classList.contains(To) }_getInnerElement (e) { return e.matches(xo) ? e : gs.findOne(xo, e) }_getOuterElement (e) { return e.closest('.nav-item, .list-group-item') || e } static jQueryInterface (e) { return this.each(function () { const t = Ro.getOrCreateInstance(this); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}es.on(document, wo, Po, function (e) { ['A', 'AREA'].includes(this.tagName) && e.preventDefault(), Li(this) || Ro.getOrCreateInstance(this).show() }), es.on(window, Eo, () => { for (const e of gs.find(Io))Ro.getOrCreateInstance(e) }), Ni(Ro); const No = '.bs.toast'; const Fo = `mouseover${No}`; const Do = `mouseout${No}`; const Bo = `focusin${No}`; const $o = `focusout${No}`; const jo = `hide${No}`; const Ho = `hidden${No}`; const qo = `show${No}`; const Vo = `shown${No}`; const Wo = 'hide'; const Ko = 'show'; const zo = 'showing'; const Uo = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const Go = { animation: !0, autohide: !0, delay: 5e3 }; class Xo extends cs {constructor (e, t) { super(e, t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default () { return Go } static get DefaultType () { return Uo } static get NAME () { return 'toast' }show () { if (es.trigger(this._element, qo).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add('fade'); this._element.classList.remove(Wo), Pi(this._element), this._element.classList.add(Ko, zo), this._queueCallback(() => { this._element.classList.remove(zo), es.trigger(this._element, Vo), this._maybeScheduleHide() }, this._element, this._config.animation) }hide () { if (!this.isShown()) return; if (es.trigger(this._element, jo).defaultPrevented) return; this._element.classList.add(zo), this._queueCallback(() => { this._element.classList.add(Wo), this._element.classList.remove(zo, Ko), es.trigger(this._element, Ho) }, this._element, this._config.animation) }dispose () { this._clearTimeout(), this.isShown() && this._element.classList.remove(Ko), super.dispose() }isShown () { return this._element.classList.contains(Ko) }_maybeScheduleHide () { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide() }, this._config.delay))) }_onInteraction (e, t) { switch (e.type) { case 'mouseover':case 'mouseout':this._hasMouseInteraction = t; break; case 'focusin':case 'focusout':this._hasKeyboardInteraction = t } if (t) return void this._clearTimeout(); const i = e.relatedTarget; this._element === i || this._element.contains(i) || this._maybeScheduleHide() }_setListeners () { es.on(this._element, Fo, e => this._onInteraction(e, !0)), es.on(this._element, Do, e => this._onInteraction(e, !1)), es.on(this._element, Bo, e => this._onInteraction(e, !0)), es.on(this._element, $o, e => this._onInteraction(e, !1)) }_clearTimeout () { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface (e) { return this.each(function () { const t = Xo.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}ls(Xo), Ni(Xo); const Qo = Object.freeze({ __proto__: null, Alert: ms, Button: fs, Carousel: Gs, Collapse: ln, Dropdown: Rn, Modal: fr, Offcanvas: Ir, Popover: io, ScrollSpy: po, Tab: Ro, Toast: Xo, Tooltip: Zr }); window.bootstrap || (window.bootstrap = Qo); const Yo = (function () { function e (e) { const t = this; this.listener = function (e) { (e.matches ? t.matchFns : t.unmatchFns).forEach(function (e) { e() }) }, this.toggler = window.matchMedia(e), this.toggler.addListener(this.listener), this.matchFns = [], this.unmatchFns = [] } return e.prototype.add = function (e, t) { this.matchFns.push(e), this.unmatchFns.push(t), (this.toggler.matches ? e : t)() }, e }()); const Jo = function (e) { return Array.prototype.slice.call(e) }; const Zo = function (e, t) { return Jo((t || document).querySelectorAll(e)) }; const ea = 'mm-spn'; const ta = (function () { function e (e, t, i, s, n) { this.node = e, this.title = t, this.slidingSubmenus = s, this.selectedClass = i, this.node.classList.add(ea), this.node.classList.add(ea + '--' + n), this.node.classList.add(ea + '--' + (this.slidingSubmenus ? 'navbar' : 'vertical')), this._setSelectedl(), this._initAnchors() } return Object.defineProperty(e.prototype, 'prefix', { get: function () { return ea }, enumerable: !1, configurable: !0 }), e.prototype.openPanel = function (e) { const t = e.parentElement; if (this.slidingSubmenus) { let i = e.dataset.mmSpnTitle; t === this.node ? this.node.classList.add(ea + '--main') : (this.node.classList.remove(ea + '--main'), i || Jo(t.children).forEach(function (e) { e.matches('a, span') && (i = e.textContent) })), i || (i = this.title), this.node.dataset.mmSpnTitle = i, Zo('.' + ea + '--open', this.node).forEach(function (e) { e.classList.remove(ea + '--open'), e.classList.remove(ea + '--parent') }), e.classList.add(ea + '--open'), e.classList.remove(ea + '--parent'); for (let s = e.parentElement.closest('ul'); s;)s.classList.add(ea + '--open'), s.classList.add(ea + '--parent'), s = s.parentElement.closest('ul') } else { const n = e.matches('.' + ea + '--open'); Zo('.' + ea + '--open', this.node).forEach(function (e) { e.classList.remove(ea + '--open') }), e.classList[n ? 'remove' : 'add'](ea + '--open'); for (let r = e.parentElement.closest('ul'); r;)r.classList.add(ea + '--open'), r = r.parentElement.closest('ul') } }, e.prototype._setSelectedl = function () { const e = Zo('.' + this.selectedClass, this.node); const t = e[e.length - 1]; let i = null; t && (i = t.closest('ul')), i || (i = this.node.querySelector('ul')), this.openPanel(i) }, e.prototype._initAnchors = function () { const e = this; this.node.addEventListener('click', function (t) { const i = t.target; let s = !1; s = s || (function (e) { return !!e.matches('a') }(i)), s = s || (function (t) { let i; return !!(i = t.closest('span') ? t.parentElement : !!t.closest('li') && t) && (Jo(i.children).forEach(function (t) { t.matches('ul') && e.openPanel(t) }), !0) }(i)), s = s || (function (t) { const i = Zo('.' + ea + '--open', t); const s = i[i.length - 1]; if (s) { const n = s.parentElement.closest('ul'); if (n) return e.openPanel(n), !0 } return !1 }(i)), s && t.stopImmediatePropagation() }) }, e }()); const ia = 'mm-ocd'; const sa = (function () { function e (e, t) { const i = this; void 0 === e && (e = null), this.wrapper = document.createElement('div'), this.wrapper.classList.add('' + ia), this.wrapper.classList.add(ia + '--' + t), this.content = document.createElement('div'), this.content.classList.add(ia + '__content'), this.wrapper.append(this.content), this.backdrop = document.createElement('div'), this.backdrop.classList.add(ia + '__backdrop'), this.wrapper.append(this.backdrop), document.body.append(this.wrapper), e && this.content.append(e); const s = function (e) { i.close(), e.stopImmediatePropagation() }; this.backdrop.addEventListener('touchstart', s, { passive: !0 }), this.backdrop.addEventListener('mousedown', s, { passive: !0 }) } return Object.defineProperty(e.prototype, 'prefix', { get: function () { return ia }, enumerable: !1, configurable: !0 }), e.prototype.open = function () { this.wrapper.classList.add(ia + '--open'), document.body.classList.add(ia + '-opened') }, e.prototype.close = function () { this.wrapper.classList.remove(ia + '--open'), document.body.classList.remove(ia + '-opened') }, e }()); const na = (function () { function e (e, t) { void 0 === t && (t = 'all'), this.menu = e, this.toggler = new Yo(t) } return e.prototype.navigation = function (e) { const t = this; if (!this.navigator) { const i = (e = e || {}).title; const s = void 0 === i ? 'Menu' : i; const n = e.selectedClass; const r = void 0 === n ? 'Selected' : n; const o = e.slidingSubmenus; const a = void 0 === o || o; const c = e.theme; const l = void 0 === c ? 'light' : c; this.navigator = new ta(this.menu, s, r, a, l), this.toggler.add(function () { return t.menu.classList.add(t.navigator.prefix) }, function () { return t.menu.classList.remove(t.navigator.prefix) }) } return this.navigator }, e.prototype.offcanvas = function (e) { const t = this; if (!this.drawer) { const i = (e = e || {}).position; const s = void 0 === i ? 'left' : i; this.drawer = new sa(null, s); const n = document.createComment('original menu location'); this.menu.after(n), this.toggler.add(function () { t.drawer.content.append(t.menu) }, function () { t.drawer.close(), n.after(t.menu) }) } return this.drawer }, e }())
/*!
 * Mmenu Light
 * mmenujs.com/mmenu-light
 *
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * License: CC-BY-4.0
 * http://creativecommons.org/licenses/by/4.0/
 */
window.MmenuLight = na, document.addEventListener('turbo:load', () => { const e = new na(document.querySelector('#mobileNav'), 'all'); e.navigation({ selectedClass: 'Selected', slidingSubmenus: !0, theme: 'light', title: 'Main Menu' }); const t = e.offcanvas({}); document.querySelector('a[href="#mobileNav"]').addEventListener('click', e => { e.preventDefault(), t.open() }) }); const ra = typeof window !== 'undefined'; const oa = ra && !('onscroll' in window) || typeof navigator !== 'undefined' && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent); const aa = ra && 'IntersectionObserver' in window; const ca = ra && 'classList' in document.createElement('p'); const la = ra && window.devicePixelRatio > 1; const ha = { elements_selector: '.lazy', container: oa || ra ? document : null, threshold: 300, thresholds: null, data_src: 'src', data_srcset: 'srcset', data_sizes: 'sizes', data_bg: 'bg', data_bg_hidpi: 'bg-hidpi', data_bg_multi: 'bg-multi', data_bg_multi_hidpi: 'bg-multi-hidpi', data_bg_set: 'bg-set', data_poster: 'poster', class_applied: 'applied', class_loading: 'loading', class_loaded: 'loaded', class_error: 'error', class_entered: 'entered', class_exited: 'exited', unobserve_completed: !0, unobserve_entered: !1, cancel_on_exit: !0, callback_enter: null, callback_exit: null, callback_applied: null, callback_loading: null, callback_loaded: null, callback_error: null, callback_finish: null, callback_cancel: null, use_native: !1, restore_on_error: !1 }; const da = e => Object.assign({}, ha, e); const ua = function (e, t) { let i; const s = 'LazyLoad::Initialized'; const n = new e(t); try { i = new CustomEvent(s, { detail: { instance: n } }) } catch (e) { i = document.createEvent('CustomEvent'), i.initCustomEvent(s, !1, !1, { instance: n }) }window.dispatchEvent(i) }; const ma = 'src'; const pa = 'srcset'; const fa = 'sizes'; const ga = 'poster'; const ba = 'llOriginalAttrs'; const va = 'data'; const ya = 'loading'; const wa = 'loaded'; const _a = 'applied'; const Ea = 'error'; const Aa = 'native'; const Sa = 'data-'; const Ca = 'll-status'; const ka = (e, t) => e.getAttribute(Sa + t); const Ta = e => ka(e, Ca); const La = (e, t) => ((e, t, i) => { const s = Sa + t; i !== null ? e.setAttribute(s, i) : e.removeAttribute(s) })(e, Ca, t); const Oa = e => La(e, null); const Ma = e => Ta(e) === null; const Pa = e => Ta(e) === Aa; const xa = [ya, wa, _a, Ea]; const Ia = (e, t, i, s) => { e && (void 0 === s ? void 0 === i ? e(t) : e(t, i) : e(t, i, s)) }; const Ra = (e, t) => { ca ? e.classList.add(t) : e.className += (e.className ? ' ' : '') + t }; const Na = (e, t) => { ca ? e.classList.remove(t) : e.className = e.className.replace(new RegExp('(^|\\s+)' + t + '(\\s+|$)'), ' ').replace(/^\s+/, '').replace(/\s+$/, '') }; const Fa = e => e.llTempImage; const Da = (e, t) => { if (!t) return; const i = t._observer; i && i.unobserve(e) }; const Ba = (e, t) => { e && (e.loadingCount += t) }; const $a = (e, t) => { e && (e.toLoadCount = t) }; const ja = e => { const t = []; for (let i, s = 0; i = e.children[s]; s += 1)i.tagName === 'SOURCE' && t.push(i); return t }; const Ha = (e, t) => { const i = e.parentNode; if (!i || i.tagName !== 'PICTURE') return; ja(i).forEach(t) }; const qa = (e, t) => { ja(e).forEach(t) }; const Va = [ma]; const Wa = [ma, ga]; const Ka = [ma, pa, fa]; const za = [va]; const Ua = e => !!e[ba]; const Ga = e => e[ba]; const Xa = e => delete e[ba]; const Qa = (e, t) => { if (Ua(e)) return; const i = {}; t.forEach(t => { i[t] = e.getAttribute(t) }), e[ba] = i }; const Ya = (e, t) => { if (!Ua(e)) return; const i = Ga(e); t.forEach(t => { ((e, t, i) => { i ? e.setAttribute(t, i) : e.removeAttribute(t) })(e, t, i[t]) }) }; const Ja = (e, t, i) => { Ra(e, t.class_applied), La(e, _a), i && (t.unobserve_completed && Da(e, t), Ia(t.callback_applied, e, i)) }; const Za = (e, t, i) => { Ra(e, t.class_loading), La(e, ya), i && (Ba(i, 1), Ia(t.callback_loading, e, i)) }; const ec = (e, t, i) => { i && e.setAttribute(t, i) }; const tc = (e, t) => { ec(e, fa, ka(e, t.data_sizes)), ec(e, pa, ka(e, t.data_srcset)), ec(e, ma, ka(e, t.data_src)) }; const ic = { IMG: (e, t) => { Ha(e, e => { Qa(e, Ka), tc(e, t) }), Qa(e, Ka), tc(e, t) }, IFRAME: (e, t) => { Qa(e, Va), ec(e, ma, ka(e, t.data_src)) }, VIDEO: (e, t) => { qa(e, e => { Qa(e, Va), ec(e, ma, ka(e, t.data_src)) }), Qa(e, Wa), ec(e, ga, ka(e, t.data_poster)), ec(e, ma, ka(e, t.data_src)), e.load() }, OBJECT: (e, t) => { Qa(e, za), ec(e, va, ka(e, t.data_src)) } }; const sc = ['IMG', 'IFRAME', 'VIDEO', 'OBJECT']; const nc = (e, t) => { !t || (e => e.loadingCount > 0)(t) || (e => e.toLoadCount > 0)(t) || Ia(e.callback_finish, t) }; const rc = (e, t, i) => { e.addEventListener(t, i), e.llEvLisnrs[t] = i }; const oc = (e, t, i) => { e.removeEventListener(t, i) }; const ac = e => !!e.llEvLisnrs; const cc = e => { if (!ac(e)) return; const t = e.llEvLisnrs; for (const i in t) { const s = t[i]; oc(e, i, s) } delete e.llEvLisnrs }; const lc = (e, t, i) => { (e => { delete e.llTempImage })(e), Ba(i, -1), (e => { e && (e.toLoadCount -= 1) })(i), Na(e, t.class_loading), t.unobserve_completed && Da(e, i) }; const hc = (e, t, i) => { const s = Fa(e) || e; if (ac(s)) return; ((e, t, i) => { ac(e) || (e.llEvLisnrs = {}); const s = e.tagName === 'VIDEO' ? 'loadeddata' : 'load'; rc(e, s, t), rc(e, 'error', i) })(s, n => { ((e, t, i, s) => { const n = Pa(t); lc(t, i, s), Ra(t, i.class_loaded), La(t, wa), Ia(i.callback_loaded, t, s), n || nc(i, s) })(0, e, t, i), cc(s) }, n => { ((e, t, i, s) => { const n = Pa(t); lc(t, i, s), Ra(t, i.class_error), La(t, Ea), Ia(i.callback_error, t, s), i.restore_on_error && Ya(t, Ka), n || nc(i, s) })(0, e, t, i), cc(s) }) }; const dc = (e, t, i) => { (e => { e.llTempImage = document.createElement('IMG') })(e), hc(e, t, i), (e => { Ua(e) || (e[ba] = { backgroundImage: e.style.backgroundImage }) })(e), ((e, t, i) => { const s = ka(e, t.data_bg); const n = ka(e, t.data_bg_hidpi); const r = la && n ? n : s; r && (e.style.backgroundImage = `url("${r}")`, Fa(e).setAttribute(ma, r), Za(e, t, i)) })(e, t, i), ((e, t, i) => { const s = ka(e, t.data_bg_multi); const n = ka(e, t.data_bg_multi_hidpi); const r = la && n ? n : s; r && (e.style.backgroundImage = r, Ja(e, t, i)) })(e, t, i), ((e, t, i) => { const s = ka(e, t.data_bg_set); if (!s) return; const n = s.split('|'); let r = n.map(e => `image-set(${e})`); e.style.backgroundImage = r.join(), e.style.backgroundImage === '' && (r = n.map(e => `-webkit-image-set(${e})`), e.style.backgroundImage = r.join()), Ja(e, t, i) })(e, t, i) }; const uc = (e, t, i) => { hc(e, t, i), ((e, t, i) => { const s = ic[e.tagName]; s && (s(e, t), Za(e, t, i)) })(e, t, i) }; const mc = (e, t, i) => { (e => sc.indexOf(e.tagName) > -1)(e) ? uc(e, t, i) : dc(e, t, i) }; const pc = (e, t, i) => { e.setAttribute('loading', 'lazy'), hc(e, t, i), ((e, t) => { const i = ic[e.tagName]; i && i(e, t) })(e, t), La(e, Aa) }; const fc = e => { e.removeAttribute(ma), e.removeAttribute(pa), e.removeAttribute(fa) }; const gc = e => { Ha(e, e => { Ya(e, Ka) }), Ya(e, Ka) }; const bc = { IMG: gc, IFRAME: e => { Ya(e, Va) }, VIDEO: e => { qa(e, e => { Ya(e, Va) }), Ya(e, Wa), e.load() }, OBJECT: e => { Ya(e, za) } }; const vc = e => { const t = bc[e.tagName]; t ? t(e) : (e => { if (!Ua(e)) return; const t = Ga(e); e.style.backgroundImage = t.backgroundImage })(e) }; const yc = (e, t) => { vc(e), ((e, t) => { Ma(e) || Pa(e) || (Na(e, t.class_entered), Na(e, t.class_exited), Na(e, t.class_applied), Na(e, t.class_loading), Na(e, t.class_loaded), Na(e, t.class_error)) })(e, t), Oa(e), Xa(e) }; const wc = (e, t, i, s) => { i.cancel_on_exit && (e => Ta(e) === ya)(e) && e.tagName === 'IMG' && (cc(e), (e => { Ha(e, e => { fc(e) }), fc(e) })(e), gc(e), Na(e, i.class_loading), Ba(s, -1), Oa(e), Ia(i.callback_cancel, e, t, s)) }; const _c = (e, t, i, s) => { const n = (e => xa.indexOf(Ta(e)) >= 0)(e); La(e, 'entered'), Ra(e, i.class_entered), Na(e, i.class_exited), ((e, t, i) => { t.unobserve_entered && Da(e, i) })(e, i, s), Ia(i.callback_enter, e, t, s), n || mc(e, i, s) }; const Ec = ['IMG', 'IFRAME', 'VIDEO']; const Ac = e => e.use_native && 'loading' in HTMLImageElement.prototype; const Sc = (e, t, i) => { e.forEach(e => (e => e.isIntersecting || e.intersectionRatio > 0)(e) ? _c(e.target, e, t, i) : ((e, t, i, s) => { Ma(e) || (Ra(e, i.class_exited), wc(e, t, i, s), Ia(i.callback_exit, e, t, s)) })(e.target, e, t, i)) }; const Cc = (e, t) => { aa && !Ac(e) && (t._observer = new IntersectionObserver(i => { Sc(i, e, t) }, (e => ({ root: e.container === document ? null : e.container, rootMargin: e.thresholds || e.threshold + 'px' }))(e))) }; const kc = e => Array.prototype.slice.call(e); const Tc = e => e.container.querySelectorAll(e.elements_selector); const Lc = e => (e => Ta(e) === Ea)(e); const Oc = (e, t) => (e => kc(e).filter(Ma))(e || Tc(t)); const Mc = (e, t) => { let i; (i = Tc(e), kc(i).filter(Lc)).forEach(t => { Na(t, e.class_error), Oa(t) }), t.update() }; const Pc = function (e, t) { const i = da(e); this._settings = i, this.loadingCount = 0, Cc(i, this), ((e, t) => { ra && (t._onlineHandler = () => { Mc(e, t) }, window.addEventListener('online', t._onlineHandler)) })(i, this), this.update(t) }; Pc.prototype = { update: function (e) { const t = this._settings; const i = Oc(e, t); let s, n; ($a(this, i.length), !oa && aa) ? Ac(t) ? ((e, t, i) => { e.forEach(e => { Ec.indexOf(e.tagName) !== -1 && pc(e, t, i) }), $a(i, 0) })(i, t, this) : (s = this._observer, n = i, (e => { e.disconnect() })(s), ((e, t) => { t.forEach(t => { e.observe(t) }) })(s, n)) : this.loadAll(i) }, destroy: function () { let e; this._observer && this._observer.disconnect(), e = this, ra && window.removeEventListener('online', e._onlineHandler), Tc(this._settings).forEach(e => { Xa(e) }), delete this._observer, delete this._settings, delete this._onlineHandler, delete this.loadingCount, delete this.toLoadCount }, loadAll: function (e) { const t = this._settings; Oc(e, t).forEach(e => { Da(e, this), mc(e, t, this) }) }, restoreAll: function () { const e = this._settings; Tc(e).forEach(t => { yc(t, e) }) } }, Pc.load = (e, t) => { const i = da(t); mc(e, i) }, Pc.resetStatus = e => { Oa(e) }, ra && ((e, t) => { if (t) if (t.length) for (let i, s = 0; i = t[s]; s += 1)ua(e, i); else ua(e, t) })(Pc, window.lazyLoadOptions), window.LazyLoad || (window.LazyLoad = Pc); class xc {constructor (e, t, i) { this.eventTarget = e, this.eventName = t, this.eventOptions = i, this.unorderedBindings = new Set() }connect () { this.eventTarget.addEventListener(this.eventName, this, this.eventOptions) }disconnect () { this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions) }bindingConnected (e) { this.unorderedBindings.add(e) }bindingDisconnected (e) { this.unorderedBindings.delete(e) }handleEvent (e) { const t = (function (e) { if ('immediatePropagationStopped' in e) return e; { const { stopImmediatePropagation: t } = e; return Object.assign(e, { immediatePropagationStopped: !1, stopImmediatePropagation () { this.immediatePropagationStopped = !0, t.call(this) } }) } }(e)); for (const e of this.bindings) { if (t.immediatePropagationStopped) break; e.handleEvent(t) } }hasBindings () { return this.unorderedBindings.size > 0 } get bindings () { return Array.from(this.unorderedBindings).sort((e, t) => { const i = e.index; const s = t.index; return i < s ? -1 : i > s ? 1 : 0 }) }} class Ic {constructor (e) { this.application = e, this.eventListenerMaps = new Map(), this.started = !1 }start () { this.started || (this.started = !0, this.eventListeners.forEach(e => e.connect())) }stop () { this.started && (this.started = !1, this.eventListeners.forEach(e => e.disconnect())) } get eventListeners () { return Array.from(this.eventListenerMaps.values()).reduce((e, t) => e.concat(Array.from(t.values())), []) }bindingConnected (e) { this.fetchEventListenerForBinding(e).bindingConnected(e) }bindingDisconnected (e, t = !1) { this.fetchEventListenerForBinding(e).bindingDisconnected(e), t && this.clearEventListenersForBinding(e) }handleError (e, t, i = {}) { this.application.handleError(e, `Error ${t}`, i) }clearEventListenersForBinding (e) { const t = this.fetchEventListenerForBinding(e); t.hasBindings() || (t.disconnect(), this.removeMappedEventListenerFor(e)) }removeMappedEventListenerFor (e) { const { eventTarget: t, eventName: i, eventOptions: s } = e; const n = this.fetchEventListenerMapForEventTarget(t); const r = this.cacheKey(i, s); n.delete(r), n.size == 0 && this.eventListenerMaps.delete(t) }fetchEventListenerForBinding (e) { const { eventTarget: t, eventName: i, eventOptions: s } = e; return this.fetchEventListener(t, i, s) }fetchEventListener (e, t, i) { const s = this.fetchEventListenerMapForEventTarget(e); const n = this.cacheKey(t, i); let r = s.get(n); return r || (r = this.createEventListener(e, t, i), s.set(n, r)), r }createEventListener (e, t, i) { const s = new xc(e, t, i); return this.started && s.connect(), s }fetchEventListenerMapForEventTarget (e) { let t = this.eventListenerMaps.get(e); return t || (t = new Map(), this.eventListenerMaps.set(e, t)), t }cacheKey (e, t) { const i = [e]; return Object.keys(t).sort().forEach(e => { i.push(`${t[e] ? '' : '!'}${e}`) }), i.join(':') }} const Rc = { stop: ({ event: e, value: t }) => (t && e.stopPropagation(), !0), prevent: ({ event: e, value: t }) => (t && e.preventDefault(), !0), self: ({ event: e, value: t, element: i }) => !t || i === e.target }; const Nc = /^(?:(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/; function Fc (e) { return e == 'window' ? window : e == 'document' ? document : void 0 } function Dc (e) { return e.replace(/(?:[_-])([a-z0-9])/g, (e, t) => t.toUpperCase()) } function Bc (e) { return Dc(e.replace(/--/g, '-').replace(/__/g, '_')) } function $c (e) { return e.charAt(0).toUpperCase() + e.slice(1) } function jc (e) { return e.replace(/([A-Z])/g, (e, t) => `-${t.toLowerCase()}`) } class Hc {constructor (e, t, i, s) { this.element = e, this.index = t, this.eventTarget = i.eventTarget || e, this.eventName = i.eventName || (function (e) { const t = e.tagName.toLowerCase(); if (t in qc) return qc[t](e) }(e)) || Vc('missing event name'), this.eventOptions = i.eventOptions || {}, this.identifier = i.identifier || Vc('missing identifier'), this.methodName = i.methodName || Vc('missing method name'), this.keyFilter = i.keyFilter || '', this.schema = s } static forToken (e, t) { return new this(e.element, e.index, (function (e) { const t = e.trim().match(Nc) || []; let i = t[1]; let s = t[2]; return s && !['keydown', 'keyup', 'keypress'].includes(i) && (i += `.${s}`, s = ''), { eventTarget: Fc(t[3]), eventName: i, eventOptions: t[6] ? (n = t[6], n.split(':').reduce((e, t) => Object.assign(e, { [t.replace(/^!/, '')]: !/^!/.test(t) }), {})) : {}, identifier: t[4], methodName: t[5], keyFilter: s }; let n }(e.content)), t) }toString () { const e = this.keyFilter ? `.${this.keyFilter}` : ''; const t = this.eventTargetName ? `@${this.eventTargetName}` : ''; return `${this.eventName}${e}${t}->${this.identifier}#${this.methodName}` }isFilterTarget (e) { if (!this.keyFilter) return !1; const t = this.keyFilter.split('+'); const i = ['meta', 'ctrl', 'alt', 'shift']; const [s, n, r, o] = i.map(e => t.includes(e)); if (e.metaKey !== s || e.ctrlKey !== n || e.altKey !== r || e.shiftKey !== o) return !0; const a = t.filter(e => !i.includes(e))[0]; return !!a && (Object.prototype.hasOwnProperty.call(this.keyMappings, a) || Vc(`contains unknown key filter: ${this.keyFilter}`), this.keyMappings[a].toLowerCase() !== e.key.toLowerCase()) } get params () { const e = {}; const t = new RegExp(`^data-${this.identifier}-(.+)-param$`, 'i'); for (const { name: i, value: s } of Array.from(this.element.attributes)) { const n = i.match(t); const r = n && n[1]; r && (e[Dc(r)] = Wc(s)) } return e } get eventTargetName () { return (e = this.eventTarget) == window ? 'window' : e == document ? 'document' : void 0; let e } get keyMappings () { return this.schema.keyMappings }} const qc = { a: () => 'click', button: () => 'click', form: () => 'submit', details: () => 'toggle', input: e => e.getAttribute('type') == 'submit' ? 'click' : 'input', select: () => 'change', textarea: () => 'input' }; function Vc (e) { throw new Error(e) } function Wc (e) { try { return JSON.parse(e) } catch (t) { return e } } class Kc {constructor (e, t) { this.context = e, this.action = t } get index () { return this.action.index } get eventTarget () { return this.action.eventTarget } get eventOptions () { return this.action.eventOptions } get identifier () { return this.context.identifier }handleEvent (e) { this.willBeInvokedByEvent(e) && this.applyEventModifiers(e) && this.invokeWithEvent(e) } get eventName () { return this.action.eventName } get method () { const e = this.controller[this.methodName]; if (typeof e === 'function') return e; throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`) }applyEventModifiers (e) { const { element: t } = this.action; const { actionDescriptorFilters: i } = this.context.application; let s = !0; for (const [n, r] of Object.entries(this.eventOptions)) if (n in i) { const o = i[n]; s = s && o({ name: n, value: r, event: e, element: t }) } return s }invokeWithEvent (e) { const { target: t, currentTarget: i } = e; try { const { params: s } = this.action; const n = Object.assign(e, { params: s }); this.method.call(this.controller, n), this.context.logDebugActivity(this.methodName, { event: e, target: t, currentTarget: i, action: this.methodName }) } catch (t) { const { identifier: i, controller: s, element: n, index: r } = this; const o = { identifier: i, controller: s, element: n, index: r, event: e }; this.context.handleError(t, `invoking action "${this.action}"`, o) } }willBeInvokedByEvent (e) { const t = e.target; return !(e instanceof KeyboardEvent && this.action.isFilterTarget(e)) && (this.element === t || (t instanceof Element && this.element.contains(t) ? this.scope.containsElement(t) : this.scope.containsElement(this.action.element))) } get controller () { return this.context.controller } get methodName () { return this.action.methodName } get element () { return this.scope.element } get scope () { return this.context.scope }} class zc {constructor (e, t) { this.mutationObserverInit = { attributes: !0, childList: !0, subtree: !0 }, this.element = e, this.started = !1, this.delegate = t, this.elements = new Set(), this.mutationObserver = new MutationObserver(e => this.processMutations(e)) }start () { this.started || (this.started = !0, this.mutationObserver.observe(this.element, this.mutationObserverInit), this.refresh()) }pause (e) { this.started && (this.mutationObserver.disconnect(), this.started = !1), e(), this.started || (this.mutationObserver.observe(this.element, this.mutationObserverInit), this.started = !0) }stop () { this.started && (this.mutationObserver.takeRecords(), this.mutationObserver.disconnect(), this.started = !1) }refresh () { if (this.started) { const e = new Set(this.matchElementsInTree()); for (const t of Array.from(this.elements))e.has(t) || this.removeElement(t); for (const t of Array.from(e)) this.addElement(t) } }processMutations (e) { if (this.started) for (const t of e) this.processMutation(t) }processMutation (e) { e.type == 'attributes' ? this.processAttributeChange(e.target, e.attributeName) : e.type == 'childList' && (this.processRemovedNodes(e.removedNodes), this.processAddedNodes(e.addedNodes)) }processAttributeChange (e, t) { const i = e; this.elements.has(i) ? this.delegate.elementAttributeChanged && this.matchElement(i) ? this.delegate.elementAttributeChanged(i, t) : this.removeElement(i) : this.matchElement(i) && this.addElement(i) }processRemovedNodes (e) { for (const t of Array.from(e)) { const e = this.elementFromNode(t); e && this.processTree(e, this.removeElement) } }processAddedNodes (e) { for (const t of Array.from(e)) { const e = this.elementFromNode(t); e && this.elementIsActive(e) && this.processTree(e, this.addElement) } }matchElement (e) { return this.delegate.matchElement(e) }matchElementsInTree (e = this.element) { return this.delegate.matchElementsInTree(e) }processTree (e, t) { for (const i of this.matchElementsInTree(e))t.call(this, i) }elementFromNode (e) { if (e.nodeType == Node.ELEMENT_NODE) return e }elementIsActive (e) { return e.isConnected == this.element.isConnected && this.element.contains(e) }addElement (e) { this.elements.has(e) || this.elementIsActive(e) && (this.elements.add(e), this.delegate.elementMatched && this.delegate.elementMatched(e)) }removeElement (e) { this.elements.has(e) && (this.elements.delete(e), this.delegate.elementUnmatched && this.delegate.elementUnmatched(e)) }} class Uc {constructor (e, t, i) { this.attributeName = t, this.delegate = i, this.elementObserver = new zc(e, this) } get element () { return this.elementObserver.element } get selector () { return `[${this.attributeName}]` }start () { this.elementObserver.start() }pause (e) { this.elementObserver.pause(e) }stop () { this.elementObserver.stop() }refresh () { this.elementObserver.refresh() } get started () { return this.elementObserver.started }matchElement (e) { return e.hasAttribute(this.attributeName) }matchElementsInTree (e) { const t = this.matchElement(e) ? [e] : []; const i = Array.from(e.querySelectorAll(this.selector)); return t.concat(i) }elementMatched (e) { this.delegate.elementMatchedAttribute && this.delegate.elementMatchedAttribute(e, this.attributeName) }elementUnmatched (e) { this.delegate.elementUnmatchedAttribute && this.delegate.elementUnmatchedAttribute(e, this.attributeName) }elementAttributeChanged (e, t) { this.delegate.elementAttributeValueChanged && this.attributeName == t && this.delegate.elementAttributeValueChanged(e, t) }} function Gc (e, t) { let i = e.get(t); return i || (i = new Set(), e.set(t, i)), i } class Xc {constructor () { this.valuesByKey = new Map() } get keys () { return Array.from(this.valuesByKey.keys()) } get values () { return Array.from(this.valuesByKey.values()).reduce((e, t) => e.concat(Array.from(t)), []) } get size () { return Array.from(this.valuesByKey.values()).reduce((e, t) => e + t.size, 0) }add (e, t) { !(function (e, t, i) { Gc(e, t).add(i) }(this.valuesByKey, e, t)) }delete (e, t) { !(function (e, t, i) { Gc(e, t).delete(i), (function (e, t) { const i = e.get(t); i != null && i.size == 0 && e.delete(t) }(e, t)) }(this.valuesByKey, e, t)) }has (e, t) { const i = this.valuesByKey.get(e); return i != null && i.has(t) }hasKey (e) { return this.valuesByKey.has(e) }hasValue (e) { return Array.from(this.valuesByKey.values()).some(t => t.has(e)) }getValuesForKey (e) { const t = this.valuesByKey.get(e); return t ? Array.from(t) : [] }getKeysForValue (e) { return Array.from(this.valuesByKey).filter(([t, i]) => i.has(e)).map(([e, t]) => e) }} class Qc {constructor (e, t, i, s = {}) { this.selector = t, this.details = s, this.elementObserver = new zc(e, this), this.delegate = i, this.matchesByElement = new Xc() } get started () { return this.elementObserver.started }start () { this.elementObserver.start() }pause (e) { this.elementObserver.pause(e) }stop () { this.elementObserver.stop() }refresh () { this.elementObserver.refresh() } get element () { return this.elementObserver.element }matchElement (e) { const t = e.matches(this.selector); return this.delegate.selectorMatchElement ? t && this.delegate.selectorMatchElement(e, this.details) : t }matchElementsInTree (e) { const t = this.matchElement(e) ? [e] : []; const i = Array.from(e.querySelectorAll(this.selector)).filter(e => this.matchElement(e)); return t.concat(i) }elementMatched (e) { this.selectorMatched(e) }elementUnmatched (e) { this.selectorUnmatched(e) }elementAttributeChanged (e, t) { const i = this.matchElement(e); const s = this.matchesByElement.has(this.selector, e); !i && s && this.selectorUnmatched(e) }selectorMatched (e) { this.delegate.selectorMatched && (this.delegate.selectorMatched(e, this.selector, this.details), this.matchesByElement.add(this.selector, e)) }selectorUnmatched (e) { this.delegate.selectorUnmatched(e, this.selector, this.details), this.matchesByElement.delete(this.selector, e) }} class Yc {constructor (e, t) { this.element = e, this.delegate = t, this.started = !1, this.stringMap = new Map(), this.mutationObserver = new MutationObserver(e => this.processMutations(e)) }start () { this.started || (this.started = !0, this.mutationObserver.observe(this.element, { attributes: !0, attributeOldValue: !0 }), this.refresh()) }stop () { this.started && (this.mutationObserver.takeRecords(), this.mutationObserver.disconnect(), this.started = !1) }refresh () { if (this.started) for (const e of this.knownAttributeNames) this.refreshAttribute(e, null) }processMutations (e) { if (this.started) for (const t of e) this.processMutation(t) }processMutation (e) { const t = e.attributeName; t && this.refreshAttribute(t, e.oldValue) }refreshAttribute (e, t) { const i = this.delegate.getStringMapKeyForAttribute(e); if (i != null) { this.stringMap.has(e) || this.stringMapKeyAdded(i, e); const s = this.element.getAttribute(e); if (this.stringMap.get(e) != s && this.stringMapValueChanged(s, i, t), s == null) { const t = this.stringMap.get(e); this.stringMap.delete(e), t && this.stringMapKeyRemoved(i, e, t) } else this.stringMap.set(e, s) } }stringMapKeyAdded (e, t) { this.delegate.stringMapKeyAdded && this.delegate.stringMapKeyAdded(e, t) }stringMapValueChanged (e, t, i) { this.delegate.stringMapValueChanged && this.delegate.stringMapValueChanged(e, t, i) }stringMapKeyRemoved (e, t, i) { this.delegate.stringMapKeyRemoved && this.delegate.stringMapKeyRemoved(e, t, i) } get knownAttributeNames () { return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames))) } get currentAttributeNames () { return Array.from(this.element.attributes).map(e => e.name) } get recordedAttributeNames () { return Array.from(this.stringMap.keys()) }} class Jc {constructor (e, t, i) { this.attributeObserver = new Uc(e, t, this), this.delegate = i, this.tokensByElement = new Xc() } get started () { return this.attributeObserver.started }start () { this.attributeObserver.start() }pause (e) { this.attributeObserver.pause(e) }stop () { this.attributeObserver.stop() }refresh () { this.attributeObserver.refresh() } get element () { return this.attributeObserver.element } get attributeName () { return this.attributeObserver.attributeName }elementMatchedAttribute (e) { this.tokensMatched(this.readTokensForElement(e)) }elementAttributeValueChanged (e) { const [t, i] = this.refreshTokensForElement(e); this.tokensUnmatched(t), this.tokensMatched(i) }elementUnmatchedAttribute (e) { this.tokensUnmatched(this.tokensByElement.getValuesForKey(e)) }tokensMatched (e) { e.forEach(e => this.tokenMatched(e)) }tokensUnmatched (e) { e.forEach(e => this.tokenUnmatched(e)) }tokenMatched (e) { this.delegate.tokenMatched(e), this.tokensByElement.add(e.element, e) }tokenUnmatched (e) { this.delegate.tokenUnmatched(e), this.tokensByElement.delete(e.element, e) }refreshTokensForElement (e) { const t = this.tokensByElement.getValuesForKey(e); const i = this.readTokensForElement(e); const s = (function (e, t) { const i = Math.max(e.length, t.length); return Array.from({ length: i }, (i, s) => [e[s], t[s]]) }(t, i)).findIndex(([e, t]) => !(function (e, t) { return e && t && e.index == t.index && e.content == t.content }(e, t))); return s == -1 ? [[], []] : [t.slice(s), i.slice(s)] }readTokensForElement (e) { const t = this.attributeName; return (function (e, t, i) { return e.trim().split(/\s+/).filter(e => e.length).map((e, s) => ({ element: t, attributeName: i, content: e, index: s })) }(e.getAttribute(t) || '', e, t)) }} class Zc {constructor (e, t, i) { this.tokenListObserver = new Jc(e, t, this), this.delegate = i, this.parseResultsByToken = new WeakMap(), this.valuesByTokenByElement = new WeakMap() } get started () { return this.tokenListObserver.started }start () { this.tokenListObserver.start() }stop () { this.tokenListObserver.stop() }refresh () { this.tokenListObserver.refresh() } get element () { return this.tokenListObserver.element } get attributeName () { return this.tokenListObserver.attributeName }tokenMatched (e) { const { element: t } = e; const { value: i } = this.fetchParseResultForToken(e); i && (this.fetchValuesByTokenForElement(t).set(e, i), this.delegate.elementMatchedValue(t, i)) }tokenUnmatched (e) { const { element: t } = e; const { value: i } = this.fetchParseResultForToken(e); i && (this.fetchValuesByTokenForElement(t).delete(e), this.delegate.elementUnmatchedValue(t, i)) }fetchParseResultForToken (e) { let t = this.parseResultsByToken.get(e); return t || (t = this.parseToken(e), this.parseResultsByToken.set(e, t)), t }fetchValuesByTokenForElement (e) { let t = this.valuesByTokenByElement.get(e); return t || (t = new Map(), this.valuesByTokenByElement.set(e, t)), t }parseToken (e) { try { return { value: this.delegate.parseValueForToken(e) } } catch (e) { return { error: e } } }} class el {constructor (e, t) { this.context = e, this.delegate = t, this.bindingsByAction = new Map() }start () { this.valueListObserver || (this.valueListObserver = new Zc(this.element, this.actionAttribute, this), this.valueListObserver.start()) }stop () { this.valueListObserver && (this.valueListObserver.stop(), delete this.valueListObserver, this.disconnectAllActions()) } get element () { return this.context.element } get identifier () { return this.context.identifier } get actionAttribute () { return this.schema.actionAttribute } get schema () { return this.context.schema } get bindings () { return Array.from(this.bindingsByAction.values()) }connectAction (e) { const t = new Kc(this.context, e); this.bindingsByAction.set(e, t), this.delegate.bindingConnected(t) }disconnectAction (e) { const t = this.bindingsByAction.get(e); t && (this.bindingsByAction.delete(e), this.delegate.bindingDisconnected(t)) }disconnectAllActions () { this.bindings.forEach(e => this.delegate.bindingDisconnected(e, !0)), this.bindingsByAction.clear() }parseValueForToken (e) { const t = Hc.forToken(e, this.schema); if (t.identifier == this.identifier) return t }elementMatchedValue (e, t) { this.connectAction(t) }elementUnmatchedValue (e, t) { this.disconnectAction(t) }} class tl {constructor (e, t) { this.context = e, this.receiver = t, this.stringMapObserver = new Yc(this.element, this), this.valueDescriptorMap = this.controller.valueDescriptorMap }start () { this.stringMapObserver.start(), this.invokeChangedCallbacksForDefaultValues() }stop () { this.stringMapObserver.stop() } get element () { return this.context.element } get controller () { return this.context.controller }getStringMapKeyForAttribute (e) { if (e in this.valueDescriptorMap) return this.valueDescriptorMap[e].name }stringMapKeyAdded (e, t) { const i = this.valueDescriptorMap[t]; this.hasValue(e) || this.invokeChangedCallback(e, i.writer(this.receiver[e]), i.writer(i.defaultValue)) }stringMapValueChanged (e, t, i) { const s = this.valueDescriptorNameMap[t]; e !== null && (i === null && (i = s.writer(s.defaultValue)), this.invokeChangedCallback(t, e, i)) }stringMapKeyRemoved (e, t, i) { const s = this.valueDescriptorNameMap[e]; this.hasValue(e) ? this.invokeChangedCallback(e, s.writer(this.receiver[e]), i) : this.invokeChangedCallback(e, s.writer(s.defaultValue), i) }invokeChangedCallbacksForDefaultValues () { for (const { key: e, name: t, defaultValue: i, writer: s } of this.valueDescriptors)i == null || this.controller.data.has(e) || this.invokeChangedCallback(t, s(i), void 0) }invokeChangedCallback (e, t, i) { const s = `${e}Changed`; const n = this.receiver[s]; if (typeof n === 'function') { const s = this.valueDescriptorNameMap[e]; try { const e = s.reader(t); let r = i; i && (r = s.reader(i)), n.call(this.receiver, e, r) } catch (e) { throw e instanceof TypeError && (e.message = `Stimulus Value "${this.context.identifier}.${s.name}" - ${e.message}`), e } } } get valueDescriptors () { const { valueDescriptorMap: e } = this; return Object.keys(e).map(t => e[t]) } get valueDescriptorNameMap () { const e = {}; return Object.keys(this.valueDescriptorMap).forEach(t => { const i = this.valueDescriptorMap[t]; e[i.name] = i }), e }hasValue (e) { const t = `has${$c(this.valueDescriptorNameMap[e].name)}`; return this.receiver[t] }} class il {constructor (e, t) { this.context = e, this.delegate = t, this.targetsByName = new Xc() }start () { this.tokenListObserver || (this.tokenListObserver = new Jc(this.element, this.attributeName, this), this.tokenListObserver.start()) }stop () { this.tokenListObserver && (this.disconnectAllTargets(), this.tokenListObserver.stop(), delete this.tokenListObserver) }tokenMatched ({ element: e, content: t }) { this.scope.containsElement(e) && this.connectTarget(e, t) }tokenUnmatched ({ element: e, content: t }) { this.disconnectTarget(e, t) }connectTarget (e, t) { let i; this.targetsByName.has(t, e) || (this.targetsByName.add(t, e), (i = this.tokenListObserver) === null || void 0 === i || i.pause(() => this.delegate.targetConnected(e, t))) }disconnectTarget (e, t) { let i; this.targetsByName.has(t, e) && (this.targetsByName.delete(t, e), (i = this.tokenListObserver) === null || void 0 === i || i.pause(() => this.delegate.targetDisconnected(e, t))) }disconnectAllTargets () { for (const e of this.targetsByName.keys) for (const t of this.targetsByName.getValuesForKey(e)) this.disconnectTarget(t, e) } get attributeName () { return `data-${this.context.identifier}-target` } get element () { return this.context.element } get scope () { return this.context.scope }} function sl (e, t) { const i = rl(e); return Array.from(i.reduce((e, i) => ((function (e, t) { const i = e[t]; return Array.isArray(i) ? i : [] }(i, t)).forEach(t => e.add(t)), e), new Set())) } function nl (e, t) { return rl(e).reduce((e, i) => (e.push(...(function (e, t) { const i = e[t]; return i ? Object.keys(i).map(e => [e, i[e]]) : [] }(i, t))), e), []) } function rl (e) { const t = []; for (;e;)t.push(e), e = Object.getPrototypeOf(e); return t.reverse() } class ol {constructor (e, t) { this.context = e, this.delegate = t, this.outletsByName = new Xc(), this.outletElementsByName = new Xc(), this.selectorObserverMap = new Map() }start () { this.selectorObserverMap.size === 0 && (this.outletDefinitions.forEach(e => { const t = this.selector(e); const i = { outletName: e }; t && this.selectorObserverMap.set(e, new Qc(document.body, t, this, i)) }), this.selectorObserverMap.forEach(e => e.start())), this.dependentContexts.forEach(e => e.refresh()) }stop () { this.selectorObserverMap.size > 0 && (this.disconnectAllOutlets(), this.selectorObserverMap.forEach(e => e.stop()), this.selectorObserverMap.clear()) }refresh () { this.selectorObserverMap.forEach(e => e.refresh()) }selectorMatched (e, t, { outletName: i }) { const s = this.getOutlet(e, i); s && this.connectOutlet(s, e, i) }selectorUnmatched (e, t, { outletName: i }) { const s = this.getOutletFromMap(e, i); s && this.disconnectOutlet(s, e, i) }selectorMatchElement (e, { outletName: t }) { return this.hasOutlet(e, t) && e.matches(`[${this.context.application.schema.controllerAttribute}~=${t}]`) }connectOutlet (e, t, i) { let s; this.outletElementsByName.has(i, t) || (this.outletsByName.add(i, e), this.outletElementsByName.add(i, t), (s = this.selectorObserverMap.get(i)) === null || void 0 === s || s.pause(() => this.delegate.outletConnected(e, t, i))) }disconnectOutlet (e, t, i) { let s; this.outletElementsByName.has(i, t) && (this.outletsByName.delete(i, e), this.outletElementsByName.delete(i, t), (s = this.selectorObserverMap.get(i)) === null || void 0 === s || s.pause(() => this.delegate.outletDisconnected(e, t, i))) }disconnectAllOutlets () { for (const e of this.outletElementsByName.keys) for (const t of this.outletElementsByName.getValuesForKey(e)) for (const i of this.outletsByName.getValuesForKey(e)) this.disconnectOutlet(i, t, e) }selector (e) { return this.scope.outlets.getSelectorForOutletName(e) } get outletDependencies () { const e = new Xc(); return this.router.modules.forEach(t => { sl(t.definition.controllerConstructor, 'outlets').forEach(i => e.add(i, t.identifier)) }), e } get outletDefinitions () { return this.outletDependencies.getKeysForValue(this.identifier) } get dependentControllerIdentifiers () { return this.outletDependencies.getValuesForKey(this.identifier) } get dependentContexts () { const e = this.dependentControllerIdentifiers; return this.router.contexts.filter(t => e.includes(t.identifier)) }hasOutlet (e, t) { return !!this.getOutlet(e, t) || !!this.getOutletFromMap(e, t) }getOutlet (e, t) { return this.application.getControllerForElementAndIdentifier(e, t) }getOutletFromMap (e, t) { return this.outletsByName.getValuesForKey(t).find(t => t.element === e) } get scope () { return this.context.scope } get identifier () { return this.context.identifier } get application () { return this.context.application } get router () { return this.application.router }} class al {constructor (e, t) { this.logDebugActivity = (e, t = {}) => { const { identifier: i, controller: s, element: n } = this; t = Object.assign({ identifier: i, controller: s, element: n }, t), this.application.logDebugActivity(this.identifier, e, t) }, this.module = e, this.scope = t, this.controller = new e.controllerConstructor(this), this.bindingObserver = new el(this, this.dispatcher), this.valueObserver = new tl(this, this.controller), this.targetObserver = new il(this, this), this.outletObserver = new ol(this, this); try { this.controller.initialize(), this.logDebugActivity('initialize') } catch (e) { this.handleError(e, 'initializing controller') } }connect () { this.bindingObserver.start(), this.valueObserver.start(), this.targetObserver.start(), this.outletObserver.start(); try { this.controller.connect(), this.logDebugActivity('connect') } catch (e) { this.handleError(e, 'connecting controller') } }refresh () { this.outletObserver.refresh() }disconnect () { try { this.controller.disconnect(), this.logDebugActivity('disconnect') } catch (e) { this.handleError(e, 'disconnecting controller') } this.outletObserver.stop(), this.targetObserver.stop(), this.valueObserver.stop(), this.bindingObserver.stop() } get application () { return this.module.application } get identifier () { return this.module.identifier } get schema () { return this.application.schema } get dispatcher () { return this.application.dispatcher } get element () { return this.scope.element } get parentElement () { return this.element.parentElement }handleError (e, t, i = {}) { const { identifier: s, controller: n, element: r } = this; i = Object.assign({ identifier: s, controller: n, element: r }, i), this.application.handleError(e, `Error ${t}`, i) }targetConnected (e, t) { this.invokeControllerMethod(`${t}TargetConnected`, e) }targetDisconnected (e, t) { this.invokeControllerMethod(`${t}TargetDisconnected`, e) }outletConnected (e, t, i) { this.invokeControllerMethod(`${Bc(i)}OutletConnected`, e, t) }outletDisconnected (e, t, i) { this.invokeControllerMethod(`${Bc(i)}OutletDisconnected`, e, t) }invokeControllerMethod (e, ...t) { const i = this.controller; typeof i[e] === 'function' && i[e](...t) }} function cl (e) { return (function (e, t) { const i = hl(e); const s = (function (e, t) { return ll(t).reduce((i, s) => { const n = (function (e, t, i) { const s = Object.getOwnPropertyDescriptor(e, i); if (!s || !('value' in s)) { const e = Object.getOwnPropertyDescriptor(t, i).value; return s && (e.get = s.get || e.get, e.set = s.set || e.set), e } }(e, t, s)); return n && Object.assign(i, { [s]: n }), i }, {}) }(e.prototype, t)); return Object.defineProperties(i.prototype, s), i }(e, (function (e) { const t = sl(e, 'blessings'); return t.reduce((t, i) => { const s = i(e); for (const e in s) { const i = t[e] || {}; t[e] = Object.assign(i, s[e]) } return t }, {}) }(e)))) } const ll = typeof Object.getOwnPropertySymbols === 'function' ? e => [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)] : Object.getOwnPropertyNames; const hl = (() => { function e (e) { function t () { return Reflect.construct(e, arguments, new.target) } return t.prototype = Object.create(e.prototype, { constructor: { value: t } }), Reflect.setPrototypeOf(t, e), t } try { return (function () { const t = e(function () { this.a.call(this) }); t.prototype.a = function () {}, new t() }()), e } catch (e) { return e => class extends e {} } })(); class dl {constructor (e, t) { this.application = e, this.definition = (function (e) { return { identifier: e.identifier, controllerConstructor: cl(e.controllerConstructor) } }(t)), this.contextsByScope = new WeakMap(), this.connectedContexts = new Set() } get identifier () { return this.definition.identifier } get controllerConstructor () { return this.definition.controllerConstructor } get contexts () { return Array.from(this.connectedContexts) }connectContextForScope (e) { const t = this.fetchContextForScope(e); this.connectedContexts.add(t), t.connect() }disconnectContextForScope (e) { const t = this.contextsByScope.get(e); t && (this.connectedContexts.delete(t), t.disconnect()) }fetchContextForScope (e) { let t = this.contextsByScope.get(e); return t || (t = new al(this, e), this.contextsByScope.set(e, t)), t }} class ul {constructor (e) { this.scope = e }has (e) { return this.data.has(this.getDataKey(e)) }get (e) { return this.getAll(e)[0] }getAll (e) { const t = this.data.get(this.getDataKey(e)) || ''; return t.match(/[^\s]+/g) || [] }getAttributeName (e) { return this.data.getAttributeNameForKey(this.getDataKey(e)) }getDataKey (e) { return `${e}-class` } get data () { return this.scope.data }} class ml {constructor (e) { this.scope = e } get element () { return this.scope.element } get identifier () { return this.scope.identifier }get (e) { const t = this.getAttributeNameForKey(e); return this.element.getAttribute(t) }set (e, t) { const i = this.getAttributeNameForKey(e); return this.element.setAttribute(i, t), this.get(e) }has (e) { const t = this.getAttributeNameForKey(e); return this.element.hasAttribute(t) }delete (e) { if (this.has(e)) { const t = this.getAttributeNameForKey(e); return this.element.removeAttribute(t), !0 } return !1 }getAttributeNameForKey (e) { return `data-${this.identifier}-${jc(e)}` }} class pl {constructor (e) { this.warnedKeysByObject = new WeakMap(), this.logger = e }warn (e, t, i) { let s = this.warnedKeysByObject.get(e); s || (s = new Set(), this.warnedKeysByObject.set(e, s)), s.has(t) || (s.add(t), this.logger.warn(i, e)) }} function fl (e, t) { return `[${e}~="${t}"]` } class gl {constructor (e) { this.scope = e } get element () { return this.scope.element } get identifier () { return this.scope.identifier } get schema () { return this.scope.schema }has (e) { return this.find(e) != null }find (...e) { return e.reduce((e, t) => e || this.findTarget(t) || this.findLegacyTarget(t), void 0) }findAll (...e) { return e.reduce((e, t) => [...e, ...this.findAllTargets(t), ...this.findAllLegacyTargets(t)], []) }findTarget (e) { const t = this.getSelectorForTargetName(e); return this.scope.findElement(t) }findAllTargets (e) { const t = this.getSelectorForTargetName(e); return this.scope.findAllElements(t) }getSelectorForTargetName (e) { return fl(this.schema.targetAttributeForScope(this.identifier), e) }findLegacyTarget (e) { const t = this.getLegacySelectorForTargetName(e); return this.deprecate(this.scope.findElement(t), e) }findAllLegacyTargets (e) { const t = this.getLegacySelectorForTargetName(e); return this.scope.findAllElements(t).map(t => this.deprecate(t, e)) }getLegacySelectorForTargetName (e) { const t = `${this.identifier}.${e}`; return fl(this.schema.targetAttribute, t) }deprecate (e, t) { if (e) { const { identifier: i } = this; const s = this.schema.targetAttribute; const n = this.schema.targetAttributeForScope(i); this.guide.warn(e, `target:${t}`, `Please replace ${s}="${i}.${t}" with ${n}="${t}". The ${s} attribute is deprecated and will be removed in a future version of Stimulus.`) } return e } get guide () { return this.scope.guide }} class bl {constructor (e, t) { this.scope = e, this.controllerElement = t } get element () { return this.scope.element } get identifier () { return this.scope.identifier } get schema () { return this.scope.schema }has (e) { return this.find(e) != null }find (...e) { return e.reduce((e, t) => e || this.findOutlet(t), void 0) }findAll (...e) { return e.reduce((e, t) => [...e, ...this.findAllOutlets(t)], []) }getSelectorForOutletName (e) { const t = this.schema.outletAttributeForScope(this.identifier, e); return this.controllerElement.getAttribute(t) }findOutlet (e) { const t = this.getSelectorForOutletName(e); if (t) return this.findElement(t, e) }findAllOutlets (e) { const t = this.getSelectorForOutletName(e); return t ? this.findAllElements(t, e) : [] }findElement (e, t) { return this.scope.queryElements(e).filter(i => this.matchesElement(i, e, t))[0] }findAllElements (e, t) { return this.scope.queryElements(e).filter(i => this.matchesElement(i, e, t)) }matchesElement (e, t, i) { const s = e.getAttribute(this.scope.schema.controllerAttribute) || ''; return e.matches(t) && s.split(' ').includes(i) }} class vl {constructor (e, t, i, s) { this.targets = new gl(this), this.classes = new ul(this), this.data = new ml(this), this.containsElement = e => e.closest(this.controllerSelector) === this.element, this.schema = e, this.element = t, this.identifier = i, this.guide = new pl(s), this.outlets = new bl(this.documentScope, t) }findElement (e) { return this.element.matches(e) ? this.element : this.queryElements(e).find(this.containsElement) }findAllElements (e) { return [...this.element.matches(e) ? [this.element] : [], ...this.queryElements(e).filter(this.containsElement)] }queryElements (e) { return Array.from(this.element.querySelectorAll(e)) } get controllerSelector () { return fl(this.schema.controllerAttribute, this.identifier) } get isDocumentScope () { return this.element === document.documentElement } get documentScope () { return this.isDocumentScope ? this : new vl(this.schema, document.documentElement, this.identifier, this.guide.logger) }} class yl {constructor (e, t, i) { this.element = e, this.schema = t, this.delegate = i, this.valueListObserver = new Zc(this.element, this.controllerAttribute, this), this.scopesByIdentifierByElement = new WeakMap(), this.scopeReferenceCounts = new WeakMap() }start () { this.valueListObserver.start() }stop () { this.valueListObserver.stop() } get controllerAttribute () { return this.schema.controllerAttribute }parseValueForToken (e) { const { element: t, content: i } = e; const s = this.fetchScopesByIdentifierForElement(t); let n = s.get(i); return n || (n = this.delegate.createScopeForElementAndIdentifier(t, i), s.set(i, n)), n }elementMatchedValue (e, t) { const i = (this.scopeReferenceCounts.get(t) || 0) + 1; this.scopeReferenceCounts.set(t, i), i == 1 && this.delegate.scopeConnected(t) }elementUnmatchedValue (e, t) { const i = this.scopeReferenceCounts.get(t); i && (this.scopeReferenceCounts.set(t, i - 1), i == 1 && this.delegate.scopeDisconnected(t)) }fetchScopesByIdentifierForElement (e) { let t = this.scopesByIdentifierByElement.get(e); return t || (t = new Map(), this.scopesByIdentifierByElement.set(e, t)), t }} class wl {constructor (e) { this.application = e, this.scopeObserver = new yl(this.element, this.schema, this), this.scopesByIdentifier = new Xc(), this.modulesByIdentifier = new Map() } get element () { return this.application.element } get schema () { return this.application.schema } get logger () { return this.application.logger } get controllerAttribute () { return this.schema.controllerAttribute } get modules () { return Array.from(this.modulesByIdentifier.values()) } get contexts () { return this.modules.reduce((e, t) => e.concat(t.contexts), []) }start () { this.scopeObserver.start() }stop () { this.scopeObserver.stop() }loadDefinition (e) { this.unloadIdentifier(e.identifier); const t = new dl(this.application, e); this.connectModule(t); const i = e.controllerConstructor.afterLoad; i && i(e.identifier, this.application) }unloadIdentifier (e) { const t = this.modulesByIdentifier.get(e); t && this.disconnectModule(t) }getContextForElementAndIdentifier (e, t) { const i = this.modulesByIdentifier.get(t); if (i) return i.contexts.find(t => t.element == e) }handleError (e, t, i) { this.application.handleError(e, t, i) }createScopeForElementAndIdentifier (e, t) { return new vl(this.schema, e, t, this.logger) }scopeConnected (e) { this.scopesByIdentifier.add(e.identifier, e); const t = this.modulesByIdentifier.get(e.identifier); t && t.connectContextForScope(e) }scopeDisconnected (e) { this.scopesByIdentifier.delete(e.identifier, e); const t = this.modulesByIdentifier.get(e.identifier); t && t.disconnectContextForScope(e) }connectModule (e) { this.modulesByIdentifier.set(e.identifier, e); this.scopesByIdentifier.getValuesForKey(e.identifier).forEach(t => e.connectContextForScope(t)) }disconnectModule (e) { this.modulesByIdentifier.delete(e.identifier); this.scopesByIdentifier.getValuesForKey(e.identifier).forEach(t => e.disconnectContextForScope(t)) }} const _l = { controllerAttribute: 'data-controller', actionAttribute: 'data-action', targetAttribute: 'data-target', targetAttributeForScope: e => `data-${e}-target`, outletAttributeForScope: (e, t) => `data-${e}-${t}-outlet`, keyMappings: Object.assign(Object.assign({ enter: 'Enter', tab: 'Tab', esc: 'Escape', space: ' ', up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', home: 'Home', end: 'End' }, El('abcdefghijklmnopqrstuvwxyz'.split('').map(e => [e, e]))), El('0123456789'.split('').map(e => [e, e]))) }; function El (e) { return e.reduce((e, [t, i]) => Object.assign(Object.assign({}, e), { [t]: i }), {}) } function Al ([e, t], i) { return (function (e) { const t = `${jc(e.token)}-value`; const i = (function (e) { const t = (function (e) { const t = Sl(e.typeObject.type); if (!t) return; const i = Cl(e.typeObject.default); if (t !== i) { const s = e.controller ? `${e.controller}.${e.token}` : e.token; throw new Error(`The specified default value for the Stimulus Value "${s}" must match the defined type "${t}". The provided default value of "${e.typeObject.default}" is of type "${i}".`) } return t }({ controller: e.controller, token: e.token, typeObject: e.typeDefinition })); const i = Cl(e.typeDefinition); const s = Sl(e.typeDefinition); const n = t || i || s; if (n) return n; const r = e.controller ? `${e.controller}.${e.typeDefinition}` : e.token; throw new Error(`Unknown value type "${r}" for "${e.token}" value`) }(e)); return { type: i, key: t, name: Dc(t), get defaultValue () { return (function (e) { const t = Sl(e); if (t) return kl[t]; const i = e.default; return void 0 !== i ? i : e }(e.typeDefinition)) }, get hasCustomDefaultValue () { return void 0 !== Cl(e.typeDefinition) }, reader: Tl[i], writer: Ll[i] || Ll.default } }({ controller: i, token: e, typeDefinition: t })) } function Sl (e) { switch (e) { case Array:return 'array'; case Boolean:return 'boolean'; case Number:return 'number'; case Object:return 'object'; case String:return 'string' } } function Cl (e) { switch (typeof e) { case 'boolean':return 'boolean'; case 'number':return 'number'; case 'string':return 'string' } return Array.isArray(e) ? 'array' : Object.prototype.toString.call(e) === '[object Object]' ? 'object' : void 0 } const kl = { get array () { return [] }, boolean: !1, number: 0, get object () { return {} }, string: '' }; const Tl = { array (e) { const t = JSON.parse(e); if (!Array.isArray(t)) throw new TypeError(`expected value of type "array" but instead got value "${e}" of type "${Cl(t)}"`); return t }, boolean: e => !(e == '0' || String(e).toLowerCase() == 'false'), number: e => Number(e), object (e) { const t = JSON.parse(e); if (t === null || typeof t !== 'object' || Array.isArray(t)) throw new TypeError(`expected value of type "object" but instead got value "${e}" of type "${Cl(t)}"`); return t }, string: e => e }; const Ll = { default: function (e) { return `${e}` }, array: Ol, object: Ol }; function Ol (e) { return JSON.stringify(e) } class Ml {constructor (e) { this.context = e } static get shouldLoad () { return !0 } static afterLoad (e, t) {} get application () { return this.context.application } get scope () { return this.context.scope } get element () { return this.scope.element } get identifier () { return this.scope.identifier } get targets () { return this.scope.targets } get outlets () { return this.scope.outlets } get classes () { return this.scope.classes } get data () { return this.scope.data }initialize () {}connect () {}disconnect () {}dispatch (e, { target: t = this.element, detail: i = {}, prefix: s = this.identifier, bubbles: n = !0, cancelable: r = !0 } = {}) { const o = new CustomEvent(s ? `${s}:${e}` : e, { detail: i, bubbles: n, cancelable: r }); return t.dispatchEvent(o), o }}Ml.blessings = [function (e) { return sl(e, 'classes').reduce((e, t) => { return Object.assign(e, { [`${i = t}Class`]: { get () { const { classes: e } = this; if (e.has(i)) return e.get(i); { const t = e.getAttributeName(i); throw new Error(`Missing attribute "${t}"`) } } }, [`${i}Classes`]: { get () { return this.classes.getAll(i) } }, [`has${$c(i)}Class`]: { get () { return this.classes.has(i) } } }); let i }, {}) }, function (e) { return sl(e, 'targets').reduce((e, t) => { return Object.assign(e, { [`${i = t}Target`]: { get () { const e = this.targets.find(i); if (e) return e; throw new Error(`Missing target element "${i}" for "${this.identifier}" controller`) } }, [`${i}Targets`]: { get () { return this.targets.findAll(i) } }, [`has${$c(i)}Target`]: { get () { return this.targets.has(i) } } }); let i }, {}) }, function (e) { const t = nl(e, 'values'); const i = { valueDescriptorMap: { get () { return t.reduce((e, t) => { const i = Al(t, this.identifier); const s = this.data.getAttributeNameForKey(i.key); return Object.assign(e, { [s]: i }) }, {}) } } }; return t.reduce((e, t) => Object.assign(e, (function (e, t) { const i = Al(e, t); const { key: s, name: n, reader: r, writer: o } = i; return { [n]: { get () { const e = this.data.get(s); return e !== null ? r(e) : i.defaultValue }, set (e) { void 0 === e ? this.data.delete(s) : this.data.set(s, o(e)) } }, [`has${$c(n)}`]: { get () { return this.data.has(s) || i.hasCustomDefaultValue } } } }(t))), i) }, function (e) { return sl(e, 'outlets').reduce((e, t) => Object.assign(e, (function (e) { const t = Bc(e); return { [`${t}Outlet`]: { get () { const t = this.outlets.find(e); if (t) { const i = this.application.getControllerForElementAndIdentifier(t, e); if (i) return i; throw new Error(`Missing "data-controller=${e}" attribute on outlet element for "${this.identifier}" controller`) } throw new Error(`Missing outlet element "${e}" for "${this.identifier}" controller`) } }, [`${t}Outlets`]: { get () { const t = this.outlets.findAll(e); return t.length > 0 ? t.map(t => { const i = this.application.getControllerForElementAndIdentifier(t, e); if (i) return i; console.warn(`The provided outlet element is missing the outlet controller "${e}" for "${this.identifier}"`, t) }).filter(e => e) : [] } }, [`${t}OutletElement`]: { get () { const t = this.outlets.find(e); if (t) return t; throw new Error(`Missing outlet element "${e}" for "${this.identifier}" controller`) } }, [`${t}OutletElements`]: { get () { return this.outlets.findAll(e) } }, [`has${$c(t)}Outlet`]: { get () { return this.outlets.has(e) } } } }(t))), {}) }], Ml.targets = [], Ml.outlets = [], Ml.values = {}
/** !
 * hotkeys-js v3.10.1
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
 *
 * Copyright (c) 2022 kenny wong <wowohoo@qq.com>
 * http://jaywcjlove.github.io/hotkeys
 * Licensed under the MIT license
 */
const Pl = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > 0; function xl (e, t, i, s) { e.addEventListener ? e.addEventListener(t, i, s) : e.attachEvent && e.attachEvent('on'.concat(t), function () { i(window.event) }) } function Il (e, t) { for (var i = t.slice(0, t.length - 1), s = 0; s < i.length; s++)i[s] = e[i[s].toLowerCase()]; return i } function Rl (e) { typeof e !== 'string' && (e = ''); for (var t = (e = e.replace(/\s/g, '')).split(','), i = t.lastIndexOf(''); i >= 0;)t[i - 1] += ',', t.splice(i, 1), i = t.lastIndexOf(''); return t } for (var Nl = { backspace: 8, '⌫': 8, tab: 9, clear: 12, enter: 13, '↩': 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, ins: 45, insert: 45, home: 36, end: 35, pageup: 33, pagedown: 34, capslock: 20, num_0: 96, num_1: 97, num_2: 98, num_3: 99, num_4: 100, num_5: 101, num_6: 102, num_7: 103, num_8: 104, num_9: 105, num_multiply: 106, num_add: 107, num_enter: 108, num_subtract: 109, num_decimal: 110, num_divide: 111, '⇪': 20, ',': 188, '.': 190, '/': 191, '`': 192, '-': Pl ? 173 : 189, '=': Pl ? 61 : 187, ';': Pl ? 59 : 186, "'": 222, '[': 219, ']': 221, '\\': 220 }, Fl = { '⇧': 16, shift: 16, '⌥': 18, alt: 18, option: 18, '⌃': 17, ctrl: 17, control: 17, '⌘': 91, cmd: 91, command: 91 }, Dl = { 16: 'shiftKey', 18: 'altKey', 17: 'ctrlKey', 91: 'metaKey', shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 }, Bl = { 16: !1, 18: !1, 17: !1, 91: !1 }, $l = {}, jl = 1; jl < 20; jl++)Nl['f'.concat(jl)] = 111 + jl; let Hl = []; let ql = !1; let Vl = 'all'; const Wl = []; const Kl = function (e) { return Nl[e.toLowerCase()] || Fl[e.toLowerCase()] || e.toUpperCase().charCodeAt(0) }; function zl (e) { Vl = e || 'all' } function Ul () { return Vl || 'all' } const Gl = function (e) { const t = e.key; let i = e.scope; const s = e.method; const n = e.splitKey; const r = void 0 === n ? '+' : n; Rl(t).forEach(function (e) { const t = e.split(r); const n = t.length; const o = t[n - 1]; const a = o === '*' ? '*' : Kl(o); if ($l[a]) { i || (i = Ul()); const c = n > 1 ? Il(Fl, t) : []; $l[a] = $l[a].filter(function (e) { return !((!s || e.method === s) && e.scope === i && (function (e, t) { for (var i = e.length >= t.length ? e : t, s = e.length >= t.length ? t : e, n = !0, r = 0; r < i.length; r++)s.indexOf(i[r]) === -1 && (n = !1); return n }(e.mods, c))) }) } }) }; function Xl (e, t, i, s) { let n; if (t.element === s && (t.scope === i || t.scope === 'all')) { for (const r in n = t.mods.length > 0, Bl)Object.prototype.hasOwnProperty.call(Bl, r) && (!Bl[r] && t.mods.indexOf(+r) > -1 || Bl[r] && t.mods.indexOf(+r) === -1) && (n = !1); (t.mods.length !== 0 || Bl[16] || Bl[18] || Bl[17] || Bl[91]) && !n && t.shortcut !== '*' || !1 === t.method(e, t) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation && e.stopPropagation(), e.cancelBubble && (e.cancelBubble = !0)) } } function Ql (e, t) { const i = $l['*']; let s = e.keyCode || e.which || e.charCode; if (Yl.filter.call(this, e)) { if (s !== 93 && s !== 224 || (s = 91), Hl.indexOf(s) === -1 && s !== 229 && Hl.push(s), ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (t) { const i = Dl[t]; e[t] && Hl.indexOf(i) === -1 ? Hl.push(i) : !e[t] && Hl.indexOf(i) > -1 ? Hl.splice(Hl.indexOf(i), 1) : t === 'metaKey' && e[t] && Hl.length === 3 && (e.ctrlKey || e.shiftKey || e.altKey || (Hl = Hl.slice(Hl.indexOf(i)))) }), s in Bl) { for (const n in Bl[s] = !0, Fl)Fl[n] === s && (Yl[n] = !0); if (!i) return } for (const r in Bl)Object.prototype.hasOwnProperty.call(Bl, r) && (Bl[r] = e[Dl[r]]); e.getModifierState && (!e.altKey || e.ctrlKey) && e.getModifierState('AltGraph') && (Hl.indexOf(17) === -1 && Hl.push(17), Hl.indexOf(18) === -1 && Hl.push(18), Bl[17] = !0, Bl[18] = !0); const o = Ul(); if (i) for (let a = 0; a < i.length; a++)i[a].scope === o && (e.type === 'keydown' && i[a].keydown || e.type === 'keyup' && i[a].keyup) && Xl(e, i[a], o, t); if (s in $l) for (let c = 0; c < $l[s].length; c++) if ((e.type === 'keydown' && $l[s][c].keydown || e.type === 'keyup' && $l[s][c].keyup) && $l[s][c].key) { for (var l = $l[s][c], h = l.splitKey, d = l.key.split(h), u = [], m = 0; m < d.length; m++)u.push(Kl(d[m])); u.sort().join('') === Hl.sort().join('') && Xl(e, l, o, t) } } } function Yl (e, t, i) { Hl = []; const s = Rl(e); let n = []; let r = 'all'; let o = document; let a = 0; let c = !1; let l = !0; let h = '+'; let d = !1; for (void 0 === i && typeof t === 'function' && (i = t), Object.prototype.toString.call(t) === '[object Object]' && (t.scope && (r = t.scope), t.element && (o = t.element), t.keyup && (c = t.keyup), void 0 !== t.keydown && (l = t.keydown), void 0 !== t.capture && (d = t.capture), typeof t.splitKey === 'string' && (h = t.splitKey)), typeof t === 'string' && (r = t); a < s.length; a++)n = [], (e = s[a].split(h)).length > 1 && (n = Il(Fl, e)), (e = (e = e[e.length - 1]) === '*' ? '*' : Kl(e)) in $l || ($l[e] = []), $l[e].push({ keyup: c, keydown: l, scope: r, mods: n, shortcut: s[a], method: i, key: s[a], splitKey: h, element: o }); void 0 !== o && !(function (e) { return Wl.indexOf(e) > -1 }(o)) && window && (Wl.push(o), xl(o, 'keydown', function (e) { Ql(e, o) }, d), ql || (ql = !0, xl(window, 'focus', function () { Hl = [] }, d)), xl(o, 'keyup', function (e) { Ql(e, o), (function (e) { let t = e.keyCode || e.which || e.charCode; const i = Hl.indexOf(t); if (i >= 0 && Hl.splice(i, 1), e.key && e.key.toLowerCase() === 'meta' && Hl.splice(0, Hl.length), t !== 93 && t !== 224 || (t = 91), t in Bl) for (const s in Bl[t] = !1, Fl)Fl[s] === t && (Yl[s] = !1) }(e)) }, d)) } const Jl = { getPressedKeyString: function () { return Hl.map(function (e) { return t = e, Object.keys(Nl).find(function (e) { return Nl[e] === t }) || (function (e) { return Object.keys(Fl).find(function (t) { return Fl[t] === e }) }(e)) || String.fromCharCode(e); let t }) }, setScope: zl, getScope: Ul, deleteScope: function (e, t) { let i, s; for (const n in e || (e = Ul()), $l) if (Object.prototype.hasOwnProperty.call($l, n)) for (i = $l[n], s = 0; s < i.length;)i[s].scope === e ? i.splice(s, 1) : s++; Ul() === e && zl(t || 'all') }, getPressedKeyCodes: function () { return Hl.slice(0) }, isPressed: function (e) { return typeof e === 'string' && (e = Kl(e)), Hl.indexOf(e) !== -1 }, filter: function (e) { const t = e.target || e.srcElement; const i = t.tagName; let s = !0; return !t.isContentEditable && (i !== 'INPUT' && i !== 'TEXTAREA' && i !== 'SELECT' || t.readOnly) || (s = !1), s }, trigger: function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'all'; Object.keys($l).forEach(function (i) { $l[i].filter(function (i) { return i.scope === t && i.shortcut === e }).forEach(function (e) { e && e.method && e.method() }) }) }, unbind: function (e) { if (void 0 === e)Object.keys($l).forEach(function (e) { return delete $l[e] }); else if (Array.isArray(e))e.forEach(function (e) { e.key && Gl(e) }); else if (typeof e === 'object')e.key && Gl(e); else if (typeof e === 'string') { for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)i[s - 1] = arguments[s]; let n = i[0]; let r = i[1]; typeof n === 'function' && (r = n, n = ''), Gl({ key: e, scope: n, method: r, splitKey: '+' }) } }, keyMap: Nl, modifier: Fl, modifierMap: Dl }; for (const Zl in Jl)Object.prototype.hasOwnProperty.call(Jl, Zl) && (Yl[Zl] = Jl[Zl]); if (typeof window !== 'undefined') { const eh = window.hotkeys; Yl.noConflict = function (e) { return e && window.hotkeys === Yl && (window.hotkeys = eh), Yl }, window.hotkeys = Yl }(class extends Ml {}).debounces = []; const th = (e, t = 200) => { let i = null; return function () { const s = arguments; const n = this; const r = () => e.apply(n, s); i && clearTimeout(i), i = setTimeout(r, t) } }; const ih = (e, t) => { const i = e; i.constructor.debounces.forEach(e => { if (typeof e === 'string' && (i[e] = th(i[e], t == null ? void 0 : t.wait)), typeof e === 'object') { const { name: s, wait: n } = e; if (!s) return; i[s] = th(i[s], n || (t == null ? void 0 : t.wait)) } }) }; (class extends Ml {}).throttles = []; window.Stimulus = class {constructor (e = document.documentElement, t = _l) { this.logger = console, this.debug = !1, this.logDebugActivity = (e, t, i = {}) => { this.debug && this.logFormattedMessage(e, t, i) }, this.element = e, this.schema = t, this.dispatcher = new Ic(this), this.router = new wl(this), this.actionDescriptorFilters = Object.assign({}, Rc) } static start (e, t) { const i = new this(e, t); return i.start(), i } async start () { await new Promise(e => { document.readyState == 'loading' ? document.addEventListener('DOMContentLoaded', () => e()) : e() }), this.logDebugActivity('application', 'starting'), this.dispatcher.start(), this.router.start(), this.logDebugActivity('application', 'start') }stop () { this.logDebugActivity('application', 'stopping'), this.dispatcher.stop(), this.router.stop(), this.logDebugActivity('application', 'stop') }register (e, t) { this.load({ identifier: e, controllerConstructor: t }) }registerActionOption (e, t) { this.actionDescriptorFilters[e] = t }load (e, ...t) { (Array.isArray(e) ? e : [e, ...t]).forEach(e => { e.controllerConstructor.shouldLoad && this.router.loadDefinition(e) }) }unload (e, ...t) { (Array.isArray(e) ? e : [e, ...t]).forEach(e => this.router.unloadIdentifier(e)) } get controllers () { return this.router.contexts.map(e => e.controller) }getControllerForElementAndIdentifier (e, t) { const i = this.router.getContextForElementAndIdentifier(e, t); return i ? i.controller : null }handleError (e, t, i) { let s; this.logger.error('%s\n\n%o\n\n%o', t, e, i), (s = window.onerror) === null || void 0 === s || s.call(window, t, '', 0, 0, e) }logFormattedMessage (e, t, i = {}) { i = Object.assign({ application: this }, i), this.logger.groupCollapsed(`${e} #${t}`), this.logger.log('details:', Object.assign({}, i)), this.logger.groupEnd() }}.start(), Stimulus.register('bs-instance', class extends Ml {static values = { class: String, connection: String, method: String }; connect () { if (this.hasConnectionValue) { const e = bootstrap[this.classValue].getOrCreateInstance(this.element); if (e == null) return; e[this.connectionValue]() } }manipulate () { const e = bootstrap[this.classValue].getInstance(this.element); e != null && e[this.methodValue]() }}), Stimulus.register('form', class extends Ml {static targets = ['submitButton', 'radioButton', 'optionTypeContainer']; static values = { delay: { default: 0, type: Number } }; static debounces = [{ name: 'submitViaClick' }]; initialize () { this.submitViaClick = this.submitViaClick.bind(this) }connect () { ih(this, { wait: this.delayValue }), this.hasSubmitButtonTarget && (this.submitButtonTarget.style.display = 'none') }submitViaClick (e) { this.submitButtonTarget.click() }submitWithNearestSubmitButton (e) { this.submitButtonTarget.click() }removeSelection (e) { this.radioButtonTargets.forEach(t => { t.dataset.radioIndexValue >= e.target.dataset.radioIndexValue && (t.checked = !1) }) }resetRadiosWithHigherIndex (e) { this.radioButtonTargets.forEach(t => { t.dataset.radioIndexValue > e.target.dataset.radioIndexValue && (t.checked = !1, t.disabled = !0) }) }optionContainterCheck (e) { this.optionTypeContainerTargets.forEach(e => { if (e.querySelector('input[type="radio"]:checked')) { const t = e.querySelector('.reset-selection'); t && (t.style.display = 'block') } }) }}), Stimulus.register('modal', class extends Ml {connect () { if (document.documentElement.hasAttribute('data-turbo-preview')) { const e = document.querySelector('.modal-backdrop'); e && e.remove() } else this.modal = new bootstrap.Modal(this.element, { keyboard: !1 }), this.modal.show() }disconnect () { this.modal && this.modal.dispose() }submitEnd (e) { !0 !== e.detail.formSubmission.submitter.formNoValidate && e.detail.success && this.modal.hide() }}), Stimulus.register('micro-form', class extends Ml {static targets = ['submitButton', 'radioButton', 'optionTypeContainer']; static values = { delay: { default: 0, type: Number } }; static debounces = [{ name: 'submitViaClick' }]; initialize () { this.submitViaClick = this.submitViaClick.bind(this) }connect () { ih(this, { wait: this.delayValue }), this.hasSubmitButtonTarget && (this.submitButtonTarget.style.display = 'none') }submitViaClick (e) { this.submitButtonTarget.click() }}); const sh = {}; window.AypexStorefront || (window.AypexStorefront = sh); const nh = function (e) { const t = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : ''); const i = window.location.search; return `${t + window.AypexStorefront.paths.platform_api_mounted_at + e + i}` }; sh.localizedPathFor = function (e) { const t = this.localization.default_locale; const i = this.localization.current_locale; const s = this.localization.default_currency; const n = this.localization.current_currency; if (t !== i || s !== n) { const t = new URL(nh(e)); const s = t.searchParams; const r = t.pathname; return s.set('locale', i), s.set('currency', n), t.origin + r + '?' + s.toString() } return nh(e) }, console.log('Aypex Storefront Initialized'); const rh = { logger: self.console, WebSocket: self.WebSocket }; const oh = { log (...e) { this.enabled && (e.push(Date.now()), rh.logger.log('[ActionCable]', ...e)) } }; const ah = () => (new Date()).getTime(); const ch = e => (ah() - e) / 1e3; class lh {constructor (e) { this.visibilityDidChange = this.visibilityDidChange.bind(this), this.connection = e, this.reconnectAttempts = 0 }start () { this.isRunning() || (this.startedAt = ah(), delete this.stoppedAt, this.startPolling(), addEventListener('visibilitychange', this.visibilityDidChange), oh.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`)) }stop () { this.isRunning() && (this.stoppedAt = ah(), this.stopPolling(), removeEventListener('visibilitychange', this.visibilityDidChange), oh.log('ConnectionMonitor stopped')) }isRunning () { return this.startedAt && !this.stoppedAt }recordPing () { this.pingedAt = ah() }recordConnect () { this.reconnectAttempts = 0, this.recordPing(), delete this.disconnectedAt, oh.log('ConnectionMonitor recorded connect') }recordDisconnect () { this.disconnectedAt = ah(), oh.log('ConnectionMonitor recorded disconnect') }startPolling () { this.stopPolling(), this.poll() }stopPolling () { clearTimeout(this.pollTimeout) }poll () { this.pollTimeout = setTimeout(() => { this.reconnectIfStale(), this.poll() }, this.getPollInterval()) }getPollInterval () { const { staleThreshold: e, reconnectionBackoffRate: t } = this.constructor; return 1e3 * e * Math.pow(1 + t, Math.min(this.reconnectAttempts, 10)) * (1 + (this.reconnectAttempts === 0 ? 1 : t) * Math.random()) }reconnectIfStale () { this.connectionIsStale() && (oh.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${ch(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`), this.reconnectAttempts++, this.disconnectedRecently() ? oh.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${ch(this.disconnectedAt)} s`) : (oh.log('ConnectionMonitor reopening'), this.connection.reopen())) } get refreshedAt () { return this.pingedAt ? this.pingedAt : this.startedAt }connectionIsStale () { return ch(this.refreshedAt) > this.constructor.staleThreshold }disconnectedRecently () { return this.disconnectedAt && ch(this.disconnectedAt) < this.constructor.staleThreshold }visibilityDidChange () { document.visibilityState === 'visible' && setTimeout(() => { !this.connectionIsStale() && this.connection.isOpen() || (oh.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`), this.connection.reopen()) }, 200) }}lh.staleThreshold = 6, lh.reconnectionBackoffRate = 0.15; const hh = lh; const dh = { message_types: { welcome: 'welcome', disconnect: 'disconnect', ping: 'ping', confirmation: 'confirm_subscription', rejection: 'reject_subscription' }, disconnect_reasons: { unauthorized: 'unauthorized', invalid_request: 'invalid_request', server_restart: 'server_restart' }, default_mount_path: '/cable', protocols: ['actioncable-v1-json', 'actioncable-unsupported'] }; const { message_types: uh, protocols: mh } = dh; const ph = mh.slice(0, mh.length - 1); const fh = [].indexOf; class gh {constructor (e) { this.open = this.open.bind(this), this.consumer = e, this.subscriptions = this.consumer.subscriptions, this.monitor = new hh(this), this.disconnected = !0 }send (e) { return !!this.isOpen() && (this.webSocket.send(JSON.stringify(e)), !0) }open () { return this.isActive() ? (oh.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`), !1) : (oh.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${mh}`), this.webSocket && this.uninstallEventHandlers(), this.webSocket = new rh.WebSocket(this.consumer.url, mh), this.installEventHandlers(), this.monitor.start(), !0) }close ({ allowReconnect: e } = { allowReconnect: !0 }) { if (e || this.monitor.stop(), this.isOpen()) return this.webSocket.close() }reopen () { if (oh.log(`Reopening WebSocket, current state is ${this.getState()}`), !this.isActive()) return this.open(); try { return this.close() } catch (e) { oh.log('Failed to reopen WebSocket', e) } finally { oh.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`), setTimeout(this.open, this.constructor.reopenDelay) } }getProtocol () { if (this.webSocket) return this.webSocket.protocol }isOpen () { return this.isState('open') }isActive () { return this.isState('open', 'connecting') }isProtocolSupported () { return fh.call(ph, this.getProtocol()) >= 0 }isState (...e) { return fh.call(e, this.getState()) >= 0 }getState () { if (this.webSocket) for (const e in rh.WebSocket) if (rh.WebSocket[e] === this.webSocket.readyState) return e.toLowerCase(); return null }installEventHandlers () { for (const e in this.events) { const t = this.events[e].bind(this); this.webSocket[`on${e}`] = t } }uninstallEventHandlers () { for (const e in this.events) this.webSocket[`on${e}`] = function () {} }}gh.reopenDelay = 500, gh.prototype.events = { message (e) { if (!this.isProtocolSupported()) return; const { identifier: t, message: i, reason: s, reconnect: n, type: r } = JSON.parse(e.data); switch (r) { case uh.welcome:return this.monitor.recordConnect(), this.subscriptions.reload(); case uh.disconnect:return oh.log(`Disconnecting. Reason: ${s}`), this.close({ allowReconnect: n }); case uh.ping:return this.monitor.recordPing(); case uh.confirmation:return this.subscriptions.confirmSubscription(t), this.subscriptions.notify(t, 'connected'); case uh.rejection:return this.subscriptions.reject(t); default:return this.subscriptions.notify(t, 'received', i) } }, open () { if (oh.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`), this.disconnected = !1, !this.isProtocolSupported()) return oh.log('Protocol is unsupported. Stopping monitor and disconnecting.'), this.close({ allowReconnect: !1 }) }, close (e) { if (oh.log('WebSocket onclose event'), !this.disconnected) return this.disconnected = !0, this.monitor.recordDisconnect(), this.subscriptions.notifyAll('disconnected', { willAttemptReconnect: this.monitor.isRunning() }) }, error () { oh.log('WebSocket onerror event') } }; const bh = gh; class vh {constructor (e, t = {}, i) { this.consumer = e, this.identifier = JSON.stringify(t), (function (e, t) { if (t != null) for (const i in t) { const s = t[i]; e[i] = s } }(this, i)) }perform (e, t = {}) { return t.action = e, this.send(t) }send (e) { return this.consumer.send({ command: 'message', identifier: this.identifier, data: JSON.stringify(e) }) }unsubscribe () { return this.consumer.subscriptions.remove(this) }} const yh = class {constructor (e) { this.subscriptions = e, this.pendingSubscriptions = [] }guarantee (e) { this.pendingSubscriptions.indexOf(e) == -1 ? (oh.log(`SubscriptionGuarantor guaranteeing ${e.identifier}`), this.pendingSubscriptions.push(e)) : oh.log(`SubscriptionGuarantor already guaranteeing ${e.identifier}`), this.startGuaranteeing() }forget (e) { oh.log(`SubscriptionGuarantor forgetting ${e.identifier}`), this.pendingSubscriptions = this.pendingSubscriptions.filter(t => t !== e) }startGuaranteeing () { this.stopGuaranteeing(), this.retrySubscribing() }stopGuaranteeing () { clearTimeout(this.retryTimeout) }retrySubscribing () { this.retryTimeout = setTimeout(() => { this.subscriptions && typeof this.subscriptions.subscribe === 'function' && this.pendingSubscriptions.map(e => { oh.log(`SubscriptionGuarantor resubscribing ${e.identifier}`), this.subscriptions.subscribe(e) }) }, 500) }}; class wh {constructor (e) { this.consumer = e, this.guarantor = new yh(this), this.subscriptions = [] }create (e, t) { const i = typeof e === 'object' ? e : { channel: e }; const s = new vh(this.consumer, i, t); return this.add(s) }add (e) { return this.subscriptions.push(e), this.consumer.ensureActiveConnection(), this.notify(e, 'initialized'), this.subscribe(e), e }remove (e) { return this.forget(e), this.findAll(e.identifier).length || this.sendCommand(e, 'unsubscribe'), e }reject (e) { return this.findAll(e).map(e => (this.forget(e), this.notify(e, 'rejected'), e)) }forget (e) { return this.guarantor.forget(e), this.subscriptions = this.subscriptions.filter(t => t !== e), e }findAll (e) { return this.subscriptions.filter(t => t.identifier === e) }reload () { return this.subscriptions.map(e => this.subscribe(e)) }notifyAll (e, ...t) { return this.subscriptions.map(i => this.notify(i, e, ...t)) }notify (e, t, ...i) { let s; return s = typeof e === 'string' ? this.findAll(e) : [e], s.map(e => typeof e[t] === 'function' ? e[t](...i) : void 0) }subscribe (e) { this.sendCommand(e, 'subscribe') && this.guarantor.guarantee(e) }confirmSubscription (e) { oh.log(`Subscription confirmed ${e}`), this.findAll(e).map(e => this.guarantor.forget(e)) }sendCommand (e, t) { const { identifier: i } = e; return this.consumer.send({ command: t, identifier: i }) }} class _h {constructor (e) { this._url = e, this.subscriptions = new wh(this), this.connection = new bh(this) } get url () { return Eh(this._url) }send (e) { return this.connection.send(e) }connect () { return this.connection.open() }disconnect () { return this.connection.close({ allowReconnect: !1 }) }ensureActiveConnection () { if (!this.connection.isActive()) return this.connection.open() }} function Eh (e) { if (typeof e === 'function' && (e = e()), e && !/^wss?:/i.test(e)) { const t = document.createElement('a'); return t.href = e, t.href = t.href, t.protocol = t.protocol.replace('http', 'ws'), t.href } return e } function Ah (e) { const t = document.head.querySelector(`meta[name='action-cable-${e}']`); if (t) return t.getAttribute('content') } var Sh = Object.freeze({ __proto__: null, Connection: bh, ConnectionMonitor: hh, Consumer: _h, INTERNAL: dh, Subscription: vh, Subscriptions: wh, SubscriptionGuarantor: yh, adapters: rh, createWebSocketURL: Eh, logger: oh, createConsumer: function (e = Ah('url') || dh.default_mount_path) { return new _h(e) }, getConfig: Ah })
// # sourceMappingURL=aypex_froentend.min.js.map
