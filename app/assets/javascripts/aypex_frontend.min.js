!(function () { if (void 0 === window.Reflect || void 0 === window.customElements || window.customElements.polyfillWrapFlushCallback) return; const e = HTMLElement; const t = function () { return Reflect.construct(e, [], this.constructor) }; window.HTMLElement = t, HTMLElement.prototype = e.prototype, HTMLElement.prototype.constructor = HTMLElement, Object.setPrototypeOf(HTMLElement, e) }()), (function (e) { function t (e, t, i) { throw new e("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + t + '.', i) } typeof e.requestSubmit !== 'function' && (e.requestSubmit = function (e) { e ? (!(function (e, i) { e instanceof HTMLElement || t(TypeError, "parameter 1 is not of type 'HTMLElement'"), e.type == 'submit' || t(TypeError, 'The specified element is not a submit button'), e.form == i || t(DOMException, 'The specified element is not owned by this form element', 'NotFoundError') }(e, this)), e.click()) : ((e = document.createElement('input')).type = 'submit', e.hidden = !0, this.appendChild(e), e.click(), this.removeChild(e)) }) }(HTMLFormElement.prototype)); const e = new WeakMap(); function t (t) { const i = (function (e) { const t = e instanceof Element ? e : e instanceof Node ? e.parentElement : null; const i = t ? t.closest('input, button') : null; return (i == null ? void 0 : i.type) == 'submit' ? i : null }(t.target)); i && i.form && e.set(i.form, i) } let i, s, n, r, o, a; !(function () { if ('submitter' in Event.prototype) return; let i; if ('SubmitEvent' in window && /Apple Computer/.test(navigator.vendor))i = window.SubmitEvent.prototype; else { if ('SubmitEvent' in window) return; i = window.Event.prototype }addEventListener('click', t, !0), Object.defineProperty(i, 'submitter', { get () { if (this.type == 'submit' && this.target instanceof HTMLFormElement) return e.get(this.target) } }) }()), (function (e) { e.eager = 'eager', e.lazy = 'lazy' }(i || (i = {}))); class c extends HTMLElement {constructor () { super(), this.loaded = Promise.resolve(), this.delegate = new c.delegateConstructor(this) } static get observedAttributes () { return ['disabled', 'complete', 'loading', 'src'] }connectedCallback () { this.delegate.connect() }disconnectedCallback () { this.delegate.disconnect() }reload () { return this.delegate.sourceURLReloaded() }attributeChangedCallback (e) { e == 'loading' ? this.delegate.loadingStyleChanged() : e == 'complete' ? this.delegate.completeChanged() : e == 'src' ? this.delegate.sourceURLChanged() : this.delegate.disabledChanged() } get src () { return this.getAttribute('src') } set src (e) { e ? this.setAttribute('src', e) : this.removeAttribute('src') } get loading () { return (function (e) { if (e.toLowerCase() === 'lazy') return i.lazy; return i.eager }(this.getAttribute('loading') || '')) } set loading (e) { e ? this.setAttribute('loading', e) : this.removeAttribute('loading') } get disabled () { return this.hasAttribute('disabled') } set disabled (e) { e ? this.setAttribute('disabled', '') : this.removeAttribute('disabled') } get autoscroll () { return this.hasAttribute('autoscroll') } set autoscroll (e) { e ? this.setAttribute('autoscroll', '') : this.removeAttribute('autoscroll') } get complete () { return !this.delegate.isLoading } get isActive () { return this.ownerDocument === document && !this.isPreview } get isPreview () { let e, t; return (t = (e = this.ownerDocument) === null || void 0 === e ? void 0 : e.documentElement) === null || void 0 === t ? void 0 : t.hasAttribute('data-turbo-preview') }} function l (e) { return new URL(e.toString(), document.baseURI) } function h (e) { let t; return e.hash ? e.hash.slice(1) : (t = e.href.match(/#(.*)$/)) ? t[1] : void 0 } function d (e, t) { return l((t == null ? void 0 : t.getAttribute('formaction')) || e.getAttribute('action') || e.action) } function u (e) { return ((function (e) { return (function (e) { return e.pathname.split('/').slice(1) }(e)).slice(-1)[0] }(e)).match(/\.[^.]*$/) || [])[0] || '' } function p (e, t) { const i = (function (e) { return t = e.origin + e.pathname, t.endsWith('/') ? t : t + '/'; let t }(t)); return e.href === l(i).href || e.href.startsWith(i) } function m (e, t) { return p(e, t) && !!u(e).match(/^(?:|\.(?:htm|html|xhtml|php))$/) } function f (e) { const t = h(e); return t != null ? e.href.slice(0, -(t.length + 1)) : e.href } function g (e) { return f(e) } class b {constructor (e) { this.response = e } get succeeded () { return this.response.ok } get failed () { return !this.succeeded } get clientError () { return this.statusCode >= 400 && this.statusCode <= 499 } get serverError () { return this.statusCode >= 500 && this.statusCode <= 599 } get redirected () { return this.response.redirected } get location () { return l(this.response.url) } get isHTML () { return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/) } get statusCode () { return this.response.status } get contentType () { return this.header('Content-Type') } get responseText () { return this.response.clone().text() } get responseHTML () { return this.isHTML ? this.response.clone().text() : Promise.resolve(void 0) }header (e) { return this.response.headers.get(e) }} function v (e) { return e == 'advance' || e == 'replace' || e == 'restore' } function y (e) { if (e.getAttribute('data-turbo-eval') == 'false') return e; { const t = document.createElement('script'); const i = M('csp-nonce'); return i && (t.nonce = i), t.textContent = e.textContent, t.async = !1, (function (e, t) { for (const { name: i, value: s } of t.attributes)e.setAttribute(i, s) }(t, e)), t } } function w (e, { target: t, cancelable: i, detail: s } = {}) { const n = new CustomEvent(e, { cancelable: i, bubbles: !0, detail: s }); return t && t.isConnected ? t.dispatchEvent(n) : document.documentElement.dispatchEvent(n), n } function _ () { return new Promise(e => requestAnimationFrame(() => e())) } function E (e = '') { return (new DOMParser()).parseFromString(e, 'text/html') } function S (e, ...t) { const i = (function (e, t) { return e.reduce((e, i, s) => e + i + (t[s] == null ? '' : t[s]), '') }(e, t)).replace(/^\n/, '').split('\n'); const s = i[0].match(/^\s+/); const n = s ? s[0].length : 0; return i.map(e => e.slice(n)).join('\n') } function A () { return Array.from({ length: 36 }).map((e, t) => t == 8 || t == 13 || t == 18 || t == 23 ? '-' : t == 14 ? '4' : t == 19 ? (Math.floor(4 * Math.random()) + 8).toString(16) : Math.floor(15 * Math.random()).toString(16)).join('') } function C (e, ...t) { for (const i of t.map(t => t == null ? void 0 : t.getAttribute(e))) if (typeof i === 'string') return i; return null } function k (...e) { for (const t of e)t.localName == 'turbo-frame' && t.setAttribute('busy', ''), t.setAttribute('aria-busy', 'true') } function T (...e) { for (const t of e)t.localName == 'turbo-frame' && t.removeAttribute('busy'), t.removeAttribute('aria-busy') } function L (e, t = 2e3) { return new Promise(i => { const s = () => { e.removeEventListener('error', s), e.removeEventListener('load', s), i() }; e.addEventListener('load', s, { once: !0 }), e.addEventListener('error', s, { once: !0 }), setTimeout(i, t) }) } function O (e) { switch (e) { case 'replace':return history.replaceState; case 'advance':case 'restore':return history.pushState } } function P (e) { return document.querySelector(`meta[name="${e}"]`) } function M (e) { const t = P(e); return t && t.content }!(function (e) { e[e.get = 0] = 'get', e[e.post = 1] = 'post', e[e.put = 2] = 'put', e[e.patch = 3] = 'patch', e[e.delete = 4] = 'delete' }(s || (s = {}))); class x {constructor (e, t, i, s = new URLSearchParams(), n = null) { this.abortController = new AbortController(), this.resolveRequestPromise = e => {}, this.delegate = e, this.method = t, this.headers = this.defaultHeaders, this.body = s, this.url = i, this.target = n } get location () { return this.url } get params () { return this.url.searchParams } get entries () { return this.body ? Array.from(this.body.entries()) : [] }cancel () { this.abortController.abort() } async perform () { let e, t; const { fetchOptions: i } = this; (t = (e = this.delegate).prepareHeadersForRequest) === null || void 0 === t || t.call(e, this.headers, this), await this.allowRequestToBeIntercepted(i); try { this.delegate.requestStarted(this); const e = await fetch(this.url.href, i); return await this.receive(e) } catch (e) { if (e.name !== 'AbortError') throw this.willDelegateErrorHandling(e) && this.delegate.requestErrored(this, e), e } finally { this.delegate.requestFinished(this) } } async receive (e) { const t = new b(e); return w('turbo:before-fetch-response', { cancelable: !0, detail: { fetchResponse: t }, target: this.target }).defaultPrevented ? this.delegate.requestPreventedHandlingResponse(this, t) : t.succeeded ? this.delegate.requestSucceededWithResponse(this, t) : this.delegate.requestFailedWithResponse(this, t), t } get fetchOptions () { let e; return { method: s[this.method].toUpperCase(), credentials: 'same-origin', headers: this.headers, redirect: 'follow', body: this.isIdempotent ? null : this.body, signal: this.abortSignal, referrer: (e = this.delegate.referrer) === null || void 0 === e ? void 0 : e.href } } get defaultHeaders () { return { Accept: 'text/html, application/xhtml+xml' } } get isIdempotent () { return this.method == s.get } get abortSignal () { return this.abortController.signal }acceptResponseType (e) { this.headers.Accept = [e, this.headers.Accept].join(', ') } async allowRequestToBeIntercepted (e) { const t = new Promise(e => this.resolveRequestPromise = e); w('turbo:before-fetch-request', { cancelable: !0, detail: { fetchOptions: e, url: this.url, resume: this.resolveRequestPromise }, target: this.target }).defaultPrevented && await t }willDelegateErrorHandling (e) { return !w('turbo:fetch-request-error', { target: this.target, cancelable: !0, detail: { request: this, error: e } }).defaultPrevented }} class I {constructor (e, t) { this.started = !1, this.intersect = e => { const t = e.slice(-1)[0]; (t == null ? void 0 : t.isIntersecting) && this.delegate.elementAppearedInViewport(this.element) }, this.delegate = e, this.element = t, this.intersectionObserver = new IntersectionObserver(this.intersect) }start () { this.started || (this.started = !0, this.intersectionObserver.observe(this.element)) }stop () { this.started && (this.started = !1, this.intersectionObserver.unobserve(this.element)) }} class R {constructor (e) { this.fragment = (function (e) { for (const t of e.querySelectorAll('turbo-stream')) { const e = document.importNode(t, !0); for (const t of e.templateElement.content.querySelectorAll('script'))t.replaceWith(y(t)); t.replaceWith(e) } return e }(e)) } static wrap (e) { return typeof e === 'string' ? new this(function (e) { const t = document.createElement('template'); return t.innerHTML = e, t.content }(e)) : e }}R.contentType = 'text/vnd.turbo-stream.html', (function (e) { e[e.initialized = 0] = 'initialized', e[e.requesting = 1] = 'requesting', e[e.waiting = 2] = 'waiting', e[e.receiving = 3] = 'receiving', e[e.stopping = 4] = 'stopping', e[e.stopped = 5] = 'stopped' }(n || (n = {}))), (function (e) { e.urlEncoded = 'application/x-www-form-urlencoded', e.multipart = 'multipart/form-data', e.plain = 'text/plain' }(r || (r = {}))); class N {constructor (e, t, i, r = !1) { this.state = n.initialized, this.delegate = e, this.formElement = t, this.submitter = i, this.formData = (function (e, t) { const i = new FormData(e); const s = t == null ? void 0 : t.getAttribute('name'); const n = t == null ? void 0 : t.getAttribute('value'); s && i.append(s, n || ''); return i }(t, i)), this.location = l(this.action), this.method == s.get && (function (e, t) { const i = new URLSearchParams(); for (const [e, s] of t)s instanceof File || i.append(e, s); e.search = i.toString() }(this.location, [...this.body.entries()])), this.fetchRequest = new x(this, this.method, this.location, this.body, this.formElement), this.mustRedirect = r } static confirmMethod (e, t, i) { return Promise.resolve(confirm(e)) } get method () { let e; return (function (e) { switch (e.toLowerCase()) { case 'get':return s.get; case 'post':return s.post; case 'put':return s.put; case 'patch':return s.patch; case 'delete':return s.delete } }((((e = this.submitter) === null || void 0 === e ? void 0 : e.getAttribute('formmethod')) || this.formElement.getAttribute('method') || '').toLowerCase())) || s.get } get action () { let e; const t = typeof this.formElement.action === 'string' ? this.formElement.action : null; return ((e = this.submitter) === null || void 0 === e ? void 0 : e.hasAttribute('formaction')) ? this.submitter.getAttribute('formaction') || '' : this.formElement.getAttribute('action') || t || '' } get body () { return this.enctype == r.urlEncoded || this.method == s.get ? new URLSearchParams(this.stringFormData) : this.formData } get enctype () { let e; return (function (e) { switch (e.toLowerCase()) { case r.multipart:return r.multipart; case r.plain:return r.plain; default:return r.urlEncoded } }(((e = this.submitter) === null || void 0 === e ? void 0 : e.getAttribute('formenctype')) || this.formElement.enctype)) } get isIdempotent () { return this.fetchRequest.isIdempotent } get stringFormData () { return [...this.formData].reduce((e, [t, i]) => e.concat(typeof i === 'string' ? [[t, i]] : []), []) } async start () { const { initialized: e, requesting: t } = n; const i = C('data-turbo-confirm', this.submitter, this.formElement); if (typeof i === 'string') { if (!await N.confirmMethod(i, this.formElement, this.submitter)) return } if (this.state == e) return this.state = t, this.fetchRequest.perform() }stop () { const { stopping: e, stopped: t } = n; if (this.state != e && this.state != t) return this.state = e, this.fetchRequest.cancel(), !0 }prepareHeadersForRequest (e, t) { if (!t.isIdempotent) { const t = (function (e) { if (e != null) { const t = (document.cookie ? document.cookie.split('; ') : []).find(t => t.startsWith(e)); if (t) { const e = t.split('=').slice(1).join('='); return e ? decodeURIComponent(e) : void 0 } } }(M('csrf-param'))) || M('csrf-token'); t && (e['X-CSRF-Token'] = t) } this.requestAcceptsTurboStreamResponse(t) && t.acceptResponseType(R.contentType) }requestStarted (e) { let t; this.state = n.waiting, (t = this.submitter) === null || void 0 === t || t.setAttribute('disabled', ''), w('turbo:submit-start', { target: this.formElement, detail: { formSubmission: this } }), this.delegate.formSubmissionStarted(this) }requestPreventedHandlingResponse (e, t) { this.result = { success: t.succeeded, fetchResponse: t } }requestSucceededWithResponse (e, t) { if (t.clientError || t.serverError) this.delegate.formSubmissionFailedWithResponse(this, t); else if (this.requestMustRedirect(e) && (function (e) { return e.statusCode == 200 && !e.redirected }(t))) { const e = new Error('Form responses must redirect to another location'); this.delegate.formSubmissionErrored(this, e) } else this.state = n.receiving, this.result = { success: !0, fetchResponse: t }, this.delegate.formSubmissionSucceededWithResponse(this, t) }requestFailedWithResponse (e, t) { this.result = { success: !1, fetchResponse: t }, this.delegate.formSubmissionFailedWithResponse(this, t) }requestErrored (e, t) { this.result = { success: !1, error: t }, this.delegate.formSubmissionErrored(this, t) }requestFinished (e) { let t; this.state = n.stopped, (t = this.submitter) === null || void 0 === t || t.removeAttribute('disabled'), w('turbo:submit-end', { target: this.formElement, detail: Object.assign({ formSubmission: this }, this.result) }), this.delegate.formSubmissionFinished(this) }requestMustRedirect (e) { return !e.isIdempotent && this.mustRedirect }requestAcceptsTurboStreamResponse (e) { return !e.isIdempotent || (function (e, ...t) { return t.some(t => t && t.hasAttribute(e)) }('data-turbo-stream', this.submitter, this.formElement)) }} class F {constructor (e) { this.element = e } get activeElement () { return this.element.ownerDocument.activeElement } get children () { return [...this.element.children] }hasAnchor (e) { return this.getElementForAnchor(e) != null }getElementForAnchor (e) { return e ? this.element.querySelector(`[id='${e}'], a[name='${e}']`) : null } get isConnected () { return this.element.isConnected } get firstAutofocusableElement () { for (const e of this.element.querySelectorAll('[autofocus]')) if (e.closest('[inert], :disabled, [hidden], details:not([open]), dialog:not([open])') == null) return e; return null } get permanentElements () { return B(this.element) }getPermanentElementById (e) { return D(this.element, e) }getPermanentElementMapForSnapshot (e) { const t = {}; for (const i of this.permanentElements) { const { id: s } = i; const n = e.getPermanentElementById(s); n && (t[s] = [i, n]) } return t }} function D (e, t) { return e.querySelector(`#${t}[data-turbo-permanent]`) } function B (e) { return e.querySelectorAll('[id][data-turbo-permanent]') } class j {constructor (e, t) { this.started = !1, this.submitCaptured = () => { this.eventTarget.removeEventListener('submit', this.submitBubbled, !1), this.eventTarget.addEventListener('submit', this.submitBubbled, !1) }, this.submitBubbled = e => { if (!e.defaultPrevented) { const t = e.target instanceof HTMLFormElement ? e.target : void 0; const i = e.submitter || void 0; t && (function (e, t) { return ((t == null ? void 0 : t.getAttribute('formmethod')) || e.getAttribute('method')) != 'dialog' }(t, i)) && (function (e, t) { const i = (t == null ? void 0 : t.getAttribute('formtarget')) || e.target; for (const e of document.getElementsByName(i)) if (e instanceof HTMLIFrameElement) return !1; return !0 }(t, i)) && this.delegate.willSubmitForm(t, i) && (e.preventDefault(), e.stopImmediatePropagation(), this.delegate.formSubmitted(t, i)) } }, this.delegate = e, this.eventTarget = t }start () { this.started || (this.eventTarget.addEventListener('submit', this.submitCaptured, !0), this.started = !0) }stop () { this.started && (this.eventTarget.removeEventListener('submit', this.submitCaptured, !0), this.started = !1) }} class q {constructor (e, t) { this.resolveRenderPromise = e => {}, this.resolveInterceptionPromise = e => {}, this.delegate = e, this.element = t }scrollToAnchor (e) { const t = this.snapshot.getElementForAnchor(e); t ? (this.scrollToElement(t), this.focusElement(t)) : this.scrollToPosition({ x: 0, y: 0 }) }scrollToAnchorFromLocation (e) { this.scrollToAnchor(h(e)) }scrollToElement (e) { e.scrollIntoView() }focusElement (e) { e instanceof HTMLElement && (e.hasAttribute('tabindex') ? e.focus() : (e.setAttribute('tabindex', '-1'), e.focus(), e.removeAttribute('tabindex'))) }scrollToPosition ({ x: e, y: t }) { this.scrollRoot.scrollTo(e, t) }scrollToTop () { this.scrollToPosition({ x: 0, y: 0 }) } get scrollRoot () { return window } async render (e) { const { isPreview: t, shouldRender: i, newSnapshot: s } = e; if (i) try { this.renderPromise = new Promise(e => this.resolveRenderPromise = e), this.renderer = e, await this.prepareToRenderSnapshot(e); const i = new Promise(e => this.resolveInterceptionPromise = e); const n = { resume: this.resolveInterceptionPromise, render: this.renderer.renderElement }; this.delegate.allowsImmediateRender(s, n) || await i, await this.renderSnapshot(e), this.delegate.viewRenderedSnapshot(s, t), this.delegate.preloadOnLoadLinksForView(this.element), this.finishRenderingSnapshot(e) } finally { delete this.renderer, this.resolveRenderPromise(void 0), delete this.renderPromise } else this.invalidate(e.reloadReason) }invalidate (e) { this.delegate.viewInvalidated(e) } async prepareToRenderSnapshot (e) { this.markAsPreview(e.isPreview), await e.prepareToRender() }markAsPreview (e) { e ? this.element.setAttribute('data-turbo-preview', '') : this.element.removeAttribute('data-turbo-preview') } async renderSnapshot (e) { await e.render() }finishRenderingSnapshot (e) { e.finishRendering() }} class H extends q {invalidate () { this.element.innerHTML = '' } get snapshot () { return new F(this.element) }} class V {constructor (e, t) { this.clickBubbled = e => { this.respondsToEventTarget(e.target) ? this.clickEvent = e : delete this.clickEvent }, this.linkClicked = e => { this.clickEvent && this.respondsToEventTarget(e.target) && e.target instanceof Element && this.delegate.shouldInterceptLinkClick(e.target, e.detail.url, e.detail.originalEvent) && (this.clickEvent.preventDefault(), e.preventDefault(), this.delegate.linkClickIntercepted(e.target, e.detail.url, e.detail.originalEvent)), delete this.clickEvent }, this.willVisit = e => { delete this.clickEvent }, this.delegate = e, this.element = t }start () { this.element.addEventListener('click', this.clickBubbled), document.addEventListener('turbo:click', this.linkClicked), document.addEventListener('turbo:before-visit', this.willVisit) }stop () { this.element.removeEventListener('click', this.clickBubbled), document.removeEventListener('turbo:click', this.linkClicked), document.removeEventListener('turbo:before-visit', this.willVisit) }respondsToEventTarget (e) { const t = e instanceof Element ? e : e instanceof Node ? e.parentElement : null; return t && t.closest('turbo-frame, html') == this.element }} class $ {constructor (e, t) { this.started = !1, this.clickCaptured = () => { this.eventTarget.removeEventListener('click', this.clickBubbled, !1), this.eventTarget.addEventListener('click', this.clickBubbled, !1) }, this.clickBubbled = e => { if (e instanceof MouseEvent && this.clickEventIsSignificant(e)) { const t = e.composedPath && e.composedPath()[0] || e.target; const i = this.findLinkFromClickTarget(t); if (i && (function (e) { for (const t of document.getElementsByName(e.target)) if (t instanceof HTMLIFrameElement) return !1; return !0 }(i))) { const t = this.getLocationForLink(i); this.delegate.willFollowLinkToLocation(i, t, e) && (e.preventDefault(), this.delegate.followedLinkToLocation(i, t)) } } }, this.delegate = e, this.eventTarget = t }start () { this.started || (this.eventTarget.addEventListener('click', this.clickCaptured, !0), this.started = !0) }stop () { this.started && (this.eventTarget.removeEventListener('click', this.clickCaptured, !0), this.started = !1) }clickEventIsSignificant (e) { return !(e.target && e.target.isContentEditable || e.defaultPrevented || e.which > 1 || e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) }findLinkFromClickTarget (e) { if (e instanceof Element) return e.closest('a[href]:not([target^=_]):not([download])') }getLocationForLink (e) { return l(e.getAttribute('href') || '') }} class W {constructor (e, t) { this.delegate = e, this.linkInterceptor = new $(this, t) }start () { this.linkInterceptor.start() }stop () { this.linkInterceptor.stop() }willFollowLinkToLocation (e, t, i) { return this.delegate.willSubmitFormLinkToLocation(e, t, i) && e.hasAttribute('data-turbo-method') }followedLinkToLocation (e, t) { const i = t.href; const s = document.createElement('form'); s.setAttribute('data-turbo', 'true'), s.setAttribute('action', i), s.setAttribute('hidden', ''); const n = e.getAttribute('data-turbo-method'); n && s.setAttribute('method', n); const r = e.getAttribute('data-turbo-frame'); r && s.setAttribute('data-turbo-frame', r); const o = e.getAttribute('data-turbo-action'); o && s.setAttribute('data-turbo-action', o); const a = e.getAttribute('data-turbo-confirm'); a && s.setAttribute('data-turbo-confirm', a); e.hasAttribute('data-turbo-stream') && s.setAttribute('data-turbo-stream', ''), this.delegate.submittedFormLinkToLocation(e, t, s), document.body.appendChild(s), s.addEventListener('turbo:submit-end', () => s.remove(), { once: !0 }), requestAnimationFrame(() => s.requestSubmit()) }} class U {constructor (e, t) { this.delegate = e, this.permanentElementMap = t } static preservingPermanentElements (e, t, i) { const s = new this(e, t); s.enter(), i(), s.leave() }enter () { for (const e in this.permanentElementMap) { const [t, i] = this.permanentElementMap[e]; this.delegate.enteringBardo(t, i), this.replaceNewPermanentElementWithPlaceholder(i) } }leave () { for (const e in this.permanentElementMap) { const [t] = this.permanentElementMap[e]; this.replaceCurrentPermanentElementWithClone(t), this.replacePlaceholderWithPermanentElement(t), this.delegate.leavingBardo(t) } }replaceNewPermanentElementWithPlaceholder (e) { const t = (function (e) { const t = document.createElement('meta'); return t.setAttribute('name', 'turbo-permanent-placeholder'), t.setAttribute('content', e.id), t }(e)); e.replaceWith(t) }replaceCurrentPermanentElementWithClone (e) { const t = e.cloneNode(!0); e.replaceWith(t) }replacePlaceholderWithPermanentElement (e) { const t = this.getPlaceholderById(e.id); t == null || t.replaceWith(e) }getPlaceholderById (e) { return this.placeholders.find(t => t.content == e) } get placeholders () { return [...document.querySelectorAll('meta[name=turbo-permanent-placeholder][content]')] }} class K {constructor (e, t, i, s, n = !0) { this.activeElement = null, this.currentSnapshot = e, this.newSnapshot = t, this.isPreview = s, this.willRender = n, this.renderElement = i, this.promise = new Promise((e, t) => this.resolvingFunctions = { resolve: e, reject: t }) } get shouldRender () { return !0 } get reloadReason () {}prepareToRender () {}finishRendering () { this.resolvingFunctions && (this.resolvingFunctions.resolve(), delete this.resolvingFunctions) }preservingPermanentElements (e) { U.preservingPermanentElements(this, this.permanentElementMap, e) }focusFirstAutofocusableElement () { const e = this.connectedSnapshot.firstAutofocusableElement; (function (e) { return e && typeof e.focus === 'function' })(e) && e.focus() }enteringBardo (e) { this.activeElement || e.contains(this.currentSnapshot.activeElement) && (this.activeElement = this.currentSnapshot.activeElement) }leavingBardo (e) { e.contains(this.activeElement) && this.activeElement instanceof HTMLElement && (this.activeElement.focus(), this.activeElement = null) } get connectedSnapshot () { return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot } get currentElement () { return this.currentSnapshot.element } get newElement () { return this.newSnapshot.element } get permanentElementMap () { return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot) }} class z extends K {constructor (e, t, i, s, n, r = !0) { super(t, i, s, n, r), this.delegate = e } static renderElement (e, t) { let i; const s = document.createRange(); s.selectNodeContents(e), s.deleteContents(); const n = t; const r = (i = n.ownerDocument) === null || void 0 === i ? void 0 : i.createRange(); r && (r.selectNodeContents(n), e.appendChild(r.extractContents())) } get shouldRender () { return !0 } async render () { await _(), this.preservingPermanentElements(() => { this.loadFrameElement() }), this.scrollFrameIntoView(), await _(), this.focusFirstAutofocusableElement(), await _(), this.activateScriptElements() }loadFrameElement () { this.delegate.willRenderFrame(this.currentElement, this.newElement), this.renderElement(this.currentElement, this.newElement) }scrollFrameIntoView () { if (this.currentElement.autoscroll || this.newElement.autoscroll) { const i = this.currentElement.firstElementChild; const s = (e = this.currentElement.getAttribute('data-autoscroll-block'), t = 'end', e == 'end' || e == 'start' || e == 'center' || e == 'nearest' ? e : t); const n = (function (e, t) { return e == 'auto' || e == 'smooth' ? e : t }(this.currentElement.getAttribute('data-autoscroll-behavior'), 'auto')); if (i) return i.scrollIntoView({ block: s, behavior: n }), !0 } let e, t; return !1 }activateScriptElements () { for (const e of this.newScriptElements) { const t = y(e); e.replaceWith(t) } } get newScriptElements () { return this.currentElement.querySelectorAll('script') }} class Q {
  constructor () { this.hiding = !1, this.value = 0, this.visible = !1, this.trickle = () => { this.setValue(this.value + Math.random() / 100) }, this.stylesheetElement = this.createStylesheetElement(), this.progressElement = this.createProgressElement(), this.installStylesheetElement(), this.setValue(0) } static get defaultCSS () {
    return S`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${Q.animationDuration}ms ease-out,
          opacity ${Q.animationDuration / 2}ms ${Q.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `
  }

  show () { this.visible || (this.visible = !0, this.installProgressElement(), this.startTrickling()) }hide () { this.visible && !this.hiding && (this.hiding = !0, this.fadeProgressElement(() => { this.uninstallProgressElement(), this.stopTrickling(), this.visible = !1, this.hiding = !1 })) }setValue (e) { this.value = e, this.refresh() }installStylesheetElement () { document.head.insertBefore(this.stylesheetElement, document.head.firstChild) }installProgressElement () { this.progressElement.style.width = '0', this.progressElement.style.opacity = '1', document.documentElement.insertBefore(this.progressElement, document.body), this.refresh() }fadeProgressElement (e) { this.progressElement.style.opacity = '0', setTimeout(e, 1.5 * Q.animationDuration) }uninstallProgressElement () { this.progressElement.parentNode && document.documentElement.removeChild(this.progressElement) }startTrickling () { this.trickleInterval || (this.trickleInterval = window.setInterval(this.trickle, Q.animationDuration)) }stopTrickling () { window.clearInterval(this.trickleInterval), delete this.trickleInterval }refresh () { requestAnimationFrame(() => { this.progressElement.style.width = 10 + 90 * this.value + '%' }) }createStylesheetElement () { const e = document.createElement('style'); return e.type = 'text/css', e.textContent = Q.defaultCSS, this.cspNonce && (e.nonce = this.cspNonce), e }createProgressElement () { const e = document.createElement('div'); return e.className = 'turbo-progress-bar', e } get cspNonce () { return M('csp-nonce') }
}Q.animationDuration = 300; class G extends F {constructor () { super(...arguments), this.detailsByOuterHTML = this.children.filter(e => !(function (e) { return e.localName == 'noscript' }(e))).map(e => (function (e) { e.hasAttribute('nonce') && e.setAttribute('nonce', ''); return e }(e))).reduce((e, t) => { const { outerHTML: i } = t; const s = i in e ? e[i] : { type: Y(t), tracked: X(t), elements: [] }; return Object.assign(Object.assign({}, e), { [i]: Object.assign(Object.assign({}, s), { elements: [...s.elements, t] }) }) }, {}) } get trackedElementSignature () { return Object.keys(this.detailsByOuterHTML).filter(e => this.detailsByOuterHTML[e].tracked).join('') }getScriptElementsNotInSnapshot (e) { return this.getElementsMatchingTypeNotInSnapshot('script', e) }getStylesheetElementsNotInSnapshot (e) { return this.getElementsMatchingTypeNotInSnapshot('stylesheet', e) }getElementsMatchingTypeNotInSnapshot (e, t) { return Object.keys(this.detailsByOuterHTML).filter(e => !(e in t.detailsByOuterHTML)).map(e => this.detailsByOuterHTML[e]).filter(({ type: t }) => t == e).map(({ elements: [e] }) => e) } get provisionalElements () { return Object.keys(this.detailsByOuterHTML).reduce((e, t) => { const { type: i, tracked: s, elements: n } = this.detailsByOuterHTML[t]; return i != null || s ? n.length > 1 ? [...e, ...n.slice(1)] : e : [...e, ...n] }, []) }getMetaValue (e) { const t = this.findMetaElementByName(e); return t ? t.getAttribute('content') : null }findMetaElementByName (e) { return Object.keys(this.detailsByOuterHTML).reduce((t, i) => { const { elements: [s] } = this.detailsByOuterHTML[i]; return (function (e, t) { return e.localName == 'meta' && e.getAttribute('name') == t }(s, e)) ? s : t }, void 0) }} function Y (e) { return (function (e) { return e.localName == 'script' }(e)) ? 'script' : (function (e) { const t = e.localName; return t == 'style' || t == 'link' && e.getAttribute('rel') == 'stylesheet' }(e)) ? 'stylesheet' : void 0 } function X (e) { return e.getAttribute('data-turbo-track') == 'reload' } class J extends F {constructor (e, t) { super(e), this.headSnapshot = t } static fromHTMLString (e = '') { return this.fromDocument(E(e)) } static fromElement (e) { return this.fromDocument(e.ownerDocument) } static fromDocument ({ head: e, body: t }) { return new this(t, new G(e)) }clone () { const e = this.element.cloneNode(!0); const t = this.element.querySelectorAll('select'); const i = e.querySelectorAll('select'); for (const [e, s] of t.entries()) { const t = i[e]; for (const e of t.selectedOptions)e.selected = !1; for (const e of s.selectedOptions)t.options[e.index].selected = !0 } for (const t of e.querySelectorAll('input[type="password"]'))t.value = ''; return new J(e, this.headSnapshot) } get headElement () { return this.headSnapshot.element } get rootLocation () { let e; return l((e = this.getSetting('root')) !== null && void 0 !== e ? e : '/') } get cacheControlValue () { return this.getSetting('cache-control') } get isPreviewable () { return this.cacheControlValue != 'no-preview' } get isCacheable () { return this.cacheControlValue != 'no-cache' } get isVisitable () { return this.getSetting('visit-control') != 'reload' }getSetting (e) { return this.headSnapshot.getMetaValue(`turbo-${e}`) }}!(function (e) { e.visitStart = 'visitStart', e.requestStart = 'requestStart', e.requestEnd = 'requestEnd', e.visitEnd = 'visitEnd' }(o || (o = {}))), (function (e) { e.initialized = 'initialized', e.started = 'started', e.canceled = 'canceled', e.failed = 'failed', e.completed = 'completed' }(a || (a = {}))); const Z = { action: 'advance', historyChanged: !1, visitCachedSnapshot: () => {}, willRender: !0, updateHistory: !0, shouldCacheSnapshot: !0, acceptsStreamResponse: !1 }; let ee, te; !(function (e) { e[e.networkFailure = 0] = 'networkFailure', e[e.timeoutFailure = -1] = 'timeoutFailure', e[e.contentTypeMismatch = -2] = 'contentTypeMismatch' }(ee || (ee = {}))); class ie {constructor (e, t, i, s = {}) { this.identifier = A(), this.timingMetrics = {}, this.followedRedirect = !1, this.historyChanged = !1, this.scrolled = !1, this.shouldCacheSnapshot = !0, this.acceptsStreamResponse = !1, this.snapshotCached = !1, this.state = a.initialized, this.delegate = e, this.location = t, this.restorationIdentifier = i || A(); const { action: n, historyChanged: r, referrer: o, snapshot: c, snapshotHTML: l, response: h, visitCachedSnapshot: d, willRender: u, updateHistory: p, shouldCacheSnapshot: m, acceptsStreamResponse: f } = Object.assign(Object.assign({}, Z), s); this.action = n, this.historyChanged = r, this.referrer = o, this.snapshot = c, this.snapshotHTML = l, this.response = h, this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action), this.visitCachedSnapshot = d, this.willRender = u, this.updateHistory = p, this.scrolled = !u, this.shouldCacheSnapshot = m, this.acceptsStreamResponse = f } get adapter () { return this.delegate.adapter } get view () { return this.delegate.view } get history () { return this.delegate.history } get restorationData () { return this.history.getRestorationDataForIdentifier(this.restorationIdentifier) } get silent () { return this.isSamePage }start () { this.state == a.initialized && (this.recordTimingMetric(o.visitStart), this.state = a.started, this.adapter.visitStarted(this), this.delegate.visitStarted(this)) }cancel () { this.state == a.started && (this.request && this.request.cancel(), this.cancelRender(), this.state = a.canceled) }complete () { this.state == a.started && (this.recordTimingMetric(o.visitEnd), this.state = a.completed, this.followRedirect(), this.followedRedirect || (this.adapter.visitCompleted(this), this.delegate.visitCompleted(this))) }fail () { this.state == a.started && (this.state = a.failed, this.adapter.visitFailed(this)) }changeHistory () { let e; if (!this.historyChanged && this.updateHistory) { const t = O(this.location.href === ((e = this.referrer) === null || void 0 === e ? void 0 : e.href) ? 'replace' : this.action); this.history.update(t, this.location, this.restorationIdentifier), this.historyChanged = !0 } }issueRequest () { this.hasPreloadedResponse() ? this.simulateRequest() : this.shouldIssueRequest() && !this.request && (this.request = new x(this, s.get, this.location), this.request.perform()) }simulateRequest () { this.response && (this.startRequest(), this.recordResponse(), this.finishRequest()) }startRequest () { this.recordTimingMetric(o.requestStart), this.adapter.visitRequestStarted(this) }recordResponse (e = this.response) { if (this.response = e, e) { const { statusCode: t } = e; se(t) ? this.adapter.visitRequestCompleted(this) : this.adapter.visitRequestFailedWithStatusCode(this, t) } }finishRequest () { this.recordTimingMetric(o.requestEnd), this.adapter.visitRequestFinished(this) }loadResponse () { if (this.response) { const { statusCode: e, responseHTML: t } = this.response; this.render(async () => { this.shouldCacheSnapshot && this.cacheSnapshot(), this.view.renderPromise && await this.view.renderPromise, se(e) && t != null ? (await this.view.renderPage(J.fromHTMLString(t), !1, this.willRender, this), this.performScroll(), this.adapter.visitRendered(this), this.complete()) : (await this.view.renderError(J.fromHTMLString(t), this), this.adapter.visitRendered(this), this.fail()) }) } }getCachedSnapshot () { const e = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot(); if (e && (!h(this.location) || e.hasAnchor(h(this.location))) && (this.action == 'restore' || e.isPreviewable)) return e }getPreloadedSnapshot () { if (this.snapshotHTML) return J.fromHTMLString(this.snapshotHTML) }hasCachedSnapshot () { return this.getCachedSnapshot() != null }loadCachedSnapshot () { const e = this.getCachedSnapshot(); if (e) { const t = this.shouldIssueRequest(); this.render(async () => { this.cacheSnapshot(), this.isSamePage ? this.adapter.visitRendered(this) : (this.view.renderPromise && await this.view.renderPromise, await this.view.renderPage(e, t, this.willRender, this), this.performScroll(), this.adapter.visitRendered(this), t || this.complete()) }) } }followRedirect () { let e; this.redirectedToLocation && !this.followedRedirect && ((e = this.response) === null || void 0 === e ? void 0 : e.redirected) && (this.adapter.visitProposedToLocation(this.redirectedToLocation, { action: 'replace', response: this.response }), this.followedRedirect = !0) }goToSamePageAnchor () { this.isSamePage && this.render(async () => { this.cacheSnapshot(), this.performScroll(), this.changeHistory(), this.adapter.visitRendered(this) }) }prepareHeadersForRequest (e, t) { this.acceptsStreamResponse && t.acceptResponseType(R.contentType) }requestStarted () { this.startRequest() }requestPreventedHandlingResponse (e, t) {} async requestSucceededWithResponse (e, t) { const i = await t.responseHTML; const { redirected: s, statusCode: n } = t; i == null ? this.recordResponse({ statusCode: ee.contentTypeMismatch, redirected: s }) : (this.redirectedToLocation = t.redirected ? t.location : void 0, this.recordResponse({ statusCode: n, responseHTML: i, redirected: s })) } async requestFailedWithResponse (e, t) { const i = await t.responseHTML; const { redirected: s, statusCode: n } = t; i == null ? this.recordResponse({ statusCode: ee.contentTypeMismatch, redirected: s }) : this.recordResponse({ statusCode: n, responseHTML: i, redirected: s }) }requestErrored (e, t) { this.recordResponse({ statusCode: ee.networkFailure, redirected: !1 }) }requestFinished () { this.finishRequest() }performScroll () { this.scrolled || this.view.forceReloaded || (this.action == 'restore' ? this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop() : this.scrollToAnchor() || this.view.scrollToTop(), this.isSamePage && this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location), this.scrolled = !0) }scrollToRestoredPosition () { const { scrollPosition: e } = this.restorationData; if (e) return this.view.scrollToPosition(e), !0 }scrollToAnchor () { const e = h(this.location); if (e != null) return this.view.scrollToAnchor(e), !0 }recordTimingMetric (e) { this.timingMetrics[e] = (new Date()).getTime() }getTimingMetrics () { return Object.assign({}, this.timingMetrics) }getHistoryMethodForAction (e) { switch (e) { case 'replace':return history.replaceState; case 'advance':case 'restore':return history.pushState } }hasPreloadedResponse () { return typeof this.response === 'object' }shouldIssueRequest () { return !this.isSamePage && (this.action == 'restore' ? !this.hasCachedSnapshot() : this.willRender) }cacheSnapshot () { this.snapshotCached || (this.view.cacheSnapshot(this.snapshot).then(e => e && this.visitCachedSnapshot(e)), this.snapshotCached = !0) } async render (e) { this.cancelRender(), await new Promise(e => { this.frame = requestAnimationFrame(() => e()) }), await e(), delete this.frame }cancelRender () { this.frame && (cancelAnimationFrame(this.frame), delete this.frame) }} function se (e) { return e >= 200 && e < 300 } class ne {constructor (e) { this.progressBar = new Q(), this.showProgressBar = () => { this.progressBar.show() }, this.session = e }visitProposedToLocation (e, t) { this.navigator.startVisit(e, (t == null ? void 0 : t.restorationIdentifier) || A(), t) }visitStarted (e) { this.location = e.location, e.loadCachedSnapshot(), e.issueRequest(), e.goToSamePageAnchor() }visitRequestStarted (e) { this.progressBar.setValue(0), e.hasCachedSnapshot() || e.action != 'restore' ? this.showVisitProgressBarAfterDelay() : this.showProgressBar() }visitRequestCompleted (e) { e.loadResponse() }visitRequestFailedWithStatusCode (e, t) { switch (t) { case ee.networkFailure:case ee.timeoutFailure:case ee.contentTypeMismatch:return this.reload({ reason: 'request_failed', context: { statusCode: t } }); default:return e.loadResponse() } }visitRequestFinished (e) { this.progressBar.setValue(1), this.hideVisitProgressBar() }visitCompleted (e) {}pageInvalidated (e) { this.reload(e) }visitFailed (e) {}visitRendered (e) {}formSubmissionStarted (e) { this.progressBar.setValue(0), this.showFormProgressBarAfterDelay() }formSubmissionFinished (e) { this.progressBar.setValue(1), this.hideFormProgressBar() }showVisitProgressBarAfterDelay () { this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay) }hideVisitProgressBar () { this.progressBar.hide(), this.visitProgressBarTimeout != null && (window.clearTimeout(this.visitProgressBarTimeout), delete this.visitProgressBarTimeout) }showFormProgressBarAfterDelay () { this.formProgressBarTimeout == null && (this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay)) }hideFormProgressBar () { this.progressBar.hide(), this.formProgressBarTimeout != null && (window.clearTimeout(this.formProgressBarTimeout), delete this.formProgressBarTimeout) }reload (e) { let t; w('turbo:reload', { detail: e }), window.location.href = ((t = this.location) === null || void 0 === t ? void 0 : t.toString()) || window.location.href } get navigator () { return this.session.navigator }} class re {constructor () { this.started = !1, this.removeStaleElements = e => { const t = [...document.querySelectorAll('[data-turbo-cache="false"]')]; for (const e of t)e.remove() } }start () { this.started || (this.started = !0, addEventListener('turbo:before-cache', this.removeStaleElements, !1)) }stop () { this.started && (this.started = !1, removeEventListener('turbo:before-cache', this.removeStaleElements, !1)) }} class oe {constructor (e, t) { this.session = e, this.element = t, this.linkInterceptor = new V(this, t), this.formSubmitObserver = new j(this, t) }start () { this.linkInterceptor.start(), this.formSubmitObserver.start() }stop () { this.linkInterceptor.stop(), this.formSubmitObserver.stop() }shouldInterceptLinkClick (e, t, i) { return this.shouldRedirect(e) }linkClickIntercepted (e, t, i) { const s = this.findFrameElement(e); s && s.delegate.linkClickIntercepted(e, t, i) }willSubmitForm (e, t) { return e.closest('turbo-frame') == null && this.shouldSubmit(e, t) && this.shouldRedirect(e, t) }formSubmitted (e, t) { const i = this.findFrameElement(e, t); i && i.delegate.formSubmitted(e, t) }shouldSubmit (e, t) { let i; const s = d(e, t); const n = this.element.ownerDocument.querySelector('meta[name="turbo-root"]'); const r = l((i = n == null ? void 0 : n.content) !== null && void 0 !== i ? i : '/'); return this.shouldRedirect(e, t) && m(s, r) }shouldRedirect (e, t) { if (e instanceof HTMLFormElement ? this.session.submissionIsNavigatable(e, t) : this.session.elementIsNavigatable(e)) { const i = this.findFrameElement(e, t); return !!i && i != e.closest('turbo-frame') } return !1 }findFrameElement (e, t) { const i = (t == null ? void 0 : t.getAttribute('data-turbo-frame')) || e.getAttribute('data-turbo-frame'); if (i && i != '_top') { const e = this.element.querySelector(`#${i}:not([disabled])`); if (e instanceof c) return e } }} class ae {constructor (e) { this.restorationIdentifier = A(), this.restorationData = {}, this.started = !1, this.pageLoaded = !1, this.onPopState = e => { if (this.shouldHandlePopState()) { const { turbo: t } = e.state || {}; if (t) { this.location = new URL(window.location.href); const { restorationIdentifier: e } = t; this.restorationIdentifier = e, this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, e) } } }, this.onPageLoad = async e => { await Promise.resolve(), this.pageLoaded = !0 }, this.delegate = e }start () { this.started || (addEventListener('popstate', this.onPopState, !1), addEventListener('load', this.onPageLoad, !1), this.started = !0, this.replace(new URL(window.location.href))) }stop () { this.started && (removeEventListener('popstate', this.onPopState, !1), removeEventListener('load', this.onPageLoad, !1), this.started = !1) }push (e, t) { this.update(history.pushState, e, t) }replace (e, t) { this.update(history.replaceState, e, t) }update (e, t, i = A()) { const s = { turbo: { restorationIdentifier: i } }; e.call(history, s, '', t.href), this.location = t, this.restorationIdentifier = i }getRestorationDataForIdentifier (e) { return this.restorationData[e] || {} }updateRestorationData (e) { const { restorationIdentifier: t } = this; const i = this.restorationData[t]; this.restorationData[t] = Object.assign(Object.assign({}, i), e) }assumeControlOfScrollRestoration () { let e; this.previousScrollRestoration || (this.previousScrollRestoration = (e = history.scrollRestoration) !== null && void 0 !== e ? e : 'auto', history.scrollRestoration = 'manual') }relinquishControlOfScrollRestoration () { this.previousScrollRestoration && (history.scrollRestoration = this.previousScrollRestoration, delete this.previousScrollRestoration) }shouldHandlePopState () { return this.pageIsLoaded() }pageIsLoaded () { return this.pageLoaded || document.readyState == 'complete' }} class ce {constructor (e) { this.delegate = e }proposeVisit (e, t = {}) { this.delegate.allowsVisitingLocationWithAction(e, t.action) && (m(e, this.view.snapshot.rootLocation) ? this.delegate.visitProposedToLocation(e, t) : window.location.href = e.toString()) }startVisit (e, t, i = {}) { this.stop(), this.currentVisit = new ie(this, l(e), t, Object.assign({ referrer: this.location }, i)), this.currentVisit.start() }submitForm (e, t) { this.stop(), this.formSubmission = new N(this, e, t, !0), this.formSubmission.start() }stop () { this.formSubmission && (this.formSubmission.stop(), delete this.formSubmission), this.currentVisit && (this.currentVisit.cancel(), delete this.currentVisit) } get adapter () { return this.delegate.adapter } get view () { return this.delegate.view } get history () { return this.delegate.history }formSubmissionStarted (e) { typeof this.adapter.formSubmissionStarted === 'function' && this.adapter.formSubmissionStarted(e) } async formSubmissionSucceededWithResponse (e, t) { if (e == this.formSubmission) { const i = await t.responseHTML; if (i) { const n = e.method == s.get; n || this.view.clearSnapshotCache(); const { statusCode: r, redirected: o } = t; const a = { action: this.getActionForFormSubmission(e), shouldCacheSnapshot: n, response: { statusCode: r, responseHTML: i, redirected: o } }; this.proposeVisit(t.location, a) } } } async formSubmissionFailedWithResponse (e, t) { const i = await t.responseHTML; if (i) { const e = J.fromHTMLString(i); t.serverError ? await this.view.renderError(e, this.currentVisit) : await this.view.renderPage(e, !1, !0, this.currentVisit), this.view.scrollToTop(), this.view.clearSnapshotCache() } }formSubmissionErrored (e, t) { console.error(t) }formSubmissionFinished (e) { typeof this.adapter.formSubmissionFinished === 'function' && this.adapter.formSubmissionFinished(e) }visitStarted (e) { this.delegate.visitStarted(e) }visitCompleted (e) { this.delegate.visitCompleted(e) }locationWithActionIsSamePage (e, t) { const i = h(e); const s = h(this.view.lastRenderedLocation); const n = t === 'restore' && void 0 === i; return t !== 'replace' && f(e) === f(this.view.lastRenderedLocation) && (n || i != null && i !== s) }visitScrolledToSamePageLocation (e, t) { this.delegate.visitScrolledToSamePageLocation(e, t) } get location () { return this.history.location } get restorationIdentifier () { return this.history.restorationIdentifier }getActionForFormSubmission (e) { const { formElement: t, submitter: i } = e; const s = C('data-turbo-action', i, t); return v(s) ? s : 'advance' }}!(function (e) { e[e.initial = 0] = 'initial', e[e.loading = 1] = 'loading', e[e.interactive = 2] = 'interactive', e[e.complete = 3] = 'complete' }(te || (te = {}))); class le {constructor (e) { this.stage = te.initial, this.started = !1, this.interpretReadyState = () => { const { readyState: e } = this; e == 'interactive' ? this.pageIsInteractive() : e == 'complete' && this.pageIsComplete() }, this.pageWillUnload = () => { this.delegate.pageWillUnload() }, this.delegate = e }start () { this.started || (this.stage == te.initial && (this.stage = te.loading), document.addEventListener('readystatechange', this.interpretReadyState, !1), addEventListener('pagehide', this.pageWillUnload, !1), this.started = !0) }stop () { this.started && (document.removeEventListener('readystatechange', this.interpretReadyState, !1), removeEventListener('pagehide', this.pageWillUnload, !1), this.started = !1) }pageIsInteractive () { this.stage == te.loading && (this.stage = te.interactive, this.delegate.pageBecameInteractive()) }pageIsComplete () { this.pageIsInteractive(), this.stage == te.interactive && (this.stage = te.complete, this.delegate.pageLoaded()) } get readyState () { return document.readyState }} class he {constructor (e) { this.started = !1, this.onScroll = () => { this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset }) }, this.delegate = e }start () { this.started || (addEventListener('scroll', this.onScroll, !1), this.onScroll(), this.started = !0) }stop () { this.started && (removeEventListener('scroll', this.onScroll, !1), this.started = !1) }updatePosition (e) { this.delegate.scrollPositionChanged(e) }} class de {render ({ fragment: e }) { U.preservingPermanentElements(this, (function (e) { const t = B(document.documentElement); const i = {}; for (const s of t) { const { id: t } = s; for (const n of e.querySelectorAll('turbo-stream')) { const e = D(n.templateElement.content, t); e && (i[t] = [s, e]) } } return i }(e)), () => document.documentElement.appendChild(e)) }enteringBardo (e, t) { t.replaceWith(e.cloneNode(!0)) }leavingBardo () {}} class ue {constructor (e) { this.sources = new Set(), this.started = !1, this.inspectFetchResponse = e => { const t = (function (e) { let t; const i = (t = e.detail) === null || void 0 === t ? void 0 : t.fetchResponse; if (i instanceof b) return i }(e)); t && (function (e) { let t; return ((t = e.contentType) !== null && void 0 !== t ? t : '').startsWith(R.contentType) }(t)) && (e.preventDefault(), this.receiveMessageResponse(t)) }, this.receiveMessageEvent = e => { this.started && typeof e.data === 'string' && this.receiveMessageHTML(e.data) }, this.delegate = e }start () { this.started || (this.started = !0, addEventListener('turbo:before-fetch-response', this.inspectFetchResponse, !1)) }stop () { this.started && (this.started = !1, removeEventListener('turbo:before-fetch-response', this.inspectFetchResponse, !1)) }connectStreamSource (e) { this.streamSourceIsConnected(e) || (this.sources.add(e), e.addEventListener('message', this.receiveMessageEvent, !1)) }disconnectStreamSource (e) { this.streamSourceIsConnected(e) && (this.sources.delete(e), e.removeEventListener('message', this.receiveMessageEvent, !1)) }streamSourceIsConnected (e) { return this.sources.has(e) } async receiveMessageResponse (e) { const t = await e.responseHTML; t && this.receiveMessageHTML(t) }receiveMessageHTML (e) { this.delegate.receivedMessageFromStream(R.wrap(e)) }} class pe extends K {static renderElement (e, t) { const { documentElement: i, body: s } = document; i.replaceChild(t, s) } async render () { this.replaceHeadAndBody(), this.activateScriptElements() }replaceHeadAndBody () { const { documentElement: e, head: t } = document; e.replaceChild(this.newHead, t), this.renderElement(this.currentElement, this.newElement) }activateScriptElements () { for (const e of this.scriptElements) { const t = e.parentNode; if (t) { const i = y(e); t.replaceChild(i, e) } } } get newHead () { return this.newSnapshot.headSnapshot.element } get scriptElements () { return document.documentElement.querySelectorAll('script') }} class me extends K {static renderElement (e, t) { document.body && t instanceof HTMLBodyElement ? document.body.replaceWith(t) : document.documentElement.appendChild(t) } get shouldRender () { return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical } get reloadReason () { return this.newSnapshot.isVisitable ? this.trackedElementsAreIdentical ? void 0 : { reason: 'tracked_element_mismatch' } : { reason: 'turbo_visit_control_is_reload' } } async prepareToRender () { await this.mergeHead() } async render () { this.willRender && this.replaceBody() }finishRendering () { super.finishRendering(), this.isPreview || this.focusFirstAutofocusableElement() } get currentHeadSnapshot () { return this.currentSnapshot.headSnapshot } get newHeadSnapshot () { return this.newSnapshot.headSnapshot } get newElement () { return this.newSnapshot.element } async mergeHead () { const e = this.copyNewHeadStylesheetElements(); this.copyNewHeadScriptElements(), this.removeCurrentHeadProvisionalElements(), this.copyNewHeadProvisionalElements(), await e }replaceBody () { this.preservingPermanentElements(() => { this.activateNewBody(), this.assignNewBody() }) } get trackedElementsAreIdentical () { return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature } async copyNewHeadStylesheetElements () { const e = []; for (const t of this.newHeadStylesheetElements)e.push(L(t)), document.head.appendChild(t); await Promise.all(e) }copyNewHeadScriptElements () { for (const e of this.newHeadScriptElements)document.head.appendChild(y(e)) }removeCurrentHeadProvisionalElements () { for (const e of this.currentHeadProvisionalElements)document.head.removeChild(e) }copyNewHeadProvisionalElements () { for (const e of this.newHeadProvisionalElements)document.head.appendChild(e) }activateNewBody () { document.adoptNode(this.newElement), this.activateNewBodyScriptElements() }activateNewBodyScriptElements () { for (const e of this.newBodyScriptElements) { const t = y(e); e.replaceWith(t) } }assignNewBody () { this.renderElement(this.currentElement, this.newElement) } get newHeadStylesheetElements () { return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot) } get newHeadScriptElements () { return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot) } get currentHeadProvisionalElements () { return this.currentHeadSnapshot.provisionalElements } get newHeadProvisionalElements () { return this.newHeadSnapshot.provisionalElements } get newBodyScriptElements () { return this.newElement.querySelectorAll('script') }} class fe {constructor (e) { this.keys = [], this.snapshots = {}, this.size = e }has (e) { return g(e) in this.snapshots }get (e) { if (this.has(e)) { const t = this.read(e); return this.touch(e), t } }put (e, t) { return this.write(e, t), this.touch(e), t }clear () { this.snapshots = {} }read (e) { return this.snapshots[g(e)] }write (e, t) { this.snapshots[g(e)] = t }touch (e) { const t = g(e); const i = this.keys.indexOf(t); i > -1 && this.keys.splice(i, 1), this.keys.unshift(t), this.trim() }trim () { for (const e of this.keys.splice(this.size)) delete this.snapshots[e] }} class ge extends q {constructor () { super(...arguments), this.snapshotCache = new fe(10), this.lastRenderedLocation = new URL(location.href), this.forceReloaded = !1 }renderPage (e, t = !1, i = !0, s) { const n = new me(this.snapshot, e, me.renderElement, t, i); return n.shouldRender ? s == null || s.changeHistory() : this.forceReloaded = !0, this.render(n) }renderError (e, t) { t == null || t.changeHistory(); const i = new pe(this.snapshot, e, pe.renderElement, !1); return this.render(i) }clearSnapshotCache () { this.snapshotCache.clear() } async cacheSnapshot (e = this.snapshot) { if (e.isCacheable) { this.delegate.viewWillCacheSnapshot(); const { lastRenderedLocation: t } = this; await new Promise(e => setTimeout(() => e(), 0)); const i = e.clone(); return this.snapshotCache.put(t, i), i } }getCachedSnapshotForLocation (e) { return this.snapshotCache.get(e) } get snapshot () { return J.fromElement(this.element) }} class be {constructor (e) { this.selector = 'a[data-turbo-preload]', this.delegate = e } get snapshotCache () { return this.delegate.navigator.view.snapshotCache }start () { if (document.readyState === 'loading') return document.addEventListener('DOMContentLoaded', () => { this.preloadOnLoadLinksForView(document.body) }); this.preloadOnLoadLinksForView(document.body) }preloadOnLoadLinksForView (e) { for (const t of e.querySelectorAll(this.selector)) this.preloadURL(t) } async preloadURL (e) { const t = new URL(e.href); if (!this.snapshotCache.has(t)) try { const e = await fetch(t.toString(), { headers: { 'VND.PREFETCH': 'true', Accept: 'text/html' } }); const i = await e.text(); const s = J.fromHTMLString(i); this.snapshotCache.put(t, s) } catch (e) {} }} function ve (e) { Object.defineProperties(e, ye) } const ye = { absoluteURL: { get () { return this.toString() } } }; const we = { after () { this.targetElements.forEach(e => { let t; return (t = e.parentElement) === null || void 0 === t ? void 0 : t.insertBefore(this.templateContent, e.nextSibling) }) }, append () { this.removeDuplicateTargetChildren(), this.targetElements.forEach(e => e.append(this.templateContent)) }, before () { this.targetElements.forEach(e => { let t; return (t = e.parentElement) === null || void 0 === t ? void 0 : t.insertBefore(this.templateContent, e) }) }, prepend () { this.removeDuplicateTargetChildren(), this.targetElements.forEach(e => e.prepend(this.templateContent)) }, remove () { this.targetElements.forEach(e => e.remove()) }, replace () { this.targetElements.forEach(e => e.replaceWith(this.templateContent)) }, update () { this.targetElements.forEach(e => e.replaceChildren(this.templateContent)) } }; const _e = new class {constructor () { this.navigator = new ce(this), this.history = new ae(this), this.preloader = new be(this), this.view = new ge(this, document.documentElement), this.adapter = new ne(this), this.pageObserver = new le(this), this.cacheObserver = new re(), this.linkClickObserver = new $(this, window), this.formSubmitObserver = new j(this, document), this.scrollObserver = new he(this), this.streamObserver = new ue(this), this.formLinkClickObserver = new W(this, document.documentElement), this.frameRedirector = new oe(this, document.documentElement), this.streamMessageRenderer = new de(), this.drive = !0, this.enabled = !0, this.progressBarDelay = 500, this.started = !1, this.formMode = 'on' }start () { this.started || (this.pageObserver.start(), this.cacheObserver.start(), this.formLinkClickObserver.start(), this.linkClickObserver.start(), this.formSubmitObserver.start(), this.scrollObserver.start(), this.streamObserver.start(), this.frameRedirector.start(), this.history.start(), this.preloader.start(), this.started = !0, this.enabled = !0) }disable () { this.enabled = !1 }stop () { this.started && (this.pageObserver.stop(), this.cacheObserver.stop(), this.formLinkClickObserver.stop(), this.linkClickObserver.stop(), this.formSubmitObserver.stop(), this.scrollObserver.stop(), this.streamObserver.stop(), this.frameRedirector.stop(), this.history.stop(), this.started = !1) }registerAdapter (e) { this.adapter = e }visit (e, t = {}) { const i = t.frame ? document.getElementById(t.frame) : null; i instanceof c ? (i.src = e.toString(), i.loaded) : this.navigator.proposeVisit(l(e), t) }connectStreamSource (e) { this.streamObserver.connectStreamSource(e) }disconnectStreamSource (e) { this.streamObserver.disconnectStreamSource(e) }renderStreamMessage (e) { this.streamMessageRenderer.render(R.wrap(e)) }clearCache () { this.view.clearSnapshotCache() }setProgressBarDelay (e) { this.progressBarDelay = e }setFormMode (e) { this.formMode = e } get location () { return this.history.location } get restorationIdentifier () { return this.history.restorationIdentifier }historyPoppedToLocationWithRestorationIdentifier (e, t) { this.enabled ? this.navigator.startVisit(e, t, { action: 'restore', historyChanged: !0 }) : this.adapter.pageInvalidated({ reason: 'turbo_disabled' }) }scrollPositionChanged (e) { this.history.updateRestorationData({ scrollPosition: e }) }willSubmitFormLinkToLocation (e, t) { return this.elementIsNavigatable(e) && m(t, this.snapshot.rootLocation) }submittedFormLinkToLocation () {}willFollowLinkToLocation (e, t, i) { return this.elementIsNavigatable(e) && m(t, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(e, t, i) }followedLinkToLocation (e, t) { const i = this.getActionForLink(e); const s = e.hasAttribute('data-turbo-stream'); this.visit(t.href, { action: i, acceptsStreamResponse: s }) }allowsVisitingLocationWithAction (e, t) { return this.locationWithActionIsSamePage(e, t) || this.applicationAllowsVisitingLocation(e) }visitProposedToLocation (e, t) { ve(e), this.adapter.visitProposedToLocation(e, t) }visitStarted (e) { e.acceptsStreamResponse || k(document.documentElement), ve(e.location), e.silent || this.notifyApplicationAfterVisitingLocation(e.location, e.action) }visitCompleted (e) { T(document.documentElement), this.notifyApplicationAfterPageLoad(e.getTimingMetrics()) }locationWithActionIsSamePage (e, t) { return this.navigator.locationWithActionIsSamePage(e, t) }visitScrolledToSamePageLocation (e, t) { this.notifyApplicationAfterVisitingSamePageLocation(e, t) }willSubmitForm (e, t) { const i = d(e, t); return this.submissionIsNavigatable(e, t) && m(l(i), this.snapshot.rootLocation) }formSubmitted (e, t) { this.navigator.submitForm(e, t) }pageBecameInteractive () { this.view.lastRenderedLocation = this.location, this.notifyApplicationAfterPageLoad() }pageLoaded () { this.history.assumeControlOfScrollRestoration() }pageWillUnload () { this.history.relinquishControlOfScrollRestoration() }receivedMessageFromStream (e) { this.renderStreamMessage(e) }viewWillCacheSnapshot () { let e; ((e = this.navigator.currentVisit) === null || void 0 === e ? void 0 : e.silent) || this.notifyApplicationBeforeCachingSnapshot() }allowsImmediateRender ({ element: e }, t) { const i = this.notifyApplicationBeforeRender(e, t); const { defaultPrevented: s, detail: { render: n } } = i; return this.view.renderer && n && (this.view.renderer.renderElement = n), !s }viewRenderedSnapshot (e, t) { this.view.lastRenderedLocation = this.history.location, this.notifyApplicationAfterRender() }preloadOnLoadLinksForView (e) { this.preloader.preloadOnLoadLinksForView(e) }viewInvalidated (e) { this.adapter.pageInvalidated(e) }frameLoaded (e) { this.notifyApplicationAfterFrameLoad(e) }frameRendered (e, t) { this.notifyApplicationAfterFrameRender(e, t) }applicationAllowsFollowingLinkToLocation (e, t, i) { return !this.notifyApplicationAfterClickingLinkToLocation(e, t, i).defaultPrevented }applicationAllowsVisitingLocation (e) { return !this.notifyApplicationBeforeVisitingLocation(e).defaultPrevented }notifyApplicationAfterClickingLinkToLocation (e, t, i) { return w('turbo:click', { target: e, detail: { url: t.href, originalEvent: i }, cancelable: !0 }) }notifyApplicationBeforeVisitingLocation (e) { return w('turbo:before-visit', { detail: { url: e.href }, cancelable: !0 }) }notifyApplicationAfterVisitingLocation (e, t) { return w('turbo:visit', { detail: { url: e.href, action: t } }) }notifyApplicationBeforeCachingSnapshot () { return w('turbo:before-cache') }notifyApplicationBeforeRender (e, t) { return w('turbo:before-render', { detail: Object.assign({ newBody: e }, t), cancelable: !0 }) }notifyApplicationAfterRender () { return w('turbo:render') }notifyApplicationAfterPageLoad (e = {}) { return w('turbo:load', { detail: { url: this.location.href, timing: e } }) }notifyApplicationAfterVisitingSamePageLocation (e, t) { dispatchEvent(new HashChangeEvent('hashchange', { oldURL: e.toString(), newURL: t.toString() })) }notifyApplicationAfterFrameLoad (e) { return w('turbo:frame-load', { target: e }) }notifyApplicationAfterFrameRender (e, t) { return w('turbo:frame-render', { detail: { fetchResponse: e }, target: t, cancelable: !0 }) }submissionIsNavigatable (e, t) { if (this.formMode == 'off') return !1; { const i = !t || this.elementIsNavigatable(t); return this.formMode == 'optin' ? i && e.closest('[data-turbo="true"]') != null : i && this.elementIsNavigatable(e) } }elementIsNavigatable (e) { const t = e.closest('[data-turbo]'); const i = e.closest('turbo-frame'); return this.drive || i ? !t || t.getAttribute('data-turbo') != 'false' : !!t && t.getAttribute('data-turbo') == 'true' }getActionForLink (e) { const t = e.getAttribute('data-turbo-action'); return v(t) ? t : 'advance' } get snapshot () { return this.view.snapshot }}(); const Ee = new class {constructor (e) { this.session = e }clear () { this.session.clearCache() }resetCacheControl () { this.setCacheControl('') }exemptPageFromCache () { this.setCacheControl('no-cache') }exemptPageFromPreview () { this.setCacheControl('no-preview') }setCacheControl (e) { !(function (e, t) { let i = P(e); i || (i = document.createElement('meta'), i.setAttribute('name', e), document.head.appendChild(i)), i.setAttribute('content', t) }('turbo-cache-control', e)) }}(_e); const { navigator: Se } = _e; function Ae () { _e.start() } function Ce (e) { _e.connectStreamSource(e) } function ke (e) { _e.disconnectStreamSource(e) } const Te = Object.freeze({ __proto__: null, navigator: Se, session: _e, cache: Ee, PageRenderer: me, PageSnapshot: J, FrameRenderer: z, start: Ae, registerAdapter: function (e) { _e.registerAdapter(e) }, visit: function (e, t) { _e.visit(e, t) }, connectStreamSource: Ce, disconnectStreamSource: ke, renderStreamMessage: function (e) { _e.renderStreamMessage(e) }, clearCache: function () { console.warn('Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`'), _e.clearCache() }, setProgressBarDelay: function (e) { _e.setProgressBarDelay(e) }, setConfirmMethod: function (e) { N.confirmMethod = e }, setFormMode: function (e) { _e.setFormMode(e) }, StreamActions: we }); function Le (e) { if (e != null) { const t = document.getElementById(e); if (t instanceof c) return t } } function Oe (e, t) { if (e) { const i = e.getAttribute('src'); if (i != null && t != null && (function (e, t) { return l(e).href == l(t).href }(i, t))) throw new Error(`Matching <turbo-frame id="${e.id}"> element has a source URL which references itself`); if (e.ownerDocument !== document && (e = document.importNode(e, !0)), e instanceof c) return e.connectedCallback(), e.disconnectedCallback(), e } } class Pe extends HTMLElement {static async renderElement (e) { await e.performAction() } async connectedCallback () { try { await this.render() } catch (e) { console.error(e) } finally { this.disconnect() } } async render () { let e; return (e = this.renderPromise) !== null && void 0 !== e ? e : this.renderPromise = (async () => { const e = this.beforeRenderEvent; this.dispatchEvent(e) && (await _(), await e.detail.render(this)) })() }disconnect () { try { this.remove() } catch (e) {} }removeDuplicateTargetChildren () { this.duplicateChildren.forEach(e => e.remove()) } get duplicateChildren () { let e; const t = this.targetElements.flatMap(e => [...e.children]).filter(e => !!e.id); const i = [...((e = this.templateContent) === null || void 0 === e ? void 0 : e.children) || []].filter(e => !!e.id).map(e => e.id); return t.filter(e => i.includes(e.id)) } get performAction () { if (this.action) { const e = we[this.action]; if (e) return e; this.raise('unknown action') } this.raise('action attribute is missing') } get targetElements () { return this.target ? this.targetElementsById : this.targets ? this.targetElementsByQuery : void this.raise('target or targets attribute is missing') } get templateContent () { return this.templateElement.content.cloneNode(!0) } get templateElement () { if (this.firstElementChild === null) { const e = this.ownerDocument.createElement('template'); return this.appendChild(e), e } if (this.firstElementChild instanceof HTMLTemplateElement) return this.firstElementChild; this.raise('first child element must be a <template> element') } get action () { return this.getAttribute('action') } get target () { return this.getAttribute('target') } get targets () { return this.getAttribute('targets') }raise (e) { throw new Error(`${this.description}: ${e}`) } get description () { let e, t; return (t = ((e = this.outerHTML.match(/<[^>]+>/)) !== null && void 0 !== e ? e : [])[0]) !== null && void 0 !== t ? t : '<turbo-stream>' } get beforeRenderEvent () { return new CustomEvent('turbo:before-stream-render', { bubbles: !0, cancelable: !0, detail: { newStream: this, render: Pe.renderElement } }) } get targetElementsById () { let e; const t = (e = this.ownerDocument) === null || void 0 === e ? void 0 : e.getElementById(this.target); return t !== null ? [t] : [] } get targetElementsByQuery () { let e; const t = (e = this.ownerDocument) === null || void 0 === e ? void 0 : e.querySelectorAll(this.targets); return t.length !== 0 ? Array.prototype.slice.call(t) : [] }} class Me extends HTMLElement {constructor () { super(...arguments), this.streamSource = null }connectedCallback () { this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src), Ce(this.streamSource) }disconnectedCallback () { this.streamSource && ke(this.streamSource) } get src () { return this.getAttribute('src') || '' }} let xe; async function Ie () { return xe || Re((async function () { const { createConsumer: e } = await Promise.resolve().then(function () { return Aa }); return e() }()).then(Re)) } function Re (e) { return xe = e } function Ne (e) { return e && typeof e === 'object' ? e instanceof Date || e instanceof RegExp ? e : Array.isArray(e) ? e.map(Ne) : Object.keys(e).reduce(function (t, i) { return t[i[0].toLowerCase() + i.slice(1).replace(/([A-Z]+)/g, function (e, t) { return '_' + t.toLowerCase() })] = Ne(e[i]), t }, {}) : e }c.delegateConstructor = class {constructor (e) { this.fetchResponseLoaded = e => {}, this.currentFetchRequest = null, this.resolveVisitPromise = () => {}, this.connected = !1, this.hasBeenLoaded = !1, this.ignoredAttributes = new Set(), this.action = null, this.visitCachedSnapshot = ({ element: e }) => { const t = e.querySelector('#' + this.element.id); t && this.previousFrameElement && t.replaceChildren(...this.previousFrameElement.children), delete this.previousFrameElement }, this.element = e, this.view = new H(this, this.element), this.appearanceObserver = new I(this, this.element), this.formLinkClickObserver = new W(this, this.element), this.linkInterceptor = new V(this, this.element), this.restorationIdentifier = A(), this.formSubmitObserver = new j(this, this.element) }connect () { this.connected || (this.connected = !0, this.loadingStyle == i.lazy ? this.appearanceObserver.start() : this.loadSourceURL(), this.formLinkClickObserver.start(), this.linkInterceptor.start(), this.formSubmitObserver.start()) }disconnect () { this.connected && (this.connected = !1, this.appearanceObserver.stop(), this.formLinkClickObserver.stop(), this.linkInterceptor.stop(), this.formSubmitObserver.stop()) }disabledChanged () { this.loadingStyle == i.eager && this.loadSourceURL() }sourceURLChanged () { this.isIgnoringChangesTo('src') || (this.element.isConnected && (this.complete = !1), (this.loadingStyle == i.eager || this.hasBeenLoaded) && this.loadSourceURL()) }sourceURLReloaded () { const { src: e } = this.element; return this.ignoringChangesToAttribute('complete', () => { this.element.removeAttribute('complete') }), this.element.src = null, this.element.src = e, this.element.loaded }completeChanged () { this.isIgnoringChangesTo('complete') || this.loadSourceURL() }loadingStyleChanged () { this.loadingStyle == i.lazy ? this.appearanceObserver.start() : (this.appearanceObserver.stop(), this.loadSourceURL()) } async loadSourceURL () { this.enabled && this.isActive && !this.complete && this.sourceURL && (this.element.loaded = this.visit(l(this.sourceURL)), this.appearanceObserver.stop(), await this.element.loaded, this.hasBeenLoaded = !0) } async loadResponse (e) { (e.redirected || e.succeeded && e.isHTML) && (this.sourceURL = e.response.url); try { const t = await e.responseHTML; if (t) { const { body: i } = E(t); const s = await this.extractForeignFrameElement(i); if (s) { const t = new F(s); const i = new z(this, this.view.snapshot, t, z.renderElement, !1, !1); this.view.renderPromise && await this.view.renderPromise, this.changeHistory(), await this.view.render(i), this.complete = !0, _e.frameRendered(e, this.element), _e.frameLoaded(this.element), this.fetchResponseLoaded(e) } else this.willHandleFrameMissingFromResponse(e) && (console.warn(`A matching frame for #${this.element.id} was missing from the response, transforming into full-page Visit.`), this.visitResponse(e.response)) } } catch (e) { console.error(e), this.view.invalidate() } finally { this.fetchResponseLoaded = () => {} } }elementAppearedInViewport (e) { this.loadSourceURL() }willSubmitFormLinkToLocation (e) { return this.shouldInterceptNavigation(e) }submittedFormLinkToLocation (e, t, i) { const s = this.findFrameElement(e); s && i.setAttribute('data-turbo-frame', s.id) }shouldInterceptLinkClick (e, t, i) { return this.shouldInterceptNavigation(e) }linkClickIntercepted (e, t) { this.navigateFrame(e, t) }willSubmitForm (e, t) { return e.closest('turbo-frame') == this.element && this.shouldInterceptNavigation(e, t) }formSubmitted (e, t) { this.formSubmission && this.formSubmission.stop(), this.formSubmission = new N(this, e, t); const { fetchRequest: i } = this.formSubmission; this.prepareHeadersForRequest(i.headers, i), this.formSubmission.start() }prepareHeadersForRequest (e, t) { let i; e['Turbo-Frame'] = this.id, ((i = this.currentNavigationElement) === null || void 0 === i ? void 0 : i.hasAttribute('data-turbo-stream')) && t.acceptResponseType(R.contentType) }requestStarted (e) { k(this.element) }requestPreventedHandlingResponse (e, t) { this.resolveVisitPromise() } async requestSucceededWithResponse (e, t) { await this.loadResponse(t), this.resolveVisitPromise() } async requestFailedWithResponse (e, t) { console.error(t), await this.loadResponse(t), this.resolveVisitPromise() }requestErrored (e, t) { console.error(t), this.resolveVisitPromise() }requestFinished (e) { T(this.element) }formSubmissionStarted ({ formElement: e }) { k(e, this.findFrameElement(e)) }formSubmissionSucceededWithResponse (e, t) { const i = this.findFrameElement(e.formElement, e.submitter); i.delegate.proposeVisitIfNavigatedWithAction(i, e.formElement, e.submitter), i.delegate.loadResponse(t) }formSubmissionFailedWithResponse (e, t) { this.element.delegate.loadResponse(t) }formSubmissionErrored (e, t) { console.error(t) }formSubmissionFinished ({ formElement: e }) { T(e, this.findFrameElement(e)) }allowsImmediateRender ({ element: e }, t) { const i = w('turbo:before-frame-render', { target: this.element, detail: Object.assign({ newFrame: e }, t), cancelable: !0 }); const { defaultPrevented: s, detail: { render: n } } = i; return this.view.renderer && n && (this.view.renderer.renderElement = n), !s }viewRenderedSnapshot (e, t) {}preloadOnLoadLinksForView (e) { _e.preloadOnLoadLinksForView(e) }viewInvalidated () {}willRenderFrame (e, t) { this.previousFrameElement = e.cloneNode(!0) } async visit (e) { let t; const i = new x(this, s.get, e, new URLSearchParams(), this.element); return (t = this.currentFetchRequest) === null || void 0 === t || t.cancel(), this.currentFetchRequest = i, new Promise(e => { this.resolveVisitPromise = () => { this.resolveVisitPromise = () => {}, this.currentFetchRequest = null, e() }, i.perform() }) }navigateFrame (e, t, i) { const s = this.findFrameElement(e, i); this.pageSnapshot = J.fromElement(s).clone(), s.delegate.proposeVisitIfNavigatedWithAction(s, e, i), this.withCurrentNavigationElement(e, () => { s.src = t }) }proposeVisitIfNavigatedWithAction (e, t, i) { if (this.action = (function (...e) { const t = C('data-turbo-action', ...e); return v(t) ? t : null }(i, t, e)), v(this.action)) { const { visitCachedSnapshot: t } = e.delegate; e.delegate.fetchResponseLoaded = i => { if (e.src) { const { statusCode: s, redirected: n } = i; const r = { response: { statusCode: s, redirected: n, responseHTML: e.ownerDocument.documentElement.outerHTML }, visitCachedSnapshot: t, willRender: !1, updateHistory: !1, restorationIdentifier: this.restorationIdentifier, snapshot: this.pageSnapshot }; this.action && (r.action = this.action), _e.visit(e.src, r) } } } }changeHistory () { if (this.action) { const e = O(this.action); _e.history.update(e, l(this.element.src || ''), this.restorationIdentifier) } }willHandleFrameMissingFromResponse (e) { this.element.setAttribute('complete', ''); const t = e.response; return !w('turbo:frame-missing', { target: this.element, detail: { response: t, visit: async (e, t = {}) => { e instanceof Response ? this.visitResponse(e) : _e.visit(e, t) } }, cancelable: !0 }).defaultPrevented } async visitResponse (e) { const t = new b(e); const i = await t.responseHTML; const { location: s, redirected: n, statusCode: r } = t; return _e.visit(s, { response: { redirected: n, statusCode: r, responseHTML: i } }) }findFrameElement (e, t) { let i; return (i = Le(C('data-turbo-frame', t, e) || this.element.getAttribute('target'))) !== null && void 0 !== i ? i : this.element } async extractForeignFrameElement (e) { let t; const i = CSS.escape(this.id); try { if (t = Oe(e.querySelector(`turbo-frame#${i}`), this.sourceURL), t) return t; if (t = Oe(e.querySelector(`turbo-frame[src][recurse~=${i}]`), this.sourceURL), t) return await t.loaded, await this.extractForeignFrameElement(t) } catch (e) { return console.error(e), new c() } return null }formActionIsVisitable (e, t) { return m(l(d(e, t)), this.rootLocation) }shouldInterceptNavigation (e, t) { const i = C('data-turbo-frame', t, e) || this.element.getAttribute('target'); if (e instanceof HTMLFormElement && !this.formActionIsVisitable(e, t)) return !1; if (!this.enabled || i == '_top') return !1; if (i) { const e = Le(i); if (e) return !e.disabled } return !!_e.elementIsNavigatable(e) && !(t && !_e.elementIsNavigatable(t)) } get id () { return this.element.id } get enabled () { return !this.element.disabled } get sourceURL () { if (this.element.src) return this.element.src } set sourceURL (e) { this.ignoringChangesToAttribute('src', () => { this.element.src = e != null ? e : null }) } get loadingStyle () { return this.element.loading } get isLoading () { return void 0 !== this.formSubmission || void 0 !== this.resolveVisitPromise() } get complete () { return this.element.hasAttribute('complete') } set complete (e) { this.ignoringChangesToAttribute('complete', () => { e ? this.element.setAttribute('complete', '') : this.element.removeAttribute('complete') }) } get isActive () { return this.element.isActive && this.connected } get rootLocation () { let e; const t = this.element.ownerDocument.querySelector('meta[name="turbo-root"]'); return l((e = t == null ? void 0 : t.content) !== null && void 0 !== e ? e : '/') }isIgnoringChangesTo (e) { return this.ignoredAttributes.has(e) }ignoringChangesToAttribute (e, t) { this.ignoredAttributes.add(e), t(), this.ignoredAttributes.delete(e) }withCurrentNavigationElement (e, t) { this.currentNavigationElement = e, t(), delete this.currentNavigationElement }}, void 0 === customElements.get('turbo-frame') && customElements.define('turbo-frame', c), void 0 === customElements.get('turbo-stream') && customElements.define('turbo-stream', Pe), void 0 === customElements.get('turbo-stream-source') && customElements.define('turbo-stream-source', Me), (() => {
  let e = document.currentScript; if (e && !e.hasAttribute('data-turbo-suppress-warning')) {
    for (e = e.parentElement; e;) {
      if (e == document.body) {
        return console.warn(S`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, e.outerHTML)
      } e = e.parentElement
    }
  }
})(), window.Turbo = Te, Ae(); class Fe extends HTMLElement {async connectedCallback () { Ce(this), this.subscription = await (async function (e, t) { const { subscriptions: i } = await Ie(); return i.create(e, t) }(this.channel, { received: this.dispatchMessageEvent.bind(this) })) }disconnectedCallback () { ke(this), this.subscription && this.subscription.unsubscribe() }dispatchMessageEvent (e) { const t = new MessageEvent('message', { data: e }); return this.dispatchEvent(t) } get channel () { return { channel: this.getAttribute('channel'), signed_stream_name: this.getAttribute('signed-stream-name'), ...Ne({ ...this.dataset }) } }}customElements.define('turbo-cable-stream-source', Fe), addEventListener('turbo:before-fetch-request', function (e) { if (e.target instanceof HTMLFormElement) { const { target: t, detail: { fetchOptions: i } } = e; t.addEventListener('turbo:submit-start', ({ detail: { formSubmission: { submitter: e } } }) => { const s = e && e.formMethod || i.body && i.body.get('_method') || t.getAttribute('method'); /get/i.test(s) || (/post/i.test(s) ? i.body.delete('_method') : i.body.set('_method', s), i.method = 'post') }, { once: !0 }) } }); const De = 'top'; const Be = 'bottom'; const je = 'right'; const qe = 'left'; const He = [De, Be, je, qe]; const Ve = 'end'; const $e = He.reduce(function (e, t) { return e.concat([t + '-start', t + '-' + Ve]) }, []); const We = [].concat(He, ['auto']).reduce(function (e, t) { return e.concat([t, t + '-start', t + '-' + Ve]) }, []); const Ue = ['beforeRead', 'read', 'afterRead', 'beforeMain', 'main', 'afterMain', 'beforeWrite', 'write', 'afterWrite']; function Ke (e) { return e ? (e.nodeName || '').toLowerCase() : null } function ze (e) { if (e == null) return window; if (e.toString() !== '[object Window]') { const t = e.ownerDocument; return t && t.defaultView || window } return e } function Qe (e) { return e instanceof ze(e).Element || e instanceof Element } function Ge (e) { return e instanceof ze(e).HTMLElement || e instanceof HTMLElement } function Ye (e) { return typeof ShadowRoot !== 'undefined' && (e instanceof ze(e).ShadowRoot || e instanceof ShadowRoot) } const Xe = { name: 'applyStyles', enabled: !0, phase: 'write', fn: function (e) { const t = e.state; Object.keys(t.elements).forEach(function (e) { const i = t.styles[e] || {}; const s = t.attributes[e] || {}; const n = t.elements[e]; Ge(n) && Ke(n) && (Object.assign(n.style, i), Object.keys(s).forEach(function (e) { const t = s[e]; !1 === t ? n.removeAttribute(e) : n.setAttribute(e, !0 === t ? '' : t) })) }) }, effect: function (e) { const t = e.state; const i = { popper: { position: t.options.strategy, left: '0', top: '0', margin: '0' }, arrow: { position: 'absolute' }, reference: {} }; return Object.assign(t.elements.popper.style, i.popper), t.styles = i, t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow), function () { Object.keys(t.elements).forEach(function (e) { const s = t.elements[e]; const n = t.attributes[e] || {}; const r = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce(function (e, t) { return e[t] = '', e }, {}); Ge(s) && Ke(s) && (Object.assign(s.style, r), Object.keys(n).forEach(function (e) { s.removeAttribute(e) })) }) } }, requires: ['computeStyles'] }; function Je (e) { return e.split('-')[0] } const Ze = Math.max; const et = Math.min; const tt = Math.round; function it () { const e = navigator.userAgentData; return e != null && e.brands ? e.brands.map(function (e) { return e.brand + '/' + e.version }).join(' ') : navigator.userAgent } function st () { return !/^((?!chrome|android).)*safari/i.test(it()) } function nt (e, t, i) { void 0 === t && (t = !1), void 0 === i && (i = !1); const s = e.getBoundingClientRect(); let n = 1; let r = 1; t && Ge(e) && (n = e.offsetWidth > 0 && tt(s.width) / e.offsetWidth || 1, r = e.offsetHeight > 0 && tt(s.height) / e.offsetHeight || 1); const o = (Qe(e) ? ze(e) : window).visualViewport; const a = !st() && i; const c = (s.left + (a && o ? o.offsetLeft : 0)) / n; const l = (s.top + (a && o ? o.offsetTop : 0)) / r; const h = s.width / n; const d = s.height / r; return { width: h, height: d, top: l, right: c + h, bottom: l + d, left: c, x: c, y: l } } function rt (e) { const t = nt(e); let i = e.offsetWidth; let s = e.offsetHeight; return Math.abs(t.width - i) <= 1 && (i = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), { x: e.offsetLeft, y: e.offsetTop, width: i, height: s } } function ot (e, t) { const i = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (i && Ye(i)) { let s = t; do { if (s && e.isSameNode(s)) return !0; s = s.parentNode || s.host } while (s) } return !1 } function at (e) { return ze(e).getComputedStyle(e) } function ct (e) { return ['table', 'td', 'th'].indexOf(Ke(e)) >= 0 } function lt (e) { return ((Qe(e) ? e.ownerDocument : e.document) || window.document).documentElement } function ht (e) { return Ke(e) === 'html' ? e : e.assignedSlot || e.parentNode || (Ye(e) ? e.host : null) || lt(e) } function dt (e) { return Ge(e) && at(e).position !== 'fixed' ? e.offsetParent : null } function ut (e) { for (var t = ze(e), i = dt(e); i && ct(i) && at(i).position === 'static';)i = dt(i); return i && (Ke(i) === 'html' || Ke(i) === 'body' && at(i).position === 'static') ? t : i || (function (e) { const t = /firefox/i.test(it()); if (/Trident/i.test(it()) && Ge(e) && at(e).position === 'fixed') return null; let i = ht(e); for (Ye(i) && (i = i.host); Ge(i) && ['html', 'body'].indexOf(Ke(i)) < 0;) { const s = at(i); if (s.transform !== 'none' || s.perspective !== 'none' || s.contain === 'paint' || ['transform', 'perspective'].indexOf(s.willChange) !== -1 || t && s.willChange === 'filter' || t && s.filter && s.filter !== 'none') return i; i = i.parentNode } return null }(e)) || t } function pt (e) { return ['top', 'bottom'].indexOf(e) >= 0 ? 'x' : 'y' } function mt (e, t, i) { return Ze(e, et(t, i)) } function ft (e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function gt (e, t) { return t.reduce(function (t, i) { return t[i] = e, t }, {}) } const bt = { name: 'arrow', enabled: !0, phase: 'main', fn: function (e) { let t; const i = e.state; const s = e.name; const n = e.options; const r = i.elements.arrow; const o = i.modifiersData.popperOffsets; const a = Je(i.placement); const c = pt(a); const l = [qe, je].indexOf(a) >= 0 ? 'height' : 'width'; if (r && o) { const h = (function (e, t) { return ft(typeof (e = typeof e === 'function' ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) !== 'number' ? e : gt(e, He)) }(n.padding, i)); const d = rt(r); const u = c === 'y' ? De : qe; const p = c === 'y' ? Be : je; const m = i.rects.reference[l] + i.rects.reference[c] - o[c] - i.rects.popper[l]; const f = o[c] - i.rects.reference[c]; const g = ut(r); const b = g ? c === 'y' ? g.clientHeight || 0 : g.clientWidth || 0 : 0; const v = m / 2 - f / 2; const y = h[u]; const w = b - d[l] - h[p]; const _ = b / 2 - d[l] / 2 + v; const E = mt(y, _, w); const S = c; i.modifiersData[s] = ((t = {})[S] = E, t.centerOffset = E - _, t) } }, effect: function (e) { const t = e.state; const i = e.options.element; let s = void 0 === i ? '[data-popper-arrow]' : i; s != null && (typeof s !== 'string' || (s = t.elements.popper.querySelector(s))) && (process.env.NODE_ENV !== 'production' && (Ge(s) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '))), ot(t.elements.popper, s) ? t.elements.arrow = s : process.env.NODE_ENV !== 'production' && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '))) }, requires: ['popperOffsets'], requiresIfExists: ['preventOverflow'] }; function vt (e) { return e.split('-')[1] } const yt = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }; function wt (e) { let t; const i = e.popper; const s = e.popperRect; const n = e.placement; const r = e.variation; const o = e.offsets; const a = e.position; const c = e.gpuAcceleration; const l = e.adaptive; const h = e.roundOffsets; const d = e.isFixed; const u = o.x; let p = void 0 === u ? 0 : u; const m = o.y; let f = void 0 === m ? 0 : m; const g = typeof h === 'function' ? h({ x: p, y: f }) : { x: p, y: f }; p = g.x, f = g.y; const b = o.hasOwnProperty('x'); const v = o.hasOwnProperty('y'); let y = qe; let w = De; const _ = window; if (l) { let E = ut(i); let S = 'clientHeight'; let A = 'clientWidth'; if (E === ze(i) && at(E = lt(i)).position !== 'static' && a === 'absolute' && (S = 'scrollHeight', A = 'scrollWidth'), n === De || (n === qe || n === je) && r === Ve)w = Be, f -= (d && E === _ && _.visualViewport ? _.visualViewport.height : E[S]) - s.height, f *= c ? 1 : -1; if (n === qe || (n === De || n === Be) && r === Ve)y = je, p -= (d && E === _ && _.visualViewport ? _.visualViewport.width : E[A]) - s.width, p *= c ? 1 : -1 } let C; const k = Object.assign({ position: a }, l && yt); const T = !0 === h ? (function (e) { const t = e.x; const i = e.y; const s = window.devicePixelRatio || 1; return { x: tt(t * s) / s || 0, y: tt(i * s) / s || 0 } }({ x: p, y: f })) : { x: p, y: f }; return p = T.x, f = T.y, c ? Object.assign({}, k, ((C = {})[w] = v ? '0' : '', C[y] = b ? '0' : '', C.transform = (_.devicePixelRatio || 1) <= 1 ? 'translate(' + p + 'px, ' + f + 'px)' : 'translate3d(' + p + 'px, ' + f + 'px, 0)', C)) : Object.assign({}, k, ((t = {})[w] = v ? f + 'px' : '', t[y] = b ? p + 'px' : '', t.transform = '', t)) } const _t = { name: 'computeStyles', enabled: !0, phase: 'beforeWrite', fn: function (e) { const t = e.state; const i = e.options; const s = i.gpuAcceleration; const n = void 0 === s || s; const r = i.adaptive; const o = void 0 === r || r; const a = i.roundOffsets; const c = void 0 === a || a; if (process.env.NODE_ENV !== 'production') { const l = at(t.elements.popper).transitionProperty || ''; o && ['transform', 'top', 'right', 'bottom', 'left'].some(function (e) { return l.indexOf(e) >= 0 }) && console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' ')) } const h = { placement: Je(t.placement), variation: vt(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: n, isFixed: t.options.strategy === 'fixed' }; t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, wt(Object.assign({}, h, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: c })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, wt(Object.assign({}, h, { offsets: t.modifiersData.arrow, position: 'absolute', adaptive: !1, roundOffsets: c })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-placement': t.placement }) }, data: {} }; const Et = { passive: !0 }; const St = { name: 'eventListeners', enabled: !0, phase: 'write', fn: function () {}, effect: function (e) { const t = e.state; const i = e.instance; const s = e.options; const n = s.scroll; const r = void 0 === n || n; const o = s.resize; const a = void 0 === o || o; const c = ze(t.elements.popper); const l = [].concat(t.scrollParents.reference, t.scrollParents.popper); return r && l.forEach(function (e) { e.addEventListener('scroll', i.update, Et) }), a && c.addEventListener('resize', i.update, Et), function () { r && l.forEach(function (e) { e.removeEventListener('scroll', i.update, Et) }), a && c.removeEventListener('resize', i.update, Et) } }, data: {} }; const At = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; function Ct (e) { return e.replace(/left|right|bottom|top/g, function (e) { return At[e] }) } const kt = { start: 'end', end: 'start' }; function Tt (e) { return e.replace(/start|end/g, function (e) { return kt[e] }) } function Lt (e) { const t = ze(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function Ot (e) { return nt(lt(e)).left + Lt(e).scrollLeft } function Pt (e) { const t = at(e); const i = t.overflow; const s = t.overflowX; const n = t.overflowY; return /auto|scroll|overlay|hidden/.test(i + n + s) } function Mt (e) { return ['html', 'body', '#document'].indexOf(Ke(e)) >= 0 ? e.ownerDocument.body : Ge(e) && Pt(e) ? e : Mt(ht(e)) } function xt (e, t) { let i; void 0 === t && (t = []); const s = Mt(e); const n = s === ((i = e.ownerDocument) == null ? void 0 : i.body); const r = ze(s); const o = n ? [r].concat(r.visualViewport || [], Pt(s) ? s : []) : s; const a = t.concat(o); return n ? a : a.concat(xt(ht(o))) } function It (e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Rt (e, t, i) { return t === 'viewport' ? It(function (e, t) { const i = ze(e); const s = lt(e); const n = i.visualViewport; let r = s.clientWidth; let o = s.clientHeight; let a = 0; let c = 0; if (n) { r = n.width, o = n.height; const l = st(); (l || !l && t === 'fixed') && (a = n.offsetLeft, c = n.offsetTop) } return { width: r, height: o, x: a + Ot(e), y: c } }(e, i)) : Qe(t) ? (function (e, t) { const i = nt(e, !1, t === 'fixed'); return i.top = i.top + e.clientTop, i.left = i.left + e.clientLeft, i.bottom = i.top + e.clientHeight, i.right = i.left + e.clientWidth, i.width = e.clientWidth, i.height = e.clientHeight, i.x = i.left, i.y = i.top, i }(t, i)) : It(function (e) { let t; const i = lt(e); const s = Lt(e); const n = (t = e.ownerDocument) == null ? void 0 : t.body; const r = Ze(i.scrollWidth, i.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0); const o = Ze(i.scrollHeight, i.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0); let a = -s.scrollLeft + Ot(e); const c = -s.scrollTop; return at(n || i).direction === 'rtl' && (a += Ze(i.clientWidth, n ? n.clientWidth : 0) - r), { width: r, height: o, x: a, y: c } }(lt(e))) } function Nt (e, t, i, s) { const n = t === 'clippingParents' ? (function (e) { const t = xt(ht(e)); const i = ['absolute', 'fixed'].indexOf(at(e).position) >= 0 && Ge(e) ? ut(e) : e; return Qe(i) ? t.filter(function (e) { return Qe(e) && ot(e, i) && Ke(e) !== 'body' }) : [] }(e)) : [].concat(t); const r = [].concat(n, [i]); const o = r[0]; const a = r.reduce(function (t, i) { const n = Rt(e, i, s); return t.top = Ze(n.top, t.top), t.right = et(n.right, t.right), t.bottom = et(n.bottom, t.bottom), t.left = Ze(n.left, t.left), t }, Rt(e, o, s)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function Ft (e) { let t; const i = e.reference; const s = e.element; const n = e.placement; const r = n ? Je(n) : null; const o = n ? vt(n) : null; const a = i.x + i.width / 2 - s.width / 2; const c = i.y + i.height / 2 - s.height / 2; switch (r) { case De:t = { x: a, y: i.y - s.height }; break; case Be:t = { x: a, y: i.y + i.height }; break; case je:t = { x: i.x + i.width, y: c }; break; case qe:t = { x: i.x - s.width, y: c }; break; default:t = { x: i.x, y: i.y } } const l = r ? pt(r) : null; if (l != null) { const h = l === 'y' ? 'height' : 'width'; switch (o) { case 'start':t[l] = t[l] - (i[h] / 2 - s[h] / 2); break; case Ve:t[l] = t[l] + (i[h] / 2 - s[h] / 2) } } return t } function Dt (e, t) { void 0 === t && (t = {}); const i = t; const s = i.placement; const n = void 0 === s ? e.placement : s; const r = i.strategy; const o = void 0 === r ? e.strategy : r; const a = i.boundary; const c = void 0 === a ? 'clippingParents' : a; const l = i.rootBoundary; const h = void 0 === l ? 'viewport' : l; const d = i.elementContext; const u = void 0 === d ? 'popper' : d; const p = i.altBoundary; const m = void 0 !== p && p; const f = i.padding; const g = void 0 === f ? 0 : f; const b = ft(typeof g !== 'number' ? g : gt(g, He)); const v = u === 'popper' ? 'reference' : 'popper'; const y = e.rects.popper; const w = e.elements[m ? v : u]; const _ = Nt(Qe(w) ? w : w.contextElement || lt(e.elements.popper), c, h, o); const E = nt(e.elements.reference); const S = Ft({ reference: E, element: y, strategy: 'absolute', placement: n }); const A = It(Object.assign({}, y, S)); const C = u === 'popper' ? A : E; const k = { top: _.top - C.top + b.top, bottom: C.bottom - _.bottom + b.bottom, left: _.left - C.left + b.left, right: C.right - _.right + b.right }; const T = e.modifiersData.offset; if (u === 'popper' && T) { const L = T[n]; Object.keys(k).forEach(function (e) { const t = [je, Be].indexOf(e) >= 0 ? 1 : -1; const i = [De, Be].indexOf(e) >= 0 ? 'y' : 'x'; k[e] += L[i] * t }) } return k } function Bt (e, t) { void 0 === t && (t = {}); const i = t; const s = i.placement; const n = i.boundary; const r = i.rootBoundary; const o = i.padding; const a = i.flipVariations; const c = i.allowedAutoPlacements; const l = void 0 === c ? We : c; const h = vt(s); const d = h ? a ? $e : $e.filter(function (e) { return vt(e) === h }) : He; let u = d.filter(function (e) { return l.indexOf(e) >= 0 }); u.length === 0 && (u = d, process.env.NODE_ENV !== 'production' && console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '))); const p = u.reduce(function (t, i) { return t[i] = Dt(e, { placement: i, boundary: n, rootBoundary: r, padding: o })[Je(i)], t }, {}); return Object.keys(p).sort(function (e, t) { return p[e] - p[t] }) } const jt = { name: 'flip', enabled: !0, phase: 'main', fn: function (e) { const t = e.state; const i = e.options; const s = e.name; if (!t.modifiersData[s]._skip) { for (var n = i.mainAxis, r = void 0 === n || n, o = i.altAxis, a = void 0 === o || o, c = i.fallbackPlacements, l = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, p = i.flipVariations, m = void 0 === p || p, f = i.allowedAutoPlacements, g = t.options.placement, b = Je(g), v = c || (b === g || !m ? [Ct(g)] : (function (e) { if (Je(e) === 'auto') return []; const t = Ct(e); return [Tt(e), t, Tt(t)] }(g))), y = [g].concat(v).reduce(function (e, i) { return e.concat(Je(i) === 'auto' ? Bt(t, { placement: i, boundary: h, rootBoundary: d, padding: l, flipVariations: m, allowedAutoPlacements: f }) : i) }, []), w = t.rects.reference, _ = t.rects.popper, E = new Map(), S = !0, A = y[0], C = 0; C < y.length; C++) { const k = y[C]; const T = Je(k); const L = vt(k) === 'start'; const O = [De, Be].indexOf(T) >= 0; const P = O ? 'width' : 'height'; const M = Dt(t, { placement: k, boundary: h, rootBoundary: d, altBoundary: u, padding: l }); let x = O ? L ? je : qe : L ? Be : De; w[P] > _[P] && (x = Ct(x)); const I = Ct(x); const R = []; if (r && R.push(M[T] <= 0), a && R.push(M[x] <= 0, M[I] <= 0), R.every(function (e) { return e })) { A = k, S = !1; break }E.set(k, R) } if (S) for (let N = function (e) { const t = y.find(function (t) { const i = E.get(t); if (i) return i.slice(0, e).every(function (e) { return e }) }); if (t) return A = t, 'break' }, F = m ? 3 : 1; F > 0; F--) { if (N(F) === 'break') break }t.placement !== A && (t.modifiersData[s]._skip = !0, t.placement = A, t.reset = !0) } }, requiresIfExists: ['offset'], data: { _skip: !1 } }; function qt (e, t, i) { return void 0 === i && (i = { x: 0, y: 0 }), { top: e.top - t.height - i.y, right: e.right - t.width + i.x, bottom: e.bottom - t.height + i.y, left: e.left - t.width - i.x } } function Ht (e) { return [De, je, Be, qe].some(function (t) { return e[t] >= 0 }) } const Vt = { name: 'hide', enabled: !0, phase: 'main', requiresIfExists: ['preventOverflow'], fn: function (e) { const t = e.state; const i = e.name; const s = t.rects.reference; const n = t.rects.popper; const r = t.modifiersData.preventOverflow; const o = Dt(t, { elementContext: 'reference' }); const a = Dt(t, { altBoundary: !0 }); const c = qt(o, s); const l = qt(a, n, r); const h = Ht(c); const d = Ht(l); t.modifiersData[i] = { referenceClippingOffsets: c, popperEscapeOffsets: l, isReferenceHidden: h, hasPopperEscaped: d }, t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-reference-hidden': h, 'data-popper-escaped': d }) } }; const $t = { name: 'offset', enabled: !0, phase: 'main', requires: ['popperOffsets'], fn: function (e) { const t = e.state; const i = e.options; const s = e.name; const n = i.offset; const r = void 0 === n ? [0, 0] : n; const o = We.reduce(function (e, i) { return e[i] = (function (e, t, i) { const s = Je(e); const n = [qe, De].indexOf(s) >= 0 ? -1 : 1; const r = typeof i === 'function' ? i(Object.assign({}, t, { placement: e })) : i; let o = r[0]; let a = r[1]; return o = o || 0, a = (a || 0) * n, [qe, je].indexOf(s) >= 0 ? { x: a, y: o } : { x: o, y: a } }(i, t.rects, r)), e }, {}); const a = o[t.placement]; const c = a.x; const l = a.y; t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c, t.modifiersData.popperOffsets.y += l), t.modifiersData[s] = o } }; const Wt = { name: 'popperOffsets', enabled: !0, phase: 'read', fn: function (e) { const t = e.state; const i = e.name; t.modifiersData[i] = Ft({ reference: t.rects.reference, element: t.rects.popper, strategy: 'absolute', placement: t.placement }) }, data: {} }; const Ut = { name: 'preventOverflow', enabled: !0, phase: 'main', fn: function (e) { const t = e.state; const i = e.options; const s = e.name; const n = i.mainAxis; const r = void 0 === n || n; const o = i.altAxis; const a = void 0 !== o && o; const c = i.boundary; const l = i.rootBoundary; const h = i.altBoundary; const d = i.padding; const u = i.tether; const p = void 0 === u || u; const m = i.tetherOffset; const f = void 0 === m ? 0 : m; const g = Dt(t, { boundary: c, rootBoundary: l, padding: d, altBoundary: h }); const b = Je(t.placement); const v = vt(t.placement); const y = !v; const w = pt(b); const _ = w === 'x' ? 'y' : 'x'; const E = t.modifiersData.popperOffsets; const S = t.rects.reference; const A = t.rects.popper; const C = typeof f === 'function' ? f(Object.assign({}, t.rects, { placement: t.placement })) : f; const k = typeof C === 'number' ? { mainAxis: C, altAxis: C } : Object.assign({ mainAxis: 0, altAxis: 0 }, C); const T = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null; const L = { x: 0, y: 0 }; if (E) { if (r) { let O; const P = w === 'y' ? De : qe; const M = w === 'y' ? Be : je; const x = w === 'y' ? 'height' : 'width'; const I = E[w]; const R = I + g[P]; const N = I - g[M]; const F = p ? -A[x] / 2 : 0; const D = v === 'start' ? S[x] : A[x]; const B = v === 'start' ? -A[x] : -S[x]; const j = t.elements.arrow; const q = p && j ? rt(j) : { width: 0, height: 0 }; const H = t.modifiersData['arrow#persistent'] ? t.modifiersData['arrow#persistent'].padding : { top: 0, right: 0, bottom: 0, left: 0 }; const V = H[P]; const $ = H[M]; const W = mt(0, S[x], q[x]); const U = y ? S[x] / 2 - F - W - V - k.mainAxis : D - W - V - k.mainAxis; const K = y ? -S[x] / 2 + F + W + $ + k.mainAxis : B + W + $ + k.mainAxis; const z = t.elements.arrow && ut(t.elements.arrow); const Q = z ? w === 'y' ? z.clientTop || 0 : z.clientLeft || 0 : 0; const G = (O = T == null ? void 0 : T[w]) != null ? O : 0; const Y = I + K - G; const X = mt(p ? et(R, I + U - G - Q) : R, I, p ? Ze(N, Y) : N); E[w] = X, L[w] = X - I } if (a) { let J; const Z = w === 'x' ? De : qe; const ee = w === 'x' ? Be : je; const te = E[_]; const ie = _ === 'y' ? 'height' : 'width'; const se = te + g[Z]; const ne = te - g[ee]; const re = [De, qe].indexOf(b) !== -1; const oe = (J = T == null ? void 0 : T[_]) != null ? J : 0; const ae = re ? se : te - S[ie] - A[ie] - oe + k.altAxis; const ce = re ? te + S[ie] + A[ie] - oe - k.altAxis : ne; const le = p && re ? (function (e, t, i) { const s = mt(e, t, i); return s > i ? i : s }(ae, te, ce)) : mt(p ? ae : se, te, p ? ce : ne); E[_] = le, L[_] = le - te }t.modifiersData[s] = L } }, requiresIfExists: ['offset'] }; function Kt (e, t, i) { void 0 === i && (i = !1); let s; let n; const r = Ge(t); const o = Ge(t) && (function (e) { const t = e.getBoundingClientRect(); const i = tt(t.width) / e.offsetWidth || 1; const s = tt(t.height) / e.offsetHeight || 1; return i !== 1 || s !== 1 }(t)); const a = lt(t); const c = nt(e, o, i); let l = { scrollLeft: 0, scrollTop: 0 }; let h = { x: 0, y: 0 }; return (r || !r && !i) && ((Ke(t) !== 'body' || Pt(a)) && (l = (s = t) !== ze(s) && Ge(s) ? { scrollLeft: (n = s).scrollLeft, scrollTop: n.scrollTop } : Lt(s)), Ge(t) ? ((h = nt(t, !0)).x += t.clientLeft, h.y += t.clientTop) : a && (h.x = Ot(a))), { x: c.left + l.scrollLeft - h.x, y: c.top + l.scrollTop - h.y, width: c.width, height: c.height } } function zt (e) { const t = new Map(); const i = new Set(); const s = []; function n (e) { i.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) { if (!i.has(e)) { const s = t.get(e); s && n(s) } }), s.push(e) } return e.forEach(function (e) { t.set(e.name, e) }), e.forEach(function (e) { i.has(e.name) || n(e) }), s } function Qt (e) { for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)i[s - 1] = arguments[s]; return [].concat(i).reduce(function (e, t) { return e.replace(/%s/, t) }, e) } const Gt = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s'; const Yt = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options']; const Xt = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.'; const Jt = { placement: 'bottom', modifiers: [], strategy: 'absolute' }; function Zt () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return !t.some(function (e) { return !(e && typeof e.getBoundingClientRect === 'function') }) } function ei (e) { void 0 === e && (e = {}); const t = e; const i = t.defaultModifiers; const s = void 0 === i ? [] : i; const n = t.defaultOptions; const r = void 0 === n ? Jt : n; return function (e, t, i) { void 0 === i && (i = r); let n; let o; let a = { placement: 'bottom', orderedModifiers: [], options: Object.assign({}, Jt, r), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }; let c = []; let l = !1; var h = { state: a, setOptions: function (i) { const n = typeof i === 'function' ? i(a.options) : i; d(), a.options = Object.assign({}, r, a.options, n), a.scrollParents = { reference: Qe(e) ? xt(e) : e.contextElement ? xt(e.contextElement) : [], popper: xt(t) }; let o; let l; let u; const p = (function (e) { const t = zt(e); return Ue.reduce(function (e, i) { return e.concat(t.filter(function (e) { return e.phase === i })) }, []) }(function (e) { const t = e.reduce(function (e, t) { const i = e[t.name]; return e[t.name] = i ? Object.assign({}, i, t, { options: Object.assign({}, i.options, t.options), data: Object.assign({}, i.data, t.data) }) : t, e }, {}); return Object.keys(t).map(function (e) { return t[e] }) }([].concat(s, a.options.modifiers)))); if (a.orderedModifiers = p.filter(function (e) { return e.enabled }), process.env.NODE_ENV !== 'production') { if ((function (e) { e.forEach(function (t) { [].concat(Object.keys(t), Yt).filter(function (e, t, i) { return i.indexOf(e) === t }).forEach(function (i) { switch (i) { case 'name':typeof t.name !== 'string' && console.error(Qt(Gt, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"')); break; case 'enabled':typeof t.enabled !== 'boolean' && console.error(Qt(Gt, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"')); break; case 'phase':Ue.indexOf(t.phase) < 0 && console.error(Qt(Gt, t.name, '"phase"', 'either ' + Ue.join(', '), '"' + String(t.phase) + '"')); break; case 'fn':typeof t.fn !== 'function' && console.error(Qt(Gt, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"')); break; case 'effect':t.effect != null && typeof t.effect !== 'function' && console.error(Qt(Gt, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"')); break; case 'requires':t.requires == null || Array.isArray(t.requires) || console.error(Qt(Gt, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"')); break; case 'requiresIfExists':Array.isArray(t.requiresIfExists) || console.error(Qt(Gt, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"')); break; case 'options':case 'data':break; default:console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + Yt.map(function (e) { return '"' + e + '"' }).join(', ') + '; but "' + i + '" was provided.') }t.requires && t.requires.forEach(function (i) { e.find(function (e) { return e.name === i }) == null && console.error(Qt('Popper: modifier "%s" requires "%s", but "%s" modifier is not available', String(t.name), i, i)) }) }) }) }((o = [].concat(p, a.options.modifiers), l = function (e) { return e.name }, u = new Set(), o.filter(function (e) { const t = l(e); if (!u.has(t)) return u.add(t), !0 })))), Je(a.options.placement) === 'auto')a.orderedModifiers.find(function (e) { return e.name === 'flip' }) || console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' ')); const m = at(t); [m.marginTop, m.marginRight, m.marginBottom, m.marginLeft].some(function (e) { return parseFloat(e) }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' ')) } return a.orderedModifiers.forEach(function (e) { const t = e.name; const i = e.options; const s = void 0 === i ? {} : i; const n = e.effect; if (typeof n === 'function') { const r = n({ state: a, name: t, instance: h, options: s }); const o = function () {}; c.push(r || o) } }), h.update() }, forceUpdate: function () { if (!l) { const e = a.elements; const t = e.reference; const i = e.popper; if (Zt(t, i)) { a.rects = { reference: Kt(t, ut(i), a.options.strategy === 'fixed'), popper: rt(i) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (e) { return a.modifiersData[e.name] = Object.assign({}, e.data) }); for (let s = 0, n = 0; n < a.orderedModifiers.length; n++) { if (process.env.NODE_ENV !== 'production' && (s += 1) > 100) { console.error('Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.'); break } if (!0 !== a.reset) { const r = a.orderedModifiers[n]; const o = r.fn; const c = r.options; const d = void 0 === c ? {} : c; const u = r.name; typeof o === 'function' && (a = o({ state: a, options: d, name: u, instance: h }) || a) } else a.reset = !1, n = -1 } } else process.env.NODE_ENV !== 'production' && console.error(Xt) } }, update: (n = function () { return new Promise(function (e) { h.forceUpdate(), e(a) }) }, function () { return o || (o = new Promise(function (e) { Promise.resolve().then(function () { o = void 0, e(n()) }) })), o }), destroy: function () { d(), l = !0 } }; if (!Zt(e, t)) return process.env.NODE_ENV !== 'production' && console.error(Xt), h; function d () { c.forEach(function (e) { return e() }), c = [] } return h.setOptions(i).then(function (e) { !l && i.onFirstUpdate && i.onFirstUpdate(e) }), h } } const ti = ei(); const ii = ei({ defaultModifiers: [St, Wt, _t, Xe] }); const si = ei({ defaultModifiers: [St, Wt, _t, Xe, $t, jt, Ut, bt, Vt] }); const ni = Object.freeze({ __proto__: null, popperGenerator: ei, detectOverflow: Dt, createPopperBase: ti, createPopper: si, createPopperLite: ii, top: De, bottom: Be, right: je, left: qe, auto: 'auto', basePlacements: He, start: 'start', end: Ve, clippingParents: 'clippingParents', viewport: 'viewport', popper: 'popper', reference: 'reference', variationPlacements: $e, placements: We, beforeRead: 'beforeRead', read: 'read', afterRead: 'afterRead', beforeMain: 'beforeMain', main: 'main', afterMain: 'afterMain', beforeWrite: 'beforeWrite', write: 'write', afterWrite: 'afterWrite', modifierPhases: Ue, applyStyles: Xe, arrow: bt, computeStyles: _t, eventListeners: St, flip: jt, hide: Vt, offset: $t, popperOffsets: Wt, preventOverflow: Ut })
/*!
  * Bootstrap v5.2.2 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
const ri = e => { let t = e.getAttribute('data-bs-target'); if (!t || t === '#') { let i = e.getAttribute('href'); if (!i || !i.includes('#') && !i.startsWith('.')) return null; i.includes('#') && !i.startsWith('#') && (i = `#${i.split('#')[1]}`), t = i && i !== '#' ? i.trim() : null } return t }; const oi = e => { const t = ri(e); return t && document.querySelector(t) ? t : null }; const ai = e => { const t = ri(e); return t ? document.querySelector(t) : null }; const ci = e => { e.dispatchEvent(new Event('transitionend')) }; const li = e => !(!e || typeof e !== 'object') && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType); const hi = e => li(e) ? e.jquery ? e[0] : e : typeof e === 'string' && e.length > 0 ? document.querySelector(e) : null; const di = e => { if (!li(e) || e.getClientRects().length === 0) return !1; const t = getComputedStyle(e).getPropertyValue('visibility') === 'visible'; const i = e.closest('details:not([open])'); if (!i) return t; if (i !== e) { const t = e.closest('summary'); if (t && t.parentNode !== i) return !1; if (t === null) return !1 } return t }; const ui = e => !e || e.nodeType !== Node.ELEMENT_NODE || (!!e.classList.contains('disabled') || (void 0 !== e.disabled ? e.disabled : e.hasAttribute('disabled') && e.getAttribute('disabled') !== 'false')); const pi = e => { if (!document.documentElement.attachShadow) return null; if (typeof e.getRootNode === 'function') { const t = e.getRootNode(); return t instanceof ShadowRoot ? t : null } return e instanceof ShadowRoot ? e : e.parentNode ? pi(e.parentNode) : null }; const mi = () => {}; const fi = e => { e.offsetHeight }; const gi = () => window.jQuery && !document.body.hasAttribute('data-bs-no-jquery') ? window.jQuery : null; const bi = []; const vi = () => document.documentElement.dir === 'rtl'; const yi = e => { let t; t = () => { const t = gi(); if (t) { const i = e.NAME; const s = t.fn[i]; t.fn[i] = e.jQueryInterface, t.fn[i].Constructor = e, t.fn[i].noConflict = () => (t.fn[i] = s, e.jQueryInterface) } }, document.readyState === 'loading' ? (bi.length || document.addEventListener('DOMContentLoaded', () => { for (const e of bi)e() }), bi.push(t)) : t() }; const wi = e => { typeof e === 'function' && e() }; const _i = (e, t, i = !0) => { if (!i) return void wi(e); const s = (e => { if (!e) return 0; let { transitionDuration: t, transitionDelay: i } = window.getComputedStyle(e); const s = Number.parseFloat(t); const n = Number.parseFloat(i); return s || n ? (t = t.split(',')[0], i = i.split(',')[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(i))) : 0 })(t) + 5; let n = !1; const r = ({ target: i }) => { i === t && (n = !0, t.removeEventListener('transitionend', r), wi(e)) }; t.addEventListener('transitionend', r), setTimeout(() => { n || ci(t) }, s) }; const Ei = (e, t, i, s) => { const n = e.length; let r = e.indexOf(t); return r === -1 ? !i && s ? e[n - 1] : e[0] : (r += i ? 1 : -1, s && (r = (r + n) % n), e[Math.max(0, Math.min(r, n - 1))]) }; const Si = /[^.]*(?=\..*)\.|.*/; const Ai = /\..*/; const Ci = /::\d+$/; const ki = {}; let Ti = 1; const Li = { mouseenter: 'mouseover', mouseleave: 'mouseout' }; const Oi = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']); function Pi (e, t) { return t && `${t}::${Ti++}` || e.uidEvent || Ti++ } function Mi (e) { const t = Pi(e); return e.uidEvent = t, ki[t] = ki[t] || {}, ki[t] } function xi (e, t, i = null) { return Object.values(e).find(e => e.callable === t && e.delegationSelector === i) } function Ii (e, t, i) { const s = typeof t === 'string'; const n = s ? i : t || i; let r = Di(e); return Oi.has(r) || (r = e), [s, n, r] } function Ri (e, t, i, s, n) { if (typeof t !== 'string' || !e) return; let [r, o, a] = Ii(t, i, s); if (t in Li) { const e = e => function (t) { if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t) }; o = e(o) } const c = Mi(e); const l = c[a] || (c[a] = {}); const h = xi(l, o, r ? i : null); if (h) return void (h.oneOff = h.oneOff && n); const d = Pi(o, t.replace(Si, '')); const u = r ? (function (e, t, i) { return function s (n) { const r = e.querySelectorAll(t); for (let { target: o } = n; o && o !== this; o = o.parentNode) for (const a of r) if (a === o) return ji(n, { delegateTarget: o }), s.oneOff && Bi.off(e, n.type, t, i), i.apply(o, [n]) } }(e, i, o)) : (function (e, t) { return function i (s) { return ji(s, { delegateTarget: e }), i.oneOff && Bi.off(e, s.type, t), t.apply(e, [s]) } }(e, o)); u.delegationSelector = r ? i : null, u.callable = o, u.oneOff = n, u.uidEvent = d, l[d] = u, e.addEventListener(a, u, r) } function Ni (e, t, i, s, n) { const r = xi(t[i], s, n); r && (e.removeEventListener(i, r, Boolean(n)), delete t[i][r.uidEvent]) } function Fi (e, t, i, s) { const n = t[i] || {}; for (const r of Object.keys(n)) if (r.includes(s)) { const s = n[r]; Ni(e, t, i, s.callable, s.delegationSelector) } } function Di (e) { return e = e.replace(Ai, ''), Li[e] || e } const Bi = { on (e, t, i, s) { Ri(e, t, i, s, !1) }, one (e, t, i, s) { Ri(e, t, i, s, !0) }, off (e, t, i, s) { if (typeof t !== 'string' || !e) return; const [n, r, o] = Ii(t, i, s); const a = o !== t; const c = Mi(e); const l = c[o] || {}; const h = t.startsWith('.'); if (void 0 === r) { if (h) for (const i of Object.keys(c))Fi(e, c, i, t.slice(1)); for (const i of Object.keys(l)) { const s = i.replace(Ci, ''); if (!a || t.includes(s)) { const t = l[i]; Ni(e, c, o, t.callable, t.delegationSelector) } } } else { if (!Object.keys(l).length) return; Ni(e, c, o, r, n ? i : null) } }, trigger (e, t, i) { if (typeof t !== 'string' || !e) return null; const s = gi(); let n = null; let r = !0; let o = !0; let a = !1; t !== Di(t) && s && (n = s.Event(t, i), s(e).trigger(n), r = !n.isPropagationStopped(), o = !n.isImmediatePropagationStopped(), a = n.isDefaultPrevented()); let c = new Event(t, { bubbles: r, cancelable: !0 }); return c = ji(c, i), a && c.preventDefault(), o && e.dispatchEvent(c), c.defaultPrevented && n && n.preventDefault(), c } }; function ji (e, t) { for (const [i, s] of Object.entries(t || {})) try { e[i] = s } catch (t) { Object.defineProperty(e, i, { configurable: !0, get: () => s }) } return e } const qi = new Map(); const Hi = { set (e, t, i) { qi.has(e) || qi.set(e, new Map()); const s = qi.get(e); s.has(t) || s.size === 0 ? s.set(t, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`) }, get: (e, t) => qi.has(e) && qi.get(e).get(t) || null, remove (e, t) { if (!qi.has(e)) return; const i = qi.get(e); i.delete(t), i.size === 0 && qi.delete(e) } }; function Vi (e) { if (e === 'true') return !0; if (e === 'false') return !1; if (e === Number(e).toString()) return Number(e); if (e === '' || e === 'null') return null; if (typeof e !== 'string') return e; try { return JSON.parse(decodeURIComponent(e)) } catch (t) { return e } } function $i (e) { return e.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`) } const Wi = { setDataAttribute (e, t, i) { e.setAttribute(`data-bs-${$i(t)}`, i) }, removeDataAttribute (e, t) { e.removeAttribute(`data-bs-${$i(t)}`) }, getDataAttributes (e) { if (!e) return {}; const t = {}; const i = Object.keys(e.dataset).filter(e => e.startsWith('bs') && !e.startsWith('bsConfig')); for (const s of i) { let i = s.replace(/^bs/, ''); i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Vi(e.dataset[s]) } return t }, getDataAttribute: (e, t) => Vi(e.getAttribute(`data-bs-${$i(t)}`)) }; class Ui {static get Default () { return {} } static get DefaultType () { return {} } static get NAME () { throw new Error('You have to implement the static method "NAME", for each component!') }_getConfig (e) { return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e }_configAfterMerge (e) { return e }_mergeConfigObj (e, t) { const i = li(t) ? Wi.getDataAttribute(t, 'config') : {}; return { ...this.constructor.Default, ...typeof i === 'object' ? i : {}, ...li(t) ? Wi.getDataAttributes(t) : {}, ...typeof e === 'object' ? e : {} } }_typeCheckConfig (e, t = this.constructor.DefaultType) { for (const s of Object.keys(t)) { const n = t[s]; const r = e[s]; const o = li(r) ? 'element' : (i = r) == null ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(n).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${n}".`) } let i }} class Ki extends Ui {constructor (e, t) { super(), (e = hi(e)) && (this._element = e, this._config = this._getConfig(t), Hi.set(this._element, this.constructor.DATA_KEY, this)) }dispose () { Hi.remove(this._element, this.constructor.DATA_KEY), Bi.off(this._element, this.constructor.EVENT_KEY); for (const e of Object.getOwnPropertyNames(this)) this[e] = null }_queueCallback (e, t, i = !0) { _i(e, t, i) }_getConfig (e) { return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } static getInstance (e) { return Hi.get(hi(e), this.DATA_KEY) } static getOrCreateInstance (e, t = {}) { return this.getInstance(e) || new this(e, typeof t === 'object' ? t : null) } static get VERSION () { return '5.2.2' } static get DATA_KEY () { return `bs.${this.NAME}` } static get EVENT_KEY () { return `.${this.DATA_KEY}` } static eventName (e) { return `${e}${this.EVENT_KEY}` }} const zi = (e, t = 'hide') => { const i = `click.dismiss${e.EVENT_KEY}`; const s = e.NAME; Bi.on(document, i, `[data-bs-dismiss="${s}"]`, function (i) { if (['A', 'AREA'].includes(this.tagName) && i.preventDefault(), ui(this)) return; const n = ai(this) || this.closest(`.${s}`); e.getOrCreateInstance(n)[t]() }) }; class Qi extends Ki {static get NAME () { return 'alert' }close () { if (Bi.trigger(this._element, 'close.bs.alert').defaultPrevented) return; this._element.classList.remove('show'); const e = this._element.classList.contains('fade'); this._queueCallback(() => this._destroyElement(), this._element, e) }_destroyElement () { this._element.remove(), Bi.trigger(this._element, 'closed.bs.alert'), this.dispose() } static jQueryInterface (e) { return this.each(function () { const t = Qi.getOrCreateInstance(this); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}zi(Qi, 'close'), yi(Qi); class Gi extends Ki {static get NAME () { return 'button' }toggle () { this._element.setAttribute('aria-pressed', this._element.classList.toggle('active')) } static jQueryInterface (e) { return this.each(function () { const t = Gi.getOrCreateInstance(this); e === 'toggle' && t[e]() }) }}Bi.on(document, 'click.bs.button.data-api', '[data-bs-toggle="button"]', e => { e.preventDefault(); const t = e.target.closest('[data-bs-toggle="button"]'); Gi.getOrCreateInstance(t).toggle() }), yi(Gi); const Yi = { find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)), findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e), children: (e, t) => [].concat(...e.children).filter(e => e.matches(t)), parents (e, t) { const i = []; let s = e.parentNode.closest(t); for (;s;)i.push(s), s = s.parentNode.closest(t); return i }, prev (e, t) { let i = e.previousElementSibling; for (;i;) { if (i.matches(t)) return [i]; i = i.previousElementSibling } return [] }, next (e, t) { let i = e.nextElementSibling; for (;i;) { if (i.matches(t)) return [i]; i = i.nextElementSibling } return [] }, focusableChildren (e) { const t = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(e => `${e}:not([tabindex^="-"])`).join(','); return this.find(t, e).filter(e => !ui(e) && di(e)) } }; const Xi = { endCallback: null, leftCallback: null, rightCallback: null }; const Ji = { endCallback: '(function|null)', leftCallback: '(function|null)', rightCallback: '(function|null)' }; class Zi extends Ui {constructor (e, t) { super(), this._element = e, e && Zi.isSupported() && (this._config = this._getConfig(t), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents()) } static get Default () { return Xi } static get DefaultType () { return Ji } static get NAME () { return 'swipe' }dispose () { Bi.off(this._element, '.bs.swipe') }_start (e) { this._supportPointerEvents ? this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) : this._deltaX = e.touches[0].clientX }_end (e) { this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), wi(this._config.endCallback) }_move (e) { this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX }_handleSwipe () { const e = Math.abs(this._deltaX); if (e <= 40) return; const t = e / this._deltaX; this._deltaX = 0, t && wi(t > 0 ? this._config.rightCallback : this._config.leftCallback) }_initEvents () { this._supportPointerEvents ? (Bi.on(this._element, 'pointerdown.bs.swipe', e => this._start(e)), Bi.on(this._element, 'pointerup.bs.swipe', e => this._end(e)), this._element.classList.add('pointer-event')) : (Bi.on(this._element, 'touchstart.bs.swipe', e => this._start(e)), Bi.on(this._element, 'touchmove.bs.swipe', e => this._move(e)), Bi.on(this._element, 'touchend.bs.swipe', e => this._end(e))) }_eventIsPointerPenTouch (e) { return this._supportPointerEvents && (e.pointerType === 'pen' || e.pointerType === 'touch') } static isSupported () { return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0 }} const es = { ArrowLeft: 'right', ArrowRight: 'left' }; const ts = { interval: 5e3, keyboard: !0, pause: 'hover', ride: !1, touch: !0, wrap: !0 }; const is = { interval: '(number|boolean)', keyboard: 'boolean', pause: '(string|boolean)', ride: '(boolean|string)', touch: 'boolean', wrap: 'boolean' }; class ss extends Ki {constructor (e, t) { super(e, t), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = Yi.findOne('.carousel-indicators', this._element), this._addEventListeners(), this._config.ride === 'carousel' && this.cycle() } static get Default () { return ts } static get DefaultType () { return is } static get NAME () { return 'carousel' }next () { this._slide('next') }nextWhenVisible () { !document.hidden && di(this._element) && this.next() }prev () { this._slide('prev') }pause () { this._isSliding && ci(this._element), this._clearInterval() }cycle () { this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval) }_maybeEnableCycle () { this._config.ride && (this._isSliding ? Bi.one(this._element, 'slid.bs.carousel', () => this.cycle()) : this.cycle()) }to (e) { const t = this._getItems(); if (e > t.length - 1 || e < 0) return; if (this._isSliding) return void Bi.one(this._element, 'slid.bs.carousel', () => this.to(e)); const i = this._getItemIndex(this._getActive()); if (i === e) return; const s = e > i ? 'next' : 'prev'; this._slide(s, t[e]) }dispose () { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() }_configAfterMerge (e) { return e.defaultInterval = e.interval, e }_addEventListeners () { this._config.keyboard && Bi.on(this._element, 'keydown.bs.carousel', e => this._keydown(e)), this._config.pause === 'hover' && (Bi.on(this._element, 'mouseenter.bs.carousel', () => this.pause()), Bi.on(this._element, 'mouseleave.bs.carousel', () => this._maybeEnableCycle())), this._config.touch && Zi.isSupported() && this._addTouchEventListeners() }_addTouchEventListeners () { for (const e of Yi.find('.carousel-item img', this._element))Bi.on(e, 'dragstart.bs.carousel', e => e.preventDefault()); const e = { leftCallback: () => this._slide(this._directionToOrder('left')), rightCallback: () => this._slide(this._directionToOrder('right')), endCallback: () => { this._config.pause === 'hover' && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval)) } }; this._swipeHelper = new Zi(this._element, e) }_keydown (e) { if (/input|textarea/i.test(e.target.tagName)) return; const t = es[e.key]; t && (e.preventDefault(), this._slide(this._directionToOrder(t))) }_getItemIndex (e) { return this._getItems().indexOf(e) }_setActiveIndicatorElement (e) { if (!this._indicatorsElement) return; const t = Yi.findOne('.active', this._indicatorsElement); t.classList.remove('active'), t.removeAttribute('aria-current'); const i = Yi.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement); i && (i.classList.add('active'), i.setAttribute('aria-current', 'true')) }_updateInterval () { const e = this._activeElement || this._getActive(); if (!e) return; const t = Number.parseInt(e.getAttribute('data-bs-interval'), 10); this._config.interval = t || this._config.defaultInterval }_slide (e, t = null) { if (this._isSliding) return; const i = this._getActive(); const s = e === 'next'; const n = t || Ei(this._getItems(), i, s, this._config.wrap); if (n === i) return; const r = this._getItemIndex(n); const o = t => Bi.trigger(this._element, t, { relatedTarget: n, direction: this._orderToDirection(e), from: this._getItemIndex(i), to: r }); if (o('slide.bs.carousel').defaultPrevented) return; if (!i || !n) return; const a = Boolean(this._interval); this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(r), this._activeElement = n; const c = s ? 'carousel-item-start' : 'carousel-item-end'; const l = s ? 'carousel-item-next' : 'carousel-item-prev'; n.classList.add(l), fi(n), i.classList.add(c), n.classList.add(c); this._queueCallback(() => { n.classList.remove(c, l), n.classList.add('active'), i.classList.remove('active', l, c), this._isSliding = !1, o('slid.bs.carousel') }, i, this._isAnimated()), a && this.cycle() }_isAnimated () { return this._element.classList.contains('slide') }_getActive () { return Yi.findOne('.active.carousel-item', this._element) }_getItems () { return Yi.find('.carousel-item', this._element) }_clearInterval () { this._interval && (clearInterval(this._interval), this._interval = null) }_directionToOrder (e) { return vi() ? e === 'left' ? 'prev' : 'next' : e === 'left' ? 'next' : 'prev' }_orderToDirection (e) { return vi() ? e === 'prev' ? 'left' : 'right' : e === 'prev' ? 'right' : 'left' } static jQueryInterface (e) { return this.each(function () { const t = ss.getOrCreateInstance(this, e); if (typeof e !== 'number') { if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } } else t.to(e) }) }}Bi.on(document, 'click.bs.carousel.data-api', '[data-bs-slide], [data-bs-slide-to]', function (e) { const t = ai(this); if (!t || !t.classList.contains('carousel')) return; e.preventDefault(); const i = ss.getOrCreateInstance(t); const s = this.getAttribute('data-bs-slide-to'); return s ? (i.to(s), void i._maybeEnableCycle()) : Wi.getDataAttribute(this, 'slide') === 'next' ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle()) }), Bi.on(window, 'load.bs.carousel.data-api', () => { const e = Yi.find('[data-bs-ride="carousel"]'); for (const t of e)ss.getOrCreateInstance(t) }), yi(ss); const ns = { parent: null, toggle: !0 }; const rs = { parent: '(null|element)', toggle: 'boolean' }; class os extends Ki {constructor (e, t) { super(e, t), this._isTransitioning = !1, this._triggerArray = []; const i = Yi.find('[data-bs-toggle="collapse"]'); for (const e of i) { const t = oi(e); const i = Yi.find(t).filter(e => e === this._element); t !== null && i.length && this._triggerArray.push(e) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default () { return ns } static get DefaultType () { return rs } static get NAME () { return 'collapse' }toggle () { this._isShown() ? this.hide() : this.show() }show () { if (this._isTransitioning || this._isShown()) return; let e = []; if (this._config.parent && (e = this._getFirstLevelChildren('.collapse.show, .collapse.collapsing').filter(e => e !== this._element).map(e => os.getOrCreateInstance(e, { toggle: !1 }))), e.length && e[0]._isTransitioning) return; if (Bi.trigger(this._element, 'show.bs.collapse').defaultPrevented) return; for (const t of e)t.hide(); const t = this._getDimension(); this._element.classList.remove('collapse'), this._element.classList.add('collapsing'), this._element.style[t] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const i = `scroll${t[0].toUpperCase() + t.slice(1)}`; this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove('collapsing'), this._element.classList.add('collapse', 'show'), this._element.style[t] = '', Bi.trigger(this._element, 'shown.bs.collapse') }, this._element, !0), this._element.style[t] = `${this._element[i]}px` }hide () { if (this._isTransitioning || !this._isShown()) return; if (Bi.trigger(this._element, 'hide.bs.collapse').defaultPrevented) return; const e = this._getDimension(); this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, fi(this._element), this._element.classList.add('collapsing'), this._element.classList.remove('collapse', 'show'); for (const e of this._triggerArray) { const t = ai(e); t && !this._isShown(t) && this._addAriaAndCollapsedClass([e], !1) } this._isTransitioning = !0; this._element.style[e] = '', this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove('collapsing'), this._element.classList.add('collapse'), Bi.trigger(this._element, 'hidden.bs.collapse') }, this._element, !0) }_isShown (e = this._element) { return e.classList.contains('show') }_configAfterMerge (e) { return e.toggle = Boolean(e.toggle), e.parent = hi(e.parent), e }_getDimension () { return this._element.classList.contains('collapse-horizontal') ? 'width' : 'height' }_initializeChildren () { if (!this._config.parent) return; const e = this._getFirstLevelChildren('[data-bs-toggle="collapse"]'); for (const t of e) { const e = ai(t); e && this._addAriaAndCollapsedClass([t], this._isShown(e)) } }_getFirstLevelChildren (e) { const t = Yi.find(':scope .collapse .collapse', this._config.parent); return Yi.find(e, this._config.parent).filter(e => !t.includes(e)) }_addAriaAndCollapsedClass (e, t) { if (e.length) for (const i of e)i.classList.toggle('collapsed', !t), i.setAttribute('aria-expanded', t) } static jQueryInterface (e) { const t = {}; return typeof e === 'string' && /show|hide/.test(e) && (t.toggle = !1), this.each(function () { const i = os.getOrCreateInstance(this, t); if (typeof e === 'string') { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e]() } }) }}Bi.on(document, 'click.bs.collapse.data-api', '[data-bs-toggle="collapse"]', function (e) { (e.target.tagName === 'A' || e.delegateTarget && e.delegateTarget.tagName === 'A') && e.preventDefault(); const t = oi(this); const i = Yi.find(t); for (const e of i)os.getOrCreateInstance(e, { toggle: !1 }).toggle() }), yi(os); const as = 'ArrowUp'; const cs = 'ArrowDown'; const ls = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)'; const hs = `${ls}.show`; const ds = vi() ? 'top-end' : 'top-start'; const us = vi() ? 'top-start' : 'top-end'; const ps = vi() ? 'bottom-end' : 'bottom-start'; const ms = vi() ? 'bottom-start' : 'bottom-end'; const fs = vi() ? 'left-start' : 'right-start'; const gs = vi() ? 'right-start' : 'left-start'; const bs = { autoClose: !0, boundary: 'clippingParents', display: 'dynamic', offset: [0, 2], popperConfig: null, reference: 'toggle' }; const vs = { autoClose: '(boolean|string)', boundary: '(string|element)', display: 'string', offset: '(array|string|function)', popperConfig: '(null|object|function)', reference: '(string|element|object)' }; class ys extends Ki {constructor (e, t) { super(e, t), this._popper = null, this._parent = this._element.parentNode, this._menu = Yi.next(this._element, '.dropdown-menu')[0] || Yi.prev(this._element, '.dropdown-menu')[0] || Yi.findOne('.dropdown-menu', this._parent), this._inNavbar = this._detectNavbar() } static get Default () { return bs } static get DefaultType () { return vs } static get NAME () { return 'dropdown' }toggle () { return this._isShown() ? this.hide() : this.show() }show () { if (ui(this._element) || this._isShown()) return; const e = { relatedTarget: this._element }; if (!Bi.trigger(this._element, 'show.bs.dropdown', e).defaultPrevented) { if (this._createPopper(), 'ontouchstart' in document.documentElement && !this._parent.closest('.navbar-nav')) for (const e of [].concat(...document.body.children))Bi.on(e, 'mouseover', mi); this._element.focus(), this._element.setAttribute('aria-expanded', !0), this._menu.classList.add('show'), this._element.classList.add('show'), Bi.trigger(this._element, 'shown.bs.dropdown', e) } }hide () { if (ui(this._element) || !this._isShown()) return; const e = { relatedTarget: this._element }; this._completeHide(e) }dispose () { this._popper && this._popper.destroy(), super.dispose() }update () { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() }_completeHide (e) { if (!Bi.trigger(this._element, 'hide.bs.dropdown', e).defaultPrevented) { if ('ontouchstart' in document.documentElement) for (const e of [].concat(...document.body.children))Bi.off(e, 'mouseover', mi); this._popper && this._popper.destroy(), this._menu.classList.remove('show'), this._element.classList.remove('show'), this._element.setAttribute('aria-expanded', 'false'), Wi.removeDataAttribute(this._menu, 'popper'), Bi.trigger(this._element, 'hidden.bs.dropdown', e) } }_getConfig (e) { if (typeof (e = super._getConfig(e)).reference === 'object' && !li(e.reference) && typeof e.reference.getBoundingClientRect !== 'function') throw new TypeError(`${'dropdown'.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return e }_createPopper () { if (void 0 === ni) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; this._config.reference === 'parent' ? e = this._parent : li(this._config.reference) ? e = hi(this._config.reference) : typeof this._config.reference === 'object' && (e = this._config.reference); const t = this._getPopperConfig(); this._popper = si(e, this._menu, t) }_isShown () { return this._menu.classList.contains('show') }_getPlacement () { const e = this._parent; if (e.classList.contains('dropend')) return fs; if (e.classList.contains('dropstart')) return gs; if (e.classList.contains('dropup-center')) return 'top'; if (e.classList.contains('dropdown-center')) return 'bottom'; const t = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end'; return e.classList.contains('dropup') ? t ? us : ds : t ? ms : ps }_detectNavbar () { return this._element.closest('.navbar') !== null }_getOffset () { const { offset: e } = this._config; return typeof e === 'string' ? e.split(',').map(e => Number.parseInt(e, 10)) : typeof e === 'function' ? t => e(t, this._element) : e }_getPopperConfig () { const e = { placement: this._getPlacement(), modifiers: [{ name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'offset', options: { offset: this._getOffset() } }] }; return (this._inNavbar || this._config.display === 'static') && (Wi.setDataAttribute(this._menu, 'popper', 'static'), e.modifiers = [{ name: 'applyStyles', enabled: !1 }]), { ...e, ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(e) : this._config.popperConfig } }_selectMenuItem ({ key: e, target: t }) { const i = Yi.find('.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)', this._menu).filter(e => di(e)); i.length && Ei(i, t, e === cs, !i.includes(t)).focus() } static jQueryInterface (e) { return this.each(function () { const t = ys.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } }) } static clearMenus (e) { if (e.button === 2 || e.type === 'keyup' && e.key !== 'Tab') return; const t = Yi.find(hs); for (const i of t) { const t = ys.getInstance(i); if (!t || !1 === t._config.autoClose) continue; const s = e.composedPath(); const n = s.includes(t._menu); if (s.includes(t._element) || t._config.autoClose === 'inside' && !n || t._config.autoClose === 'outside' && n) continue; if (t._menu.contains(e.target) && (e.type === 'keyup' && e.key === 'Tab' || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; const r = { relatedTarget: t._element }; e.type === 'click' && (r.clickEvent = e), t._completeHide(r) } } static dataApiKeydownHandler (e) { const t = /input|textarea/i.test(e.target.tagName); const i = e.key === 'Escape'; const s = [as, cs].includes(e.key); if (!s && !i) return; if (t && !i) return; e.preventDefault(); const n = this.matches(ls) ? this : Yi.prev(this, ls)[0] || Yi.next(this, ls)[0] || Yi.findOne(ls, e.delegateTarget.parentNode); const r = ys.getOrCreateInstance(n); if (s) return e.stopPropagation(), r.show(), void r._selectMenuItem(e); r._isShown() && (e.stopPropagation(), r.hide(), n.focus()) }}Bi.on(document, 'keydown.bs.dropdown.data-api', ls, ys.dataApiKeydownHandler), Bi.on(document, 'keydown.bs.dropdown.data-api', '.dropdown-menu', ys.dataApiKeydownHandler), Bi.on(document, 'click.bs.dropdown.data-api', ys.clearMenus), Bi.on(document, 'keyup.bs.dropdown.data-api', ys.clearMenus), Bi.on(document, 'click.bs.dropdown.data-api', ls, function (e) { e.preventDefault(), ys.getOrCreateInstance(this).toggle() }), yi(ys); class ws {constructor () { this._element = document.body }getWidth () { const e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e) }hide () { const e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, 'padding-right', t => t + e), this._setElementAttributes('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top', 'padding-right', t => t + e), this._setElementAttributes('.sticky-top', 'margin-right', t => t - e) }reset () { this._resetElementAttributes(this._element, 'overflow'), this._resetElementAttributes(this._element, 'padding-right'), this._resetElementAttributes('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top', 'padding-right'), this._resetElementAttributes('.sticky-top', 'margin-right') }isOverflowing () { return this.getWidth() > 0 }_disableOverFlow () { this._saveInitialAttribute(this._element, 'overflow'), this._element.style.overflow = 'hidden' }_setElementAttributes (e, t, i) { const s = this.getWidth(); this._applyManipulationCallback(e, e => { if (e !== this._element && window.innerWidth > e.clientWidth + s) return; this._saveInitialAttribute(e, t); const n = window.getComputedStyle(e).getPropertyValue(t); e.style.setProperty(t, `${i(Number.parseFloat(n))}px`) }) }_saveInitialAttribute (e, t) { const i = e.style.getPropertyValue(t); i && Wi.setDataAttribute(e, t, i) }_resetElementAttributes (e, t) { this._applyManipulationCallback(e, e => { const i = Wi.getDataAttribute(e, t); i !== null ? (Wi.removeDataAttribute(e, t), e.style.setProperty(t, i)) : e.style.removeProperty(t) }) }_applyManipulationCallback (e, t) { if (li(e))t(e); else for (const i of Yi.find(e, this._element))t(i) }} const _s = { className: 'modal-backdrop', clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: 'body' }; const Es = { className: 'string', clickCallback: '(function|null)', isAnimated: 'boolean', isVisible: 'boolean', rootElement: '(element|string)' }; class Ss extends Ui {constructor (e) { super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null } static get Default () { return _s } static get DefaultType () { return Es } static get NAME () { return 'backdrop' }show (e) { if (!this._config.isVisible) return void wi(e); this._append(); const t = this._getElement(); this._config.isAnimated && fi(t), t.classList.add('show'), this._emulateAnimation(() => { wi(e) }) }hide (e) { this._config.isVisible ? (this._getElement().classList.remove('show'), this._emulateAnimation(() => { this.dispose(), wi(e) })) : wi(e) }dispose () { this._isAppended && (Bi.off(this._element, 'mousedown.bs.backdrop'), this._element.remove(), this._isAppended = !1) }_getElement () { if (!this._element) { const e = document.createElement('div'); e.className = this._config.className, this._config.isAnimated && e.classList.add('fade'), this._element = e } return this._element }_configAfterMerge (e) { return e.rootElement = hi(e.rootElement), e }_append () { if (this._isAppended) return; const e = this._getElement(); this._config.rootElement.append(e), Bi.on(e, 'mousedown.bs.backdrop', () => { wi(this._config.clickCallback) }), this._isAppended = !0 }_emulateAnimation (e) { _i(e, this._getElement(), this._config.isAnimated) }} const As = { autofocus: !0, trapElement: null }; const Cs = { autofocus: 'boolean', trapElement: 'element' }; class ks extends Ui {constructor (e) { super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null } static get Default () { return As } static get DefaultType () { return Cs } static get NAME () { return 'focustrap' }activate () { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), Bi.off(document, '.bs.focustrap'), Bi.on(document, 'focusin.bs.focustrap', e => this._handleFocusin(e)), Bi.on(document, 'keydown.tab.bs.focustrap', e => this._handleKeydown(e)), this._isActive = !0) }deactivate () { this._isActive && (this._isActive = !1, Bi.off(document, '.bs.focustrap')) }_handleFocusin (e) { const { trapElement: t } = this._config; if (e.target === document || e.target === t || t.contains(e.target)) return; const i = Yi.focusableChildren(t); i.length === 0 ? t.focus() : this._lastTabNavDirection === 'backward' ? i[i.length - 1].focus() : i[0].focus() }_handleKeydown (e) { e.key === 'Tab' && (this._lastTabNavDirection = e.shiftKey ? 'backward' : 'forward') }} const Ts = { backdrop: !0, focus: !0, keyboard: !0 }; const Ls = { backdrop: '(boolean|string)', focus: 'boolean', keyboard: 'boolean' }; class Os extends Ki {constructor (e, t) { super(e, t), this._dialog = Yi.findOne('.modal-dialog', this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new ws(), this._addEventListeners() } static get Default () { return Ts } static get DefaultType () { return Ls } static get NAME () { return 'modal' }toggle (e) { return this._isShown ? this.hide() : this.show(e) }show (e) { if (this._isShown || this._isTransitioning) return; Bi.trigger(this._element, 'show.bs.modal', { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add('modal-open'), this._adjustDialog(), this._backdrop.show(() => this._showElement(e))) }hide () { if (!this._isShown || this._isTransitioning) return; Bi.trigger(this._element, 'hide.bs.modal').defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove('show'), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())) }dispose () { for (const e of [window, this._dialog])Bi.off(e, '.bs.modal'); this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() }handleUpdate () { this._adjustDialog() }_initializeBackDrop () { return new Ss({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) }_initializeFocusTrap () { return new ks({ trapElement: this._element }) }_showElement (e) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.scrollTop = 0; const t = Yi.findOne('.modal-body', this._dialog); t && (t.scrollTop = 0), fi(this._element), this._element.classList.add('show'); this._queueCallback(() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, Bi.trigger(this._element, 'shown.bs.modal', { relatedTarget: e }) }, this._dialog, this._isAnimated()) }_addEventListeners () { Bi.on(this._element, 'keydown.dismiss.bs.modal', e => { if (e.key === 'Escape') return this._config.keyboard ? (e.preventDefault(), void this.hide()) : void this._triggerBackdropTransition() }), Bi.on(window, 'resize.bs.modal', () => { this._isShown && !this._isTransitioning && this._adjustDialog() }), Bi.on(this._element, 'mousedown.dismiss.bs.modal', e => { Bi.one(this._element, 'click.dismiss.bs.modal', t => { this._element === e.target && this._element === t.target && (this._config.backdrop !== 'static' ? this._config.backdrop && this.hide() : this._triggerBackdropTransition()) }) }) }_hideModal () { this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove('modal-open'), this._resetAdjustments(), this._scrollBar.reset(), Bi.trigger(this._element, 'hidden.bs.modal') }) }_isAnimated () { return this._element.classList.contains('fade') }_triggerBackdropTransition () { if (Bi.trigger(this._element, 'hidePrevented.bs.modal').defaultPrevented) return; const e = this._element.scrollHeight > document.documentElement.clientHeight; const t = this._element.style.overflowY; t === 'hidden' || this._element.classList.contains('modal-static') || (e || (this._element.style.overflowY = 'hidden'), this._element.classList.add('modal-static'), this._queueCallback(() => { this._element.classList.remove('modal-static'), this._queueCallback(() => { this._element.style.overflowY = t }, this._dialog) }, this._dialog), this._element.focus()) }_adjustDialog () { const e = this._element.scrollHeight > document.documentElement.clientHeight; const t = this._scrollBar.getWidth(); const i = t > 0; if (i && !e) { const e = vi() ? 'paddingLeft' : 'paddingRight'; this._element.style[e] = `${t}px` } if (!i && e) { const e = vi() ? 'paddingRight' : 'paddingLeft'; this._element.style[e] = `${t}px` } }_resetAdjustments () { this._element.style.paddingLeft = '', this._element.style.paddingRight = '' } static jQueryInterface (e, t) { return this.each(function () { const i = Os.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e](t) } }) }}Bi.on(document, 'click.bs.modal.data-api', '[data-bs-toggle="modal"]', function (e) { const t = ai(this); ['A', 'AREA'].includes(this.tagName) && e.preventDefault(), Bi.one(t, 'show.bs.modal', e => { e.defaultPrevented || Bi.one(t, 'hidden.bs.modal', () => { di(this) && this.focus() }) }); const i = Yi.findOne('.modal.show'); i && Os.getInstance(i).hide(); Os.getOrCreateInstance(t).toggle(this) }), zi(Os), yi(Os); const Ps = { backdrop: !0, keyboard: !0, scroll: !1 }; const Ms = { backdrop: '(boolean|string)', keyboard: 'boolean', scroll: 'boolean' }; class xs extends Ki {constructor (e, t) { super(e, t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default () { return Ps } static get DefaultType () { return Ms } static get NAME () { return 'offcanvas' }toggle (e) { return this._isShown ? this.hide() : this.show(e) }show (e) { if (this._isShown) return; if (Bi.trigger(this._element, 'show.bs.offcanvas', { relatedTarget: e }).defaultPrevented) return; this._isShown = !0, this._backdrop.show(), this._config.scroll || (new ws()).hide(), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.classList.add('showing'); this._queueCallback(() => { this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add('show'), this._element.classList.remove('showing'), Bi.trigger(this._element, 'shown.bs.offcanvas', { relatedTarget: e }) }, this._element, !0) }hide () { if (!this._isShown) return; if (Bi.trigger(this._element, 'hide.bs.offcanvas').defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add('hiding'), this._backdrop.hide(); this._queueCallback(() => { this._element.classList.remove('show', 'hiding'), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._config.scroll || (new ws()).reset(), Bi.trigger(this._element, 'hidden.bs.offcanvas') }, this._element, !0) }dispose () { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() }_initializeBackDrop () { const e = Boolean(this._config.backdrop); return new Ss({ className: 'offcanvas-backdrop', isVisible: e, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: e ? () => { this._config.backdrop !== 'static' ? this.hide() : Bi.trigger(this._element, 'hidePrevented.bs.offcanvas') } : null }) }_initializeFocusTrap () { return new ks({ trapElement: this._element }) }_addEventListeners () { Bi.on(this._element, 'keydown.dismiss.bs.offcanvas', e => { e.key === 'Escape' && (this._config.keyboard ? this.hide() : Bi.trigger(this._element, 'hidePrevented.bs.offcanvas')) }) } static jQueryInterface (e) { return this.each(function () { const t = xs.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}Bi.on(document, 'click.bs.offcanvas.data-api', '[data-bs-toggle="offcanvas"]', function (e) { const t = ai(this); if (['A', 'AREA'].includes(this.tagName) && e.preventDefault(), ui(this)) return; Bi.one(t, 'hidden.bs.offcanvas', () => { di(this) && this.focus() }); const i = Yi.findOne('.offcanvas.show'); i && i !== t && xs.getInstance(i).hide(); xs.getOrCreateInstance(t).toggle(this) }), Bi.on(window, 'load.bs.offcanvas.data-api', () => { for (const e of Yi.find('.offcanvas.show'))xs.getOrCreateInstance(e).show() }), Bi.on(window, 'resize.bs.offcanvas', () => { for (const e of Yi.find('[aria-modal][class*=show][class*=offcanvas-]'))getComputedStyle(e).position !== 'fixed' && xs.getOrCreateInstance(e).hide() }), zi(xs), yi(xs); const Is = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']); const Rs = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i; const Ns = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; const Fs = (e, t) => { const i = e.nodeName.toLowerCase(); return t.includes(i) ? !Is.has(i) || Boolean(Rs.test(e.nodeValue) || Ns.test(e.nodeValue)) : t.filter(e => e instanceof RegExp).some(e => e.test(i)) }; const Ds = { '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i], a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'srcset', 'alt', 'title', 'width', 'height'], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; const Bs = { allowList: Ds, content: {}, extraClass: '', html: !1, sanitize: !0, sanitizeFn: null, template: '<div></div>' }; const js = { allowList: 'object', content: 'object', extraClass: '(string|function)', html: 'boolean', sanitize: 'boolean', sanitizeFn: '(null|function)', template: 'string' }; const qs = { entry: '(string|element|function|null)', selector: '(string|element)' }; class Hs extends Ui {constructor (e) { super(), this._config = this._getConfig(e) } static get Default () { return Bs } static get DefaultType () { return js } static get NAME () { return 'TemplateFactory' }getContent () { return Object.values(this._config.content).map(e => this._resolvePossibleFunction(e)).filter(Boolean) }hasContent () { return this.getContent().length > 0 }changeContent (e) { return this._checkContent(e), this._config.content = { ...this._config.content, ...e }, this }toHtml () { const e = document.createElement('div'); e.innerHTML = this._maybeSanitize(this._config.template); for (const [t, i] of Object.entries(this._config.content)) this._setContent(e, i, t); const t = e.children[0]; const i = this._resolvePossibleFunction(this._config.extraClass); return i && t.classList.add(...i.split(' ')), t }_typeCheckConfig (e) { super._typeCheckConfig(e), this._checkContent(e.content) }_checkContent (e) { for (const [t, i] of Object.entries(e)) super._typeCheckConfig({ selector: t, entry: i }, qs) }_setContent (e, t, i) { const s = Yi.findOne(i, e); s && ((t = this._resolvePossibleFunction(t)) ? li(t) ? this._putElementInTemplate(hi(t), s) : this._config.html ? s.innerHTML = this._maybeSanitize(t) : s.textContent = t : s.remove()) }_maybeSanitize (e) { return this._config.sanitize ? (function (e, t, i) { if (!e.length) return e; if (i && typeof i === 'function') return i(e); const s = (new window.DOMParser()).parseFromString(e, 'text/html'); const n = [].concat(...s.body.querySelectorAll('*')); for (const e of n) { const i = e.nodeName.toLowerCase(); if (!Object.keys(t).includes(i)) { e.remove(); continue } const s = [].concat(...e.attributes); const n = [].concat(t['*'] || [], t[i] || []); for (const t of s)Fs(t, n) || e.removeAttribute(t.nodeName) } return s.body.innerHTML }(e, this._config.allowList, this._config.sanitizeFn)) : e }_resolvePossibleFunction (e) { return typeof e === 'function' ? e(this) : e }_putElementInTemplate (e, t) { if (this._config.html) return t.innerHTML = '', void t.append(e); t.textContent = e.textContent }} const Vs = new Set(['sanitize', 'allowList', 'sanitizeFn']); const $s = { AUTO: 'auto', TOP: 'top', RIGHT: vi() ? 'left' : 'right', BOTTOM: 'bottom', LEFT: vi() ? 'right' : 'left' }; const Ws = { allowList: Ds, animation: !0, boundary: 'clippingParents', container: !1, customClass: '', delay: 0, fallbackPlacements: ['top', 'right', 'bottom', 'left'], html: !1, offset: [0, 0], placement: 'top', popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: '', trigger: 'hover focus' }; const Us = { allowList: 'object', animation: 'boolean', boundary: '(string|element)', container: '(string|element|boolean)', customClass: '(string|function)', delay: '(number|object)', fallbackPlacements: 'array', html: 'boolean', offset: '(array|string|function)', placement: '(string|function)', popperConfig: '(null|object|function)', sanitize: 'boolean', sanitizeFn: '(null|function)', selector: '(string|boolean)', template: 'string', title: '(string|element|function)', trigger: 'string' }; class Ks extends Ki {constructor (e, t) { if (void 0 === ni) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(e, t), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle() } static get Default () { return Ws } static get DefaultType () { return Us } static get NAME () { return 'tooltip' }enable () { this._isEnabled = !0 }disable () { this._isEnabled = !1 }toggleEnabled () { this._isEnabled = !this._isEnabled }toggle () { this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter()) }dispose () { clearTimeout(this._timeout), Bi.off(this._element.closest('.modal'), 'hide.bs.modal', this._hideModalHandler), this.tip && this.tip.remove(), this._element.getAttribute('data-bs-original-title') && this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title')), this._disposePopper(), super.dispose() }show () { if (this._element.style.display === 'none') throw new Error('Please use show on visible elements'); if (!this._isWithContent() || !this._isEnabled) return; const e = Bi.trigger(this._element, this.constructor.eventName('show')); const t = (pi(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (e.defaultPrevented || !t) return; this.tip && (this.tip.remove(), this.tip = null); const i = this._getTipElement(); this._element.setAttribute('aria-describedby', i.getAttribute('id')); const { container: s } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(i), Bi.trigger(this._element, this.constructor.eventName('inserted'))), this._popper ? this._popper.update() : this._popper = this._createPopper(i), i.classList.add('show'), 'ontouchstart' in document.documentElement) for (const e of [].concat(...document.body.children))Bi.on(e, 'mouseover', mi); this._queueCallback(() => { Bi.trigger(this._element, this.constructor.eventName('shown')), !1 === this._isHovered && this._leave(), this._isHovered = !1 }, this.tip, this._isAnimated()) }hide () { if (!this._isShown()) return; if (Bi.trigger(this._element, this.constructor.eventName('hide')).defaultPrevented) return; const e = this._getTipElement(); if (e.classList.remove('show'), 'ontouchstart' in document.documentElement) for (const e of [].concat(...document.body.children))Bi.off(e, 'mouseover', mi); this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this._isHovered = null; this._queueCallback(() => { this._isWithActiveTrigger() || (this._isHovered || e.remove(), this._element.removeAttribute('aria-describedby'), Bi.trigger(this._element, this.constructor.eventName('hidden')), this._disposePopper()) }, this.tip, this._isAnimated()) }update () { this._popper && this._popper.update() }_isWithContent () { return Boolean(this._getTitle()) }_getTipElement () { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip }_createTipElement (e) { const t = this._getTemplateFactory(e).toHtml(); if (!t) return null; t.classList.remove('fade', 'show'), t.classList.add(`bs-${this.constructor.NAME}-auto`); const i = (e => { do { e += Math.floor(1e6 * Math.random()) } while (document.getElementById(e)); return e })(this.constructor.NAME).toString(); return t.setAttribute('id', i), this._isAnimated() && t.classList.add('fade'), t }setContent (e) { this._newContent = e, this._isShown() && (this._disposePopper(), this.show()) }_getTemplateFactory (e) { return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new Hs({ ...this._config, content: e, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory }_getContentForTemplate () { return { '.tooltip-inner': this._getTitle() } }_getTitle () { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title') }_initializeOnDelegatedTarget (e) { return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig()) }_isAnimated () { return this._config.animation || this.tip && this.tip.classList.contains('fade') }_isShown () { return this.tip && this.tip.classList.contains('show') }_createPopper (e) { const t = typeof this._config.placement === 'function' ? this._config.placement.call(this, e, this._element) : this._config.placement; const i = $s[t.toUpperCase()]; return si(this._element, e, this._getPopperConfig(i)) }_getOffset () { const { offset: e } = this._config; return typeof e === 'string' ? e.split(',').map(e => Number.parseInt(e, 10)) : typeof e === 'function' ? t => e(t, this._element) : e }_resolvePossibleFunction (e) { return typeof e === 'function' ? e.call(this._element) : e }_getPopperConfig (e) { const t = { placement: e, modifiers: [{ name: 'flip', options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: 'offset', options: { offset: this._getOffset() } }, { name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'arrow', options: { element: `.${this.constructor.NAME}-arrow` } }, { name: 'preSetPlacement', enabled: !0, phase: 'beforeMain', fn: e => { this._getTipElement().setAttribute('data-popper-placement', e.state.placement) } }] }; return { ...t, ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(t) : this._config.popperConfig } }_setListeners () { const e = this._config.trigger.split(' '); for (const t of e) if (t === 'click')Bi.on(this._element, this.constructor.eventName('click'), this._config.selector, e => { this._initializeOnDelegatedTarget(e).toggle() }); else if (t !== 'manual') { const e = t === 'hover' ? this.constructor.eventName('mouseenter') : this.constructor.eventName('focusin'); const i = t === 'hover' ? this.constructor.eventName('mouseleave') : this.constructor.eventName('focusout'); Bi.on(this._element, e, this._config.selector, e => { const t = this._initializeOnDelegatedTarget(e); t._activeTrigger[e.type === 'focusin' ? 'focus' : 'hover'] = !0, t._enter() }), Bi.on(this._element, i, this._config.selector, e => { const t = this._initializeOnDelegatedTarget(e); t._activeTrigger[e.type === 'focusout' ? 'focus' : 'hover'] = t._element.contains(e.relatedTarget), t._leave() }) } this._hideModalHandler = () => { this._element && this.hide() }, Bi.on(this._element.closest('.modal'), 'hide.bs.modal', this._hideModalHandler) }_fixTitle () { const e = this._element.getAttribute('title'); e && (this._element.getAttribute('aria-label') || this._element.textContent.trim() || this._element.setAttribute('aria-label', e), this._element.setAttribute('data-bs-original-title', e), this._element.removeAttribute('title')) }_enter () { this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(() => { this._isHovered && this.show() }, this._config.delay.show)) }_leave () { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => { this._isHovered || this.hide() }, this._config.delay.hide)) }_setTimeout (e, t) { clearTimeout(this._timeout), this._timeout = setTimeout(e, t) }_isWithActiveTrigger () { return Object.values(this._activeTrigger).includes(!0) }_getConfig (e) { const t = Wi.getDataAttributes(this._element); for (const e of Object.keys(t))Vs.has(e) && delete t[e]; return e = { ...t, ...typeof e === 'object' && e ? e : {} }, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e }_configAfterMerge (e) { return e.container = !1 === e.container ? document.body : hi(e.container), typeof e.delay === 'number' && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title === 'number' && (e.title = e.title.toString()), typeof e.content === 'number' && (e.content = e.content.toString()), e }_getDelegateConfig () { const e = {}; for (const t in this._config) this.constructor.Default[t] !== this._config[t] && (e[t] = this._config[t]); return e.selector = !1, e.trigger = 'manual', e }_disposePopper () { this._popper && (this._popper.destroy(), this._popper = null) } static jQueryInterface (e) { return this.each(function () { const t = Ks.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } }) }}yi(Ks); const zs = { ...Ks.Default, content: '', offset: [0, 8], placement: 'right', template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: 'click' }; const Qs = { ...Ks.DefaultType, content: '(null|string|element|function)' }; class Gs extends Ks {static get Default () { return zs } static get DefaultType () { return Qs } static get NAME () { return 'popover' }_isWithContent () { return this._getTitle() || this._getContent() }_getContentForTemplate () { return { '.popover-header': this._getTitle(), '.popover-body': this._getContent() } }_getContent () { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface (e) { return this.each(function () { const t = Gs.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } }) }}yi(Gs); const Ys = { offset: null, rootMargin: '0px 0px -25%', smoothScroll: !1, target: null, threshold: [0.1, 0.5, 1] }; const Xs = { offset: '(number|null)', rootMargin: 'string', smoothScroll: 'boolean', target: 'element', threshold: 'array' }; class Js extends Ki {constructor (e, t) { super(e, t), this._targetLinks = new Map(), this._observableSections = new Map(), this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default () { return Ys } static get DefaultType () { return Xs } static get NAME () { return 'scrollspy' }refresh () { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const e of this._observableSections.values()) this._observer.observe(e) }dispose () { this._observer.disconnect(), super.dispose() }_configAfterMerge (e) { return e.target = hi(e.target) || document.body, e.rootMargin = e.offset ? `${e.offset}px 0px -30%` : e.rootMargin, typeof e.threshold === 'string' && (e.threshold = e.threshold.split(',').map(e => Number.parseFloat(e))), e }_maybeEnableSmoothScroll () { this._config.smoothScroll && (Bi.off(this._config.target, 'click.bs.scrollspy'), Bi.on(this._config.target, 'click.bs.scrollspy', '[href]', e => { const t = this._observableSections.get(e.target.hash); if (t) { e.preventDefault(); const i = this._rootElement || window; const s = t.offsetTop - this._element.offsetTop; if (i.scrollTo) return void i.scrollTo({ top: s, behavior: 'smooth' }); i.scrollTop = s } })) }_getNewObserver () { const e = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver(e => this._observerCallback(e), e) }_observerCallback (e) { const t = e => this._targetLinks.get(`#${e.target.id}`); const i = e => { this._previousScrollData.visibleEntryTop = e.target.offsetTop, this._process(t(e)) }; const s = (this._rootElement || document.documentElement).scrollTop; const n = s >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = s; for (const r of e) { if (!r.isIntersecting) { this._activeTarget = null, this._clearActiveClass(t(r)); continue } const e = r.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (n && e) { if (i(r), !s) return } else n || e || i(r) } }_initializeTargetsAndObservables () { this._targetLinks = new Map(), this._observableSections = new Map(); const e = Yi.find('[href]', this._config.target); for (const t of e) { if (!t.hash || ui(t)) continue; const e = Yi.findOne(t.hash, this._element); di(e) && (this._targetLinks.set(t.hash, t), this._observableSections.set(t.hash, e)) } }_process (e) { this._activeTarget !== e && (this._clearActiveClass(this._config.target), this._activeTarget = e, e.classList.add('active'), this._activateParents(e), Bi.trigger(this._element, 'activate.bs.scrollspy', { relatedTarget: e })) }_activateParents (e) { if (e.classList.contains('dropdown-item'))Yi.findOne('.dropdown-toggle', e.closest('.dropdown')).classList.add('active'); else for (const t of Yi.parents(e, '.nav, .list-group')) for (const e of Yi.prev(t, '.nav-link, .nav-item > .nav-link, .list-group-item'))e.classList.add('active') }_clearActiveClass (e) { e.classList.remove('active'); const t = Yi.find('[href].active', e); for (const e of t)e.classList.remove('active') } static jQueryInterface (e) { return this.each(function () { const t = Js.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}Bi.on(window, 'load.bs.scrollspy.data-api', () => { for (const e of Yi.find('[data-bs-spy="scroll"]'))Js.getOrCreateInstance(e) }), yi(Js); const Zs = 'ArrowLeft'; const en = 'ArrowRight'; const tn = 'ArrowUp'; const sn = 'ArrowDown'; const nn = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; const rn = `.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${nn}`; class on extends Ki {constructor (e) { super(e), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), Bi.on(this._element, 'keydown.bs.tab', e => this._keydown(e))) } static get NAME () { return 'tab' }show () { const e = this._element; if (this._elemIsActive(e)) return; const t = this._getActiveElem(); const i = t ? Bi.trigger(t, 'hide.bs.tab', { relatedTarget: e }) : null; Bi.trigger(e, 'show.bs.tab', { relatedTarget: t }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(t, e), this._activate(e, t)) }_activate (e, t) { if (!e) return; e.classList.add('active'), this._activate(ai(e)); this._queueCallback(() => { e.getAttribute('role') === 'tab' ? (e.removeAttribute('tabindex'), e.setAttribute('aria-selected', !0), this._toggleDropDown(e, !0), Bi.trigger(e, 'shown.bs.tab', { relatedTarget: t })) : e.classList.add('show') }, e, e.classList.contains('fade')) }_deactivate (e, t) { if (!e) return; e.classList.remove('active'), e.blur(), this._deactivate(ai(e)); this._queueCallback(() => { e.getAttribute('role') === 'tab' ? (e.setAttribute('aria-selected', !1), e.setAttribute('tabindex', '-1'), this._toggleDropDown(e, !1), Bi.trigger(e, 'hidden.bs.tab', { relatedTarget: t })) : e.classList.remove('show') }, e, e.classList.contains('fade')) }_keydown (e) { if (![Zs, en, tn, sn].includes(e.key)) return; e.stopPropagation(), e.preventDefault(); const t = [en, sn].includes(e.key); const i = Ei(this._getChildren().filter(e => !ui(e)), e.target, t, !0); i && (i.focus({ preventScroll: !0 }), on.getOrCreateInstance(i).show()) }_getChildren () { return Yi.find(rn, this._parent) }_getActiveElem () { return this._getChildren().find(e => this._elemIsActive(e)) || null }_setInitialAttributes (e, t) { this._setAttributeIfNotExists(e, 'role', 'tablist'); for (const e of t) this._setInitialAttributesOnChild(e) }_setInitialAttributesOnChild (e) { e = this._getInnerElement(e); const t = this._elemIsActive(e); const i = this._getOuterElement(e); e.setAttribute('aria-selected', t), i !== e && this._setAttributeIfNotExists(i, 'role', 'presentation'), t || e.setAttribute('tabindex', '-1'), this._setAttributeIfNotExists(e, 'role', 'tab'), this._setInitialAttributesOnTargetPanel(e) }_setInitialAttributesOnTargetPanel (e) { const t = ai(e); t && (this._setAttributeIfNotExists(t, 'role', 'tabpanel'), e.id && this._setAttributeIfNotExists(t, 'aria-labelledby', `#${e.id}`)) }_toggleDropDown (e, t) { const i = this._getOuterElement(e); if (!i.classList.contains('dropdown')) return; const s = (e, s) => { const n = Yi.findOne(e, i); n && n.classList.toggle(s, t) }; s('.dropdown-toggle', 'active'), s('.dropdown-menu', 'show'), i.setAttribute('aria-expanded', t) }_setAttributeIfNotExists (e, t, i) { e.hasAttribute(t) || e.setAttribute(t, i) }_elemIsActive (e) { return e.classList.contains('active') }_getInnerElement (e) { return e.matches(rn) ? e : Yi.findOne(rn, e) }_getOuterElement (e) { return e.closest('.nav-item, .list-group-item') || e } static jQueryInterface (e) { return this.each(function () { const t = on.getOrCreateInstance(this); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e]() } }) }}Bi.on(document, 'click.bs.tab', nn, function (e) { ['A', 'AREA'].includes(this.tagName) && e.preventDefault(), ui(this) || on.getOrCreateInstance(this).show() }), Bi.on(window, 'load.bs.tab', () => { for (const e of Yi.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]'))on.getOrCreateInstance(e) }), yi(on); const an = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const cn = { animation: !0, autohide: !0, delay: 5e3 }; class ln extends Ki {constructor (e, t) { super(e, t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default () { return cn } static get DefaultType () { return an } static get NAME () { return 'toast' }show () { if (Bi.trigger(this._element, 'show.bs.toast').defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add('fade'); this._element.classList.remove('hide'), fi(this._element), this._element.classList.add('show', 'showing'), this._queueCallback(() => { this._element.classList.remove('showing'), Bi.trigger(this._element, 'shown.bs.toast'), this._maybeScheduleHide() }, this._element, this._config.animation) }hide () { if (!this.isShown()) return; if (Bi.trigger(this._element, 'hide.bs.toast').defaultPrevented) return; this._element.classList.add('showing'), this._queueCallback(() => { this._element.classList.add('hide'), this._element.classList.remove('showing', 'show'), Bi.trigger(this._element, 'hidden.bs.toast') }, this._element, this._config.animation) }dispose () { this._clearTimeout(), this.isShown() && this._element.classList.remove('show'), super.dispose() }isShown () { return this._element.classList.contains('show') }_maybeScheduleHide () { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide() }, this._config.delay))) }_onInteraction (e, t) { switch (e.type) { case 'mouseover':case 'mouseout':this._hasMouseInteraction = t; break; case 'focusin':case 'focusout':this._hasKeyboardInteraction = t } if (t) return void this._clearTimeout(); const i = e.relatedTarget; this._element === i || this._element.contains(i) || this._maybeScheduleHide() }_setListeners () { Bi.on(this._element, 'mouseover.bs.toast', e => this._onInteraction(e, !0)), Bi.on(this._element, 'mouseout.bs.toast', e => this._onInteraction(e, !1)), Bi.on(this._element, 'focusin.bs.toast', e => this._onInteraction(e, !0)), Bi.on(this._element, 'focusout.bs.toast', e => this._onInteraction(e, !1)) }_clearTimeout () { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface (e) { return this.each(function () { const t = ln.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](this) } }) }}zi(ln), yi(ln); const hn = Object.freeze({ __proto__: null, Alert: Qi, Button: Gi, Carousel: ss, Collapse: os, Dropdown: ys, Modal: Os, Offcanvas: xs, Popover: Gs, ScrollSpy: Js, Tab: on, Toast: ln, Tooltip: Ks }); window.bootstrap || (window.bootstrap = hn); const dn = (function () { function e (e) { const t = this; this.listener = function (e) { (e.matches ? t.matchFns : t.unmatchFns).forEach(function (e) { e() }) }, this.toggler = window.matchMedia(e), this.toggler.addListener(this.listener), this.matchFns = [], this.unmatchFns = [] } return e.prototype.add = function (e, t) { this.matchFns.push(e), this.unmatchFns.push(t), (this.toggler.matches ? e : t)() }, e }()); const un = function (e) { return Array.prototype.slice.call(e) }; const pn = function (e, t) { return un((t || document).querySelectorAll(e)) }; const mn = (function () { function e (e, t, i, s, n) { this.node = e, this.title = t, this.slidingSubmenus = s, this.selectedClass = i, this.node.classList.add('mm-spn'), this.node.classList.add('mm-spn--' + n), this.node.classList.add('mm-spn--' + (this.slidingSubmenus ? 'navbar' : 'vertical')), this._setSelectedl(), this._initAnchors() } return Object.defineProperty(e.prototype, 'prefix', { get: function () { return 'mm-spn' }, enumerable: !1, configurable: !0 }), e.prototype.openPanel = function (e) { const t = e.parentElement; if (this.slidingSubmenus) { let i = e.dataset.mmSpnTitle; t === this.node ? this.node.classList.add('mm-spn--main') : (this.node.classList.remove('mm-spn--main'), i || un(t.children).forEach(function (e) { e.matches('a, span') && (i = e.textContent) })), i || (i = this.title), this.node.dataset.mmSpnTitle = i, pn('.mm-spn--open', this.node).forEach(function (e) { e.classList.remove('mm-spn--open'), e.classList.remove('mm-spn--parent') }), e.classList.add('mm-spn--open'), e.classList.remove('mm-spn--parent'); for (let s = e.parentElement.closest('ul'); s;)s.classList.add('mm-spn--open'), s.classList.add('mm-spn--parent'), s = s.parentElement.closest('ul') } else { const n = e.matches('.mm-spn--open'); pn('.mm-spn--open', this.node).forEach(function (e) { e.classList.remove('mm-spn--open') }), e.classList[n ? 'remove' : 'add']('mm-spn--open'); for (let r = e.parentElement.closest('ul'); r;)r.classList.add('mm-spn--open'), r = r.parentElement.closest('ul') } }, e.prototype._setSelectedl = function () { const e = pn('.' + this.selectedClass, this.node); const t = e[e.length - 1]; let i = null; t && (i = t.closest('ul')), i || (i = this.node.querySelector('ul')), this.openPanel(i) }, e.prototype._initAnchors = function () { const e = this; this.node.addEventListener('click', function (t) { const i = t.target; let s = !1; s = s || (function (e) { return !!e.matches('a') }(i)), s = s || (function (t) { let i; return !!(i = t.closest('span') ? t.parentElement : !!t.closest('li') && t) && (un(i.children).forEach(function (t) { t.matches('ul') && e.openPanel(t) }), !0) }(i)), s = s || (function (t) { const i = pn('.mm-spn--open', t); const s = i[i.length - 1]; if (s) { const n = s.parentElement.closest('ul'); if (n) return e.openPanel(n), !0 } return !1 }(i)), s && t.stopImmediatePropagation() }) }, e }()); const fn = 'mm-ocd'; const gn = (function () { function e (e, t) { const i = this; void 0 === e && (e = null), this.wrapper = document.createElement('div'), this.wrapper.classList.add('mm-ocd'), this.wrapper.classList.add('mm-ocd--' + t), this.content = document.createElement('div'), this.content.classList.add('mm-ocd__content'), this.wrapper.append(this.content), this.backdrop = document.createElement('div'), this.backdrop.classList.add('mm-ocd__backdrop'), this.wrapper.append(this.backdrop), document.body.append(this.wrapper), e && this.content.append(e); const s = function (e) { i.close(), e.stopImmediatePropagation() }; this.backdrop.addEventListener('touchstart', s, { passive: !0 }), this.backdrop.addEventListener('mousedown', s, { passive: !0 }) } return Object.defineProperty(e.prototype, 'prefix', { get: function () { return fn }, enumerable: !1, configurable: !0 }), e.prototype.open = function () { this.wrapper.classList.add('mm-ocd--open'), document.body.classList.add('mm-ocd-opened') }, e.prototype.close = function () { this.wrapper.classList.remove('mm-ocd--open'), document.body.classList.remove('mm-ocd-opened') }, e }()); const bn = (function () { function e (e, t) { void 0 === t && (t = 'all'), this.menu = e, this.toggler = new dn(t) } return e.prototype.navigation = function (e) { const t = this; if (!this.navigator) { const i = (e = e || {}).title; const s = void 0 === i ? 'Menu' : i; const n = e.selectedClass; const r = void 0 === n ? 'Selected' : n; const o = e.slidingSubmenus; const a = void 0 === o || o; const c = e.theme; const l = void 0 === c ? 'light' : c; this.navigator = new mn(this.menu, s, r, a, l), this.toggler.add(function () { return t.menu.classList.add(t.navigator.prefix) }, function () { return t.menu.classList.remove(t.navigator.prefix) }) } return this.navigator }, e.prototype.offcanvas = function (e) { const t = this; if (!this.drawer) { const i = (e = e || {}).position; const s = void 0 === i ? 'left' : i; this.drawer = new gn(null, s); const n = document.createComment('original menu location'); this.menu.after(n), this.toggler.add(function () { t.drawer.content.append(t.menu) }, function () { t.drawer.close(), n.after(t.menu) }) } return this.drawer }, e }())
/*!
 * Mmenu Light
 * mmenujs.com/mmenu-light
 *
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * License: CC-BY-4.0
 * http://creativecommons.org/licenses/by/4.0/
 */
window.MmenuLight = bn, document.addEventListener('turbo:load', () => { const e = new bn(document.querySelector('#mobileNav'), 'all'); e.navigation({ selectedClass: 'Selected', slidingSubmenus: !0, theme: 'light', title: 'Main Menu' }); const t = e.offcanvas({}); document.querySelector('a[href="#mobileNav"]').addEventListener('click', e => { e.preventDefault(), t.open() }) }); const vn = typeof window !== 'undefined'; const yn = vn && !('onscroll' in window) || typeof navigator !== 'undefined' && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent); const wn = vn && 'IntersectionObserver' in window; const _n = vn && 'classList' in document.createElement('p'); const En = vn && window.devicePixelRatio > 1; const Sn = { elements_selector: '.lazy', container: yn || vn ? document : null, threshold: 300, thresholds: null, data_src: 'src', data_srcset: 'srcset', data_sizes: 'sizes', data_bg: 'bg', data_bg_hidpi: 'bg-hidpi', data_bg_multi: 'bg-multi', data_bg_multi_hidpi: 'bg-multi-hidpi', data_bg_set: 'bg-set', data_poster: 'poster', class_applied: 'applied', class_loading: 'loading', class_loaded: 'loaded', class_error: 'error', class_entered: 'entered', class_exited: 'exited', unobserve_completed: !0, unobserve_entered: !1, cancel_on_exit: !0, callback_enter: null, callback_exit: null, callback_applied: null, callback_loading: null, callback_loaded: null, callback_error: null, callback_finish: null, callback_cancel: null, use_native: !1, restore_on_error: !1 }; const An = e => Object.assign({}, Sn, e); const Cn = function (e, t) { let i; const s = 'LazyLoad::Initialized'; const n = new e(t); try { i = new CustomEvent(s, { detail: { instance: n } }) } catch (e) { i = document.createEvent('CustomEvent'), i.initCustomEvent(s, !1, !1, { instance: n }) }window.dispatchEvent(i) }; const kn = 'src'; const Tn = 'llOriginalAttrs'; const Ln = (e, t) => e.getAttribute('data-' + t); const On = e => Ln(e, 'll-status'); const Pn = (e, t) => ((e, t, i) => { const s = 'data-' + t; i !== null ? e.setAttribute(s, i) : e.removeAttribute(s) })(e, 'll-status', t); const Mn = e => Pn(e, null); const xn = e => On(e) === null; const In = e => On(e) === 'native'; const Rn = ['loading', 'loaded', 'applied', 'error']; const Nn = (e, t, i, s) => { e && (void 0 === s ? void 0 === i ? e(t) : e(t, i) : e(t, i, s)) }; const Fn = (e, t) => { _n ? e.classList.add(t) : e.className += (e.className ? ' ' : '') + t }; const Dn = (e, t) => { _n ? e.classList.remove(t) : e.className = e.className.replace(new RegExp('(^|\\s+)' + t + '(\\s+|$)'), ' ').replace(/^\s+/, '').replace(/\s+$/, '') }; const Bn = e => e.llTempImage; const jn = (e, t) => { if (!t) return; const i = t._observer; i && i.unobserve(e) }; const qn = (e, t) => { e && (e.loadingCount += t) }; const Hn = (e, t) => { e && (e.toLoadCount = t) }; const Vn = e => { const t = []; for (let i, s = 0; i = e.children[s]; s += 1)i.tagName === 'SOURCE' && t.push(i); return t }; const $n = (e, t) => { const i = e.parentNode; if (!i || i.tagName !== 'PICTURE') return; Vn(i).forEach(t) }; const Wn = (e, t) => { Vn(e).forEach(t) }; const Un = [kn]; const Kn = [kn, 'poster']; const zn = [kn, 'srcset', 'sizes']; const Qn = ['data']; const Gn = e => !!e[Tn]; const Yn = e => e[Tn]; const Xn = e => delete e[Tn]; const Jn = (e, t) => { if (Gn(e)) return; const i = {}; t.forEach(t => { i[t] = e.getAttribute(t) }), e[Tn] = i }; const Zn = (e, t) => { if (!Gn(e)) return; const i = Yn(e); t.forEach(t => { ((e, t, i) => { i ? e.setAttribute(t, i) : e.removeAttribute(t) })(e, t, i[t]) }) }; const er = (e, t, i) => { Fn(e, t.class_applied), Pn(e, 'applied'), i && (t.unobserve_completed && jn(e, t), Nn(t.callback_applied, e, i)) }; const tr = (e, t, i) => { Fn(e, t.class_loading), Pn(e, 'loading'), i && (qn(i, 1), Nn(t.callback_loading, e, i)) }; const ir = (e, t, i) => { i && e.setAttribute(t, i) }; const sr = (e, t) => { ir(e, 'sizes', Ln(e, t.data_sizes)), ir(e, 'srcset', Ln(e, t.data_srcset)), ir(e, kn, Ln(e, t.data_src)) }; const nr = { IMG: (e, t) => { $n(e, e => { Jn(e, zn), sr(e, t) }), Jn(e, zn), sr(e, t) }, IFRAME: (e, t) => { Jn(e, Un), ir(e, kn, Ln(e, t.data_src)) }, VIDEO: (e, t) => { Wn(e, e => { Jn(e, Un), ir(e, kn, Ln(e, t.data_src)) }), Jn(e, Kn), ir(e, 'poster', Ln(e, t.data_poster)), ir(e, kn, Ln(e, t.data_src)), e.load() }, OBJECT: (e, t) => { Jn(e, Qn), ir(e, 'data', Ln(e, t.data_src)) } }; const rr = ['IMG', 'IFRAME', 'VIDEO', 'OBJECT']; const or = (e, t) => { !t || (e => e.loadingCount > 0)(t) || (e => e.toLoadCount > 0)(t) || Nn(e.callback_finish, t) }; const ar = (e, t, i) => { e.addEventListener(t, i), e.llEvLisnrs[t] = i }; const cr = (e, t, i) => { e.removeEventListener(t, i) }; const lr = e => !!e.llEvLisnrs; const hr = e => { if (!lr(e)) return; const t = e.llEvLisnrs; for (const i in t) { const s = t[i]; cr(e, i, s) } delete e.llEvLisnrs }; const dr = (e, t, i) => { (e => { delete e.llTempImage })(e), qn(i, -1), (e => { e && (e.toLoadCount -= 1) })(i), Dn(e, t.class_loading), t.unobserve_completed && jn(e, i) }; const ur = (e, t, i) => { const s = Bn(e) || e; if (lr(s)) return; ((e, t, i) => { lr(e) || (e.llEvLisnrs = {}); const s = e.tagName === 'VIDEO' ? 'loadeddata' : 'load'; ar(e, s, t), ar(e, 'error', i) })(s, n => { ((e, t, i, s) => { const n = In(t); dr(t, i, s), Fn(t, i.class_loaded), Pn(t, 'loaded'), Nn(i.callback_loaded, t, s), n || or(i, s) })(0, e, t, i), hr(s) }, n => { ((e, t, i, s) => { const n = In(t); dr(t, i, s), Fn(t, i.class_error), Pn(t, 'error'), Nn(i.callback_error, t, s), i.restore_on_error && Zn(t, zn), n || or(i, s) })(0, e, t, i), hr(s) }) }; const pr = (e, t, i) => { (e => { e.llTempImage = document.createElement('IMG') })(e), ur(e, t, i), (e => { Gn(e) || (e[Tn] = { backgroundImage: e.style.backgroundImage }) })(e), ((e, t, i) => { const s = Ln(e, t.data_bg); const n = Ln(e, t.data_bg_hidpi); const r = En && n ? n : s; r && (e.style.backgroundImage = `url("${r}")`, Bn(e).setAttribute(kn, r), tr(e, t, i)) })(e, t, i), ((e, t, i) => { const s = Ln(e, t.data_bg_multi); const n = Ln(e, t.data_bg_multi_hidpi); const r = En && n ? n : s; r && (e.style.backgroundImage = r, er(e, t, i)) })(e, t, i), ((e, t, i) => { const s = Ln(e, t.data_bg_set); if (!s) return; const n = s.split('|'); let r = n.map(e => `image-set(${e})`); e.style.backgroundImage = r.join(), e.style.backgroundImage === '' && (r = n.map(e => `-webkit-image-set(${e})`), e.style.backgroundImage = r.join()), er(e, t, i) })(e, t, i) }; const mr = (e, t, i) => { ur(e, t, i), ((e, t, i) => { const s = nr[e.tagName]; s && (s(e, t), tr(e, t, i)) })(e, t, i) }; const fr = (e, t, i) => { (e => rr.indexOf(e.tagName) > -1)(e) ? mr(e, t, i) : pr(e, t, i) }; const gr = (e, t, i) => { e.setAttribute('loading', 'lazy'), ur(e, t, i), ((e, t) => { const i = nr[e.tagName]; i && i(e, t) })(e, t), Pn(e, 'native') }; const br = e => { e.removeAttribute(kn), e.removeAttribute('srcset'), e.removeAttribute('sizes') }; const vr = e => { $n(e, e => { Zn(e, zn) }), Zn(e, zn) }; const yr = { IMG: vr, IFRAME: e => { Zn(e, Un) }, VIDEO: e => { Wn(e, e => { Zn(e, Un) }), Zn(e, Kn), e.load() }, OBJECT: e => { Zn(e, Qn) } }; const wr = e => { const t = yr[e.tagName]; t ? t(e) : (e => { if (!Gn(e)) return; const t = Yn(e); e.style.backgroundImage = t.backgroundImage })(e) }; const _r = (e, t) => { wr(e), ((e, t) => { xn(e) || In(e) || (Dn(e, t.class_entered), Dn(e, t.class_exited), Dn(e, t.class_applied), Dn(e, t.class_loading), Dn(e, t.class_loaded), Dn(e, t.class_error)) })(e, t), Mn(e), Xn(e) }; const Er = (e, t, i, s) => { i.cancel_on_exit && (e => On(e) === 'loading')(e) && e.tagName === 'IMG' && (hr(e), (e => { $n(e, e => { br(e) }), br(e) })(e), vr(e), Dn(e, i.class_loading), qn(s, -1), Mn(e), Nn(i.callback_cancel, e, t, s)) }; const Sr = (e, t, i, s) => { const n = (e => Rn.indexOf(On(e)) >= 0)(e); Pn(e, 'entered'), Fn(e, i.class_entered), Dn(e, i.class_exited), ((e, t, i) => { t.unobserve_entered && jn(e, i) })(e, i, s), Nn(i.callback_enter, e, t, s), n || fr(e, i, s) }; const Ar = ['IMG', 'IFRAME', 'VIDEO']; const Cr = e => e.use_native && 'loading' in HTMLImageElement.prototype; const kr = (e, t, i) => { e.forEach(e => (e => e.isIntersecting || e.intersectionRatio > 0)(e) ? Sr(e.target, e, t, i) : ((e, t, i, s) => { xn(e) || (Fn(e, i.class_exited), Er(e, t, i, s), Nn(i.callback_exit, e, t, s)) })(e.target, e, t, i)) }; const Tr = (e, t) => { wn && !Cr(e) && (t._observer = new IntersectionObserver(i => { kr(i, e, t) }, (e => ({ root: e.container === document ? null : e.container, rootMargin: e.thresholds || e.threshold + 'px' }))(e))) }; const Lr = e => Array.prototype.slice.call(e); const Or = e => e.container.querySelectorAll(e.elements_selector); const Pr = e => (e => On(e) === 'error')(e); const Mr = (e, t) => (e => Lr(e).filter(xn))(e || Or(t)); const xr = (e, t) => { let i; (i = Or(e), Lr(i).filter(Pr)).forEach(t => { Dn(t, e.class_error), Mn(t) }), t.update() }; const Ir = function (e, t) { const i = An(e); this._settings = i, this.loadingCount = 0, Tr(i, this), ((e, t) => { vn && (t._onlineHandler = () => { xr(e, t) }, window.addEventListener('online', t._onlineHandler)) })(i, this), this.update(t) }; Ir.prototype = { update: function (e) { const t = this._settings; const i = Mr(e, t); let s, n; (Hn(this, i.length), !yn && wn) ? Cr(t) ? ((e, t, i) => { e.forEach(e => { Ar.indexOf(e.tagName) !== -1 && gr(e, t, i) }), Hn(i, 0) })(i, t, this) : (s = this._observer, n = i, (e => { e.disconnect() })(s), ((e, t) => { t.forEach(t => { e.observe(t) }) })(s, n)) : this.loadAll(i) }, destroy: function () { let e; this._observer && this._observer.disconnect(), e = this, vn && window.removeEventListener('online', e._onlineHandler), Or(this._settings).forEach(e => { Xn(e) }), delete this._observer, delete this._settings, delete this._onlineHandler, delete this.loadingCount, delete this.toLoadCount }, loadAll: function (e) { const t = this._settings; Mr(e, t).forEach(e => { jn(e, this), fr(e, t, this) }) }, restoreAll: function () { const e = this._settings; Or(e).forEach(t => { _r(t, e) }) } }, Ir.load = (e, t) => { const i = An(t); fr(e, i) }, Ir.resetStatus = e => { Mn(e) }, vn && ((e, t) => { if (t) if (t.length) for (let i, s = 0; i = t[s]; s += 1)Cn(e, i); else Cn(e, t) })(Ir, window.lazyLoadOptions), window.LazyLoad || (window.LazyLoad = Ir); class Rr {constructor (e, t, i) { this.eventTarget = e, this.eventName = t, this.eventOptions = i, this.unorderedBindings = new Set() }connect () { this.eventTarget.addEventListener(this.eventName, this, this.eventOptions) }disconnect () { this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions) }bindingConnected (e) { this.unorderedBindings.add(e) }bindingDisconnected (e) { this.unorderedBindings.delete(e) }handleEvent (e) { const t = (function (e) { if ('immediatePropagationStopped' in e) return e; { const { stopImmediatePropagation: t } = e; return Object.assign(e, { immediatePropagationStopped: !1, stopImmediatePropagation () { this.immediatePropagationStopped = !0, t.call(this) } }) } }(e)); for (const e of this.bindings) { if (t.immediatePropagationStopped) break; e.handleEvent(t) } } get bindings () { return Array.from(this.unorderedBindings).sort((e, t) => { const i = e.index; const s = t.index; return i < s ? -1 : i > s ? 1 : 0 }) }} class Nr {constructor (e) { this.application = e, this.eventListenerMaps = new Map(), this.started = !1 }start () { this.started || (this.started = !0, this.eventListeners.forEach(e => e.connect())) }stop () { this.started && (this.started = !1, this.eventListeners.forEach(e => e.disconnect())) } get eventListeners () { return Array.from(this.eventListenerMaps.values()).reduce((e, t) => e.concat(Array.from(t.values())), []) }bindingConnected (e) { this.fetchEventListenerForBinding(e).bindingConnected(e) }bindingDisconnected (e) { this.fetchEventListenerForBinding(e).bindingDisconnected(e) }handleError (e, t, i = {}) { this.application.handleError(e, `Error ${t}`, i) }fetchEventListenerForBinding (e) { const { eventTarget: t, eventName: i, eventOptions: s } = e; return this.fetchEventListener(t, i, s) }fetchEventListener (e, t, i) { const s = this.fetchEventListenerMapForEventTarget(e); const n = this.cacheKey(t, i); let r = s.get(n); return r || (r = this.createEventListener(e, t, i), s.set(n, r)), r }createEventListener (e, t, i) { const s = new Rr(e, t, i); return this.started && s.connect(), s }fetchEventListenerMapForEventTarget (e) { let t = this.eventListenerMaps.get(e); return t || (t = new Map(), this.eventListenerMaps.set(e, t)), t }cacheKey (e, t) { const i = [e]; return Object.keys(t).sort().forEach(e => { i.push(`${t[e] ? '' : '!'}${e}`) }), i.join(':') }} const Fr = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/; function Dr (e) { return e == 'window' ? window : e == 'document' ? document : void 0 } function Br (e) { return e.replace(/(?:[_-])([a-z0-9])/g, (e, t) => t.toUpperCase()) } function jr (e) { return e.charAt(0).toUpperCase() + e.slice(1) } function qr (e) { return e.replace(/([A-Z])/g, (e, t) => `-${t.toLowerCase()}`) } class Hr {constructor (e, t, i) { this.element = e, this.index = t, this.eventTarget = i.eventTarget || e, this.eventName = i.eventName || (function (e) { const t = e.tagName.toLowerCase(); if (t in Vr) return Vr[t](e) }(e)) || $r('missing event name'), this.eventOptions = i.eventOptions || {}, this.identifier = i.identifier || $r('missing identifier'), this.methodName = i.methodName || $r('missing method name') } static forToken (e) { return new this(e.element, e.index, (function (e) { const t = e.trim().match(Fr) || []; return { eventTarget: Dr(t[4]), eventName: t[2], eventOptions: t[9] ? (i = t[9], i.split(':').reduce((e, t) => Object.assign(e, { [t.replace(/^!/, '')]: !/^!/.test(t) }), {})) : {}, identifier: t[5], methodName: t[7] }; let i }(e.content))) }toString () { const e = this.eventTargetName ? `@${this.eventTargetName}` : ''; return `${this.eventName}${e}->${this.identifier}#${this.methodName}` } get params () { const e = {}; const t = new RegExp(`^data-${this.identifier}-(.+)-param$`); for (const { name: i, value: s } of Array.from(this.element.attributes)) { const n = i.match(t); const r = n && n[1]; r && (e[Br(r)] = Wr(s)) } return e } get eventTargetName () { return (e = this.eventTarget) == window ? 'window' : e == document ? 'document' : void 0; let e }} const Vr = { a: e => 'click', button: e => 'click', form: e => 'submit', details: e => 'toggle', input: e => e.getAttribute('type') == 'submit' ? 'click' : 'input', select: e => 'change', textarea: e => 'input' }; function $r (e) { throw new Error(e) } function Wr (e) { try { return JSON.parse(e) } catch (t) { return e } } class Ur {constructor (e, t) { this.context = e, this.action = t } get index () { return this.action.index } get eventTarget () { return this.action.eventTarget } get eventOptions () { return this.action.eventOptions } get identifier () { return this.context.identifier }handleEvent (e) { this.willBeInvokedByEvent(e) && this.shouldBeInvokedPerSelf(e) && (this.processStopPropagation(e), this.processPreventDefault(e), this.invokeWithEvent(e)) } get eventName () { return this.action.eventName } get method () { const e = this.controller[this.methodName]; if (typeof e === 'function') return e; throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`) }processStopPropagation (e) { this.eventOptions.stop && e.stopPropagation() }processPreventDefault (e) { this.eventOptions.prevent && e.preventDefault() }invokeWithEvent (e) { const { target: t, currentTarget: i } = e; try { const { params: s } = this.action; const n = Object.assign(e, { params: s }); this.method.call(this.controller, n), this.context.logDebugActivity(this.methodName, { event: e, target: t, currentTarget: i, action: this.methodName }) } catch (t) { const { identifier: i, controller: s, element: n, index: r } = this; const o = { identifier: i, controller: s, element: n, index: r, event: e }; this.context.handleError(t, `invoking action "${this.action}"`, o) } }shouldBeInvokedPerSelf (e) { return !0 !== this.action.eventOptions.self || this.action.element === e.target }willBeInvokedByEvent (e) { const t = e.target; return this.element === t || (t instanceof Element && this.element.contains(t) ? this.scope.containsElement(t) : this.scope.containsElement(this.action.element)) } get controller () { return this.context.controller } get methodName () { return this.action.methodName } get element () { return this.scope.element } get scope () { return this.context.scope }} class Kr {constructor (e, t) { this.mutationObserverInit = { attributes: !0, childList: !0, subtree: !0 }, this.element = e, this.started = !1, this.delegate = t, this.elements = new Set(), this.mutationObserver = new MutationObserver(e => this.processMutations(e)) }start () { this.started || (this.started = !0, this.mutationObserver.observe(this.element, this.mutationObserverInit), this.refresh()) }pause (e) { this.started && (this.mutationObserver.disconnect(), this.started = !1), e(), this.started || (this.mutationObserver.observe(this.element, this.mutationObserverInit), this.started = !0) }stop () { this.started && (this.mutationObserver.takeRecords(), this.mutationObserver.disconnect(), this.started = !1) }refresh () { if (this.started) { const e = new Set(this.matchElementsInTree()); for (const t of Array.from(this.elements))e.has(t) || this.removeElement(t); for (const t of Array.from(e)) this.addElement(t) } }processMutations (e) { if (this.started) for (const t of e) this.processMutation(t) }processMutation (e) { e.type == 'attributes' ? this.processAttributeChange(e.target, e.attributeName) : e.type == 'childList' && (this.processRemovedNodes(e.removedNodes), this.processAddedNodes(e.addedNodes)) }processAttributeChange (e, t) { const i = e; this.elements.has(i) ? this.delegate.elementAttributeChanged && this.matchElement(i) ? this.delegate.elementAttributeChanged(i, t) : this.removeElement(i) : this.matchElement(i) && this.addElement(i) }processRemovedNodes (e) { for (const t of Array.from(e)) { const e = this.elementFromNode(t); e && this.processTree(e, this.removeElement) } }processAddedNodes (e) { for (const t of Array.from(e)) { const e = this.elementFromNode(t); e && this.elementIsActive(e) && this.processTree(e, this.addElement) } }matchElement (e) { return this.delegate.matchElement(e) }matchElementsInTree (e = this.element) { return this.delegate.matchElementsInTree(e) }processTree (e, t) { for (const i of this.matchElementsInTree(e))t.call(this, i) }elementFromNode (e) { if (e.nodeType == Node.ELEMENT_NODE) return e }elementIsActive (e) { return e.isConnected == this.element.isConnected && this.element.contains(e) }addElement (e) { this.elements.has(e) || this.elementIsActive(e) && (this.elements.add(e), this.delegate.elementMatched && this.delegate.elementMatched(e)) }removeElement (e) { this.elements.has(e) && (this.elements.delete(e), this.delegate.elementUnmatched && this.delegate.elementUnmatched(e)) }} class zr {constructor (e, t, i) { this.attributeName = t, this.delegate = i, this.elementObserver = new Kr(e, this) } get element () { return this.elementObserver.element } get selector () { return `[${this.attributeName}]` }start () { this.elementObserver.start() }pause (e) { this.elementObserver.pause(e) }stop () { this.elementObserver.stop() }refresh () { this.elementObserver.refresh() } get started () { return this.elementObserver.started }matchElement (e) { return e.hasAttribute(this.attributeName) }matchElementsInTree (e) { const t = this.matchElement(e) ? [e] : []; const i = Array.from(e.querySelectorAll(this.selector)); return t.concat(i) }elementMatched (e) { this.delegate.elementMatchedAttribute && this.delegate.elementMatchedAttribute(e, this.attributeName) }elementUnmatched (e) { this.delegate.elementUnmatchedAttribute && this.delegate.elementUnmatchedAttribute(e, this.attributeName) }elementAttributeChanged (e, t) { this.delegate.elementAttributeValueChanged && this.attributeName == t && this.delegate.elementAttributeValueChanged(e, t) }} class Qr {constructor (e, t) { this.element = e, this.delegate = t, this.started = !1, this.stringMap = new Map(), this.mutationObserver = new MutationObserver(e => this.processMutations(e)) }start () { this.started || (this.started = !0, this.mutationObserver.observe(this.element, { attributes: !0, attributeOldValue: !0 }), this.refresh()) }stop () { this.started && (this.mutationObserver.takeRecords(), this.mutationObserver.disconnect(), this.started = !1) }refresh () { if (this.started) for (const e of this.knownAttributeNames) this.refreshAttribute(e, null) }processMutations (e) { if (this.started) for (const t of e) this.processMutation(t) }processMutation (e) { const t = e.attributeName; t && this.refreshAttribute(t, e.oldValue) }refreshAttribute (e, t) { const i = this.delegate.getStringMapKeyForAttribute(e); if (i != null) { this.stringMap.has(e) || this.stringMapKeyAdded(i, e); const s = this.element.getAttribute(e); if (this.stringMap.get(e) != s && this.stringMapValueChanged(s, i, t), s == null) { const t = this.stringMap.get(e); this.stringMap.delete(e), t && this.stringMapKeyRemoved(i, e, t) } else this.stringMap.set(e, s) } }stringMapKeyAdded (e, t) { this.delegate.stringMapKeyAdded && this.delegate.stringMapKeyAdded(e, t) }stringMapValueChanged (e, t, i) { this.delegate.stringMapValueChanged && this.delegate.stringMapValueChanged(e, t, i) }stringMapKeyRemoved (e, t, i) { this.delegate.stringMapKeyRemoved && this.delegate.stringMapKeyRemoved(e, t, i) } get knownAttributeNames () { return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames))) } get currentAttributeNames () { return Array.from(this.element.attributes).map(e => e.name) } get recordedAttributeNames () { return Array.from(this.stringMap.keys()) }} function Gr (e, t) { let i = e.get(t); return i || (i = new Set(), e.set(t, i)), i } class Yr {constructor () { this.valuesByKey = new Map() } get keys () { return Array.from(this.valuesByKey.keys()) } get values () { return Array.from(this.valuesByKey.values()).reduce((e, t) => e.concat(Array.from(t)), []) } get size () { return Array.from(this.valuesByKey.values()).reduce((e, t) => e + t.size, 0) }add (e, t) { !(function (e, t, i) { Gr(e, t).add(i) }(this.valuesByKey, e, t)) }delete (e, t) { !(function (e, t, i) { Gr(e, t).delete(i), (function (e, t) { const i = e.get(t); i != null && i.size == 0 && e.delete(t) }(e, t)) }(this.valuesByKey, e, t)) }has (e, t) { const i = this.valuesByKey.get(e); return i != null && i.has(t) }hasKey (e) { return this.valuesByKey.has(e) }hasValue (e) { return Array.from(this.valuesByKey.values()).some(t => t.has(e)) }getValuesForKey (e) { const t = this.valuesByKey.get(e); return t ? Array.from(t) : [] }getKeysForValue (e) { return Array.from(this.valuesByKey).filter(([t, i]) => i.has(e)).map(([e, t]) => e) }} class Xr {constructor (e, t, i) { this.attributeObserver = new zr(e, t, this), this.delegate = i, this.tokensByElement = new Yr() } get started () { return this.attributeObserver.started }start () { this.attributeObserver.start() }pause (e) { this.attributeObserver.pause(e) }stop () { this.attributeObserver.stop() }refresh () { this.attributeObserver.refresh() } get element () { return this.attributeObserver.element } get attributeName () { return this.attributeObserver.attributeName }elementMatchedAttribute (e) { this.tokensMatched(this.readTokensForElement(e)) }elementAttributeValueChanged (e) { const [t, i] = this.refreshTokensForElement(e); this.tokensUnmatched(t), this.tokensMatched(i) }elementUnmatchedAttribute (e) { this.tokensUnmatched(this.tokensByElement.getValuesForKey(e)) }tokensMatched (e) { e.forEach(e => this.tokenMatched(e)) }tokensUnmatched (e) { e.forEach(e => this.tokenUnmatched(e)) }tokenMatched (e) { this.delegate.tokenMatched(e), this.tokensByElement.add(e.element, e) }tokenUnmatched (e) { this.delegate.tokenUnmatched(e), this.tokensByElement.delete(e.element, e) }refreshTokensForElement (e) { const t = this.tokensByElement.getValuesForKey(e); const i = this.readTokensForElement(e); const s = (function (e, t) { const i = Math.max(e.length, t.length); return Array.from({ length: i }, (i, s) => [e[s], t[s]]) }(t, i)).findIndex(([e, t]) => !(function (e, t) { return e && t && e.index == t.index && e.content == t.content }(e, t))); return s == -1 ? [[], []] : [t.slice(s), i.slice(s)] }readTokensForElement (e) { const t = this.attributeName; return (function (e, t, i) { return e.trim().split(/\s+/).filter(e => e.length).map((e, s) => ({ element: t, attributeName: i, content: e, index: s })) }(e.getAttribute(t) || '', e, t)) }} class Jr {constructor (e, t, i) { this.tokenListObserver = new Xr(e, t, this), this.delegate = i, this.parseResultsByToken = new WeakMap(), this.valuesByTokenByElement = new WeakMap() } get started () { return this.tokenListObserver.started }start () { this.tokenListObserver.start() }stop () { this.tokenListObserver.stop() }refresh () { this.tokenListObserver.refresh() } get element () { return this.tokenListObserver.element } get attributeName () { return this.tokenListObserver.attributeName }tokenMatched (e) { const { element: t } = e; const { value: i } = this.fetchParseResultForToken(e); i && (this.fetchValuesByTokenForElement(t).set(e, i), this.delegate.elementMatchedValue(t, i)) }tokenUnmatched (e) { const { element: t } = e; const { value: i } = this.fetchParseResultForToken(e); i && (this.fetchValuesByTokenForElement(t).delete(e), this.delegate.elementUnmatchedValue(t, i)) }fetchParseResultForToken (e) { let t = this.parseResultsByToken.get(e); return t || (t = this.parseToken(e), this.parseResultsByToken.set(e, t)), t }fetchValuesByTokenForElement (e) { let t = this.valuesByTokenByElement.get(e); return t || (t = new Map(), this.valuesByTokenByElement.set(e, t)), t }parseToken (e) { try { return { value: this.delegate.parseValueForToken(e) } } catch (e) { return { error: e } } }} class Zr {constructor (e, t) { this.context = e, this.delegate = t, this.bindingsByAction = new Map() }start () { this.valueListObserver || (this.valueListObserver = new Jr(this.element, this.actionAttribute, this), this.valueListObserver.start()) }stop () { this.valueListObserver && (this.valueListObserver.stop(), delete this.valueListObserver, this.disconnectAllActions()) } get element () { return this.context.element } get identifier () { return this.context.identifier } get actionAttribute () { return this.schema.actionAttribute } get schema () { return this.context.schema } get bindings () { return Array.from(this.bindingsByAction.values()) }connectAction (e) { const t = new Ur(this.context, e); this.bindingsByAction.set(e, t), this.delegate.bindingConnected(t) }disconnectAction (e) { const t = this.bindingsByAction.get(e); t && (this.bindingsByAction.delete(e), this.delegate.bindingDisconnected(t)) }disconnectAllActions () { this.bindings.forEach(e => this.delegate.bindingDisconnected(e)), this.bindingsByAction.clear() }parseValueForToken (e) { const t = Hr.forToken(e); if (t.identifier == this.identifier) return t }elementMatchedValue (e, t) { this.connectAction(t) }elementUnmatchedValue (e, t) { this.disconnectAction(t) }} class eo {constructor (e, t) { this.context = e, this.receiver = t, this.stringMapObserver = new Qr(this.element, this), this.valueDescriptorMap = this.controller.valueDescriptorMap }start () { this.stringMapObserver.start(), this.invokeChangedCallbacksForDefaultValues() }stop () { this.stringMapObserver.stop() } get element () { return this.context.element } get controller () { return this.context.controller }getStringMapKeyForAttribute (e) { if (e in this.valueDescriptorMap) return this.valueDescriptorMap[e].name }stringMapKeyAdded (e, t) { const i = this.valueDescriptorMap[t]; this.hasValue(e) || this.invokeChangedCallback(e, i.writer(this.receiver[e]), i.writer(i.defaultValue)) }stringMapValueChanged (e, t, i) { const s = this.valueDescriptorNameMap[t]; e !== null && (i === null && (i = s.writer(s.defaultValue)), this.invokeChangedCallback(t, e, i)) }stringMapKeyRemoved (e, t, i) { const s = this.valueDescriptorNameMap[e]; this.hasValue(e) ? this.invokeChangedCallback(e, s.writer(this.receiver[e]), i) : this.invokeChangedCallback(e, s.writer(s.defaultValue), i) }invokeChangedCallbacksForDefaultValues () { for (const { key: e, name: t, defaultValue: i, writer: s } of this.valueDescriptors)i == null || this.controller.data.has(e) || this.invokeChangedCallback(t, s(i), void 0) }invokeChangedCallback (e, t, i) { const s = `${e}Changed`; const n = this.receiver[s]; if (typeof n === 'function') { const s = this.valueDescriptorNameMap[e]; try { const e = s.reader(t); let r = i; i && (r = s.reader(i)), n.call(this.receiver, e, r) } catch (e) { if (!(e instanceof TypeError)) throw e; throw new TypeError(`Stimulus Value "${this.context.identifier}.${s.name}" - ${e.message}`) } } } get valueDescriptors () { const { valueDescriptorMap: e } = this; return Object.keys(e).map(t => e[t]) } get valueDescriptorNameMap () { const e = {}; return Object.keys(this.valueDescriptorMap).forEach(t => { const i = this.valueDescriptorMap[t]; e[i.name] = i }), e }hasValue (e) { const t = `has${jr(this.valueDescriptorNameMap[e].name)}`; return this.receiver[t] }} class to {constructor (e, t) { this.context = e, this.delegate = t, this.targetsByName = new Yr() }start () { this.tokenListObserver || (this.tokenListObserver = new Xr(this.element, this.attributeName, this), this.tokenListObserver.start()) }stop () { this.tokenListObserver && (this.disconnectAllTargets(), this.tokenListObserver.stop(), delete this.tokenListObserver) }tokenMatched ({ element: e, content: t }) { this.scope.containsElement(e) && this.connectTarget(e, t) }tokenUnmatched ({ element: e, content: t }) { this.disconnectTarget(e, t) }connectTarget (e, t) { let i; this.targetsByName.has(t, e) || (this.targetsByName.add(t, e), (i = this.tokenListObserver) === null || void 0 === i || i.pause(() => this.delegate.targetConnected(e, t))) }disconnectTarget (e, t) { let i; this.targetsByName.has(t, e) && (this.targetsByName.delete(t, e), (i = this.tokenListObserver) === null || void 0 === i || i.pause(() => this.delegate.targetDisconnected(e, t))) }disconnectAllTargets () { for (const e of this.targetsByName.keys) for (const t of this.targetsByName.getValuesForKey(e)) this.disconnectTarget(t, e) } get attributeName () { return `data-${this.context.identifier}-target` } get element () { return this.context.element } get scope () { return this.context.scope }} class io {constructor (e, t) { this.logDebugActivity = (e, t = {}) => { const { identifier: i, controller: s, element: n } = this; t = Object.assign({ identifier: i, controller: s, element: n }, t), this.application.logDebugActivity(this.identifier, e, t) }, this.module = e, this.scope = t, this.controller = new e.controllerConstructor(this), this.bindingObserver = new Zr(this, this.dispatcher), this.valueObserver = new eo(this, this.controller), this.targetObserver = new to(this, this); try { this.controller.initialize(), this.logDebugActivity('initialize') } catch (e) { this.handleError(e, 'initializing controller') } }connect () { this.bindingObserver.start(), this.valueObserver.start(), this.targetObserver.start(); try { this.controller.connect(), this.logDebugActivity('connect') } catch (e) { this.handleError(e, 'connecting controller') } }disconnect () { try { this.controller.disconnect(), this.logDebugActivity('disconnect') } catch (e) { this.handleError(e, 'disconnecting controller') } this.targetObserver.stop(), this.valueObserver.stop(), this.bindingObserver.stop() } get application () { return this.module.application } get identifier () { return this.module.identifier } get schema () { return this.application.schema } get dispatcher () { return this.application.dispatcher } get element () { return this.scope.element } get parentElement () { return this.element.parentElement }handleError (e, t, i = {}) { const { identifier: s, controller: n, element: r } = this; i = Object.assign({ identifier: s, controller: n, element: r }, i), this.application.handleError(e, `Error ${t}`, i) }targetConnected (e, t) { this.invokeControllerMethod(`${t}TargetConnected`, e) }targetDisconnected (e, t) { this.invokeControllerMethod(`${t}TargetDisconnected`, e) }invokeControllerMethod (e, ...t) { const i = this.controller; typeof i[e] === 'function' && i[e](...t) }} function so (e, t) { const i = ro(e); return Array.from(i.reduce((e, i) => ((function (e, t) { const i = e[t]; return Array.isArray(i) ? i : [] }(i, t)).forEach(t => e.add(t)), e), new Set())) } function no (e, t) { return ro(e).reduce((e, i) => (e.push(...(function (e, t) { const i = e[t]; return i ? Object.keys(i).map(e => [e, i[e]]) : [] }(i, t))), e), []) } function ro (e) { const t = []; for (;e;)t.push(e), e = Object.getPrototypeOf(e); return t.reverse() } function oo (e) { return (function (e, t) { const i = co(e); const s = (function (e, t) { return ao(t).reduce((i, s) => { const n = (function (e, t, i) { const s = Object.getOwnPropertyDescriptor(e, i); if (!s || !('value' in s)) { const e = Object.getOwnPropertyDescriptor(t, i).value; return s && (e.get = s.get || e.get, e.set = s.set || e.set), e } }(e, t, s)); return n && Object.assign(i, { [s]: n }), i }, {}) }(e.prototype, t)); return Object.defineProperties(i.prototype, s), i }(e, (function (e) { return so(e, 'blessings').reduce((t, i) => { const s = i(e); for (const e in s) { const i = t[e] || {}; t[e] = Object.assign(i, s[e]) } return t }, {}) }(e)))) } const ao = typeof Object.getOwnPropertySymbols === 'function' ? e => [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)] : Object.getOwnPropertyNames; const co = (() => { function e (e) { function t () { return Reflect.construct(e, arguments, new.target) } return t.prototype = Object.create(e.prototype, { constructor: { value: t } }), Reflect.setPrototypeOf(t, e), t } try { return (function () { const t = e(function () { this.a.call(this) }); t.prototype.a = function () {}, new t() }()), e } catch (e) { return e => class extends e {} } })(); class lo {constructor (e, t) { this.application = e, this.definition = (function (e) { return { identifier: e.identifier, controllerConstructor: oo(e.controllerConstructor) } }(t)), this.contextsByScope = new WeakMap(), this.connectedContexts = new Set() } get identifier () { return this.definition.identifier } get controllerConstructor () { return this.definition.controllerConstructor } get contexts () { return Array.from(this.connectedContexts) }connectContextForScope (e) { const t = this.fetchContextForScope(e); this.connectedContexts.add(t), t.connect() }disconnectContextForScope (e) { const t = this.contextsByScope.get(e); t && (this.connectedContexts.delete(t), t.disconnect()) }fetchContextForScope (e) { let t = this.contextsByScope.get(e); return t || (t = new io(this, e), this.contextsByScope.set(e, t)), t }} class ho {constructor (e) { this.scope = e }has (e) { return this.data.has(this.getDataKey(e)) }get (e) { return this.getAll(e)[0] }getAll (e) { const t = this.data.get(this.getDataKey(e)) || ''; return t.match(/[^\s]+/g) || [] }getAttributeName (e) { return this.data.getAttributeNameForKey(this.getDataKey(e)) }getDataKey (e) { return `${e}-class` } get data () { return this.scope.data }} class uo {constructor (e) { this.scope = e } get element () { return this.scope.element } get identifier () { return this.scope.identifier }get (e) { const t = this.getAttributeNameForKey(e); return this.element.getAttribute(t) }set (e, t) { const i = this.getAttributeNameForKey(e); return this.element.setAttribute(i, t), this.get(e) }has (e) { const t = this.getAttributeNameForKey(e); return this.element.hasAttribute(t) }delete (e) { if (this.has(e)) { const t = this.getAttributeNameForKey(e); return this.element.removeAttribute(t), !0 } return !1 }getAttributeNameForKey (e) { return `data-${this.identifier}-${qr(e)}` }} class po {constructor (e) { this.warnedKeysByObject = new WeakMap(), this.logger = e }warn (e, t, i) { let s = this.warnedKeysByObject.get(e); s || (s = new Set(), this.warnedKeysByObject.set(e, s)), s.has(t) || (s.add(t), this.logger.warn(i, e)) }} function mo (e, t) { return `[${e}~="${t}"]` } class fo {constructor (e) { this.scope = e } get element () { return this.scope.element } get identifier () { return this.scope.identifier } get schema () { return this.scope.schema }has (e) { return this.find(e) != null }find (...e) { return e.reduce((e, t) => e || this.findTarget(t) || this.findLegacyTarget(t), void 0) }findAll (...e) { return e.reduce((e, t) => [...e, ...this.findAllTargets(t), ...this.findAllLegacyTargets(t)], []) }findTarget (e) { const t = this.getSelectorForTargetName(e); return this.scope.findElement(t) }findAllTargets (e) { const t = this.getSelectorForTargetName(e); return this.scope.findAllElements(t) }getSelectorForTargetName (e) { return mo(this.schema.targetAttributeForScope(this.identifier), e) }findLegacyTarget (e) { const t = this.getLegacySelectorForTargetName(e); return this.deprecate(this.scope.findElement(t), e) }findAllLegacyTargets (e) { const t = this.getLegacySelectorForTargetName(e); return this.scope.findAllElements(t).map(t => this.deprecate(t, e)) }getLegacySelectorForTargetName (e) { const t = `${this.identifier}.${e}`; return mo(this.schema.targetAttribute, t) }deprecate (e, t) { if (e) { const { identifier: i } = this; const s = this.schema.targetAttribute; const n = this.schema.targetAttributeForScope(i); this.guide.warn(e, `target:${t}`, `Please replace ${s}="${i}.${t}" with ${n}="${t}". The ${s} attribute is deprecated and will be removed in a future version of Stimulus.`) } return e } get guide () { return this.scope.guide }} class go {constructor (e, t, i, s) { this.targets = new fo(this), this.classes = new ho(this), this.data = new uo(this), this.containsElement = e => e.closest(this.controllerSelector) === this.element, this.schema = e, this.element = t, this.identifier = i, this.guide = new po(s) }findElement (e) { return this.element.matches(e) ? this.element : this.queryElements(e).find(this.containsElement) }findAllElements (e) { return [...this.element.matches(e) ? [this.element] : [], ...this.queryElements(e).filter(this.containsElement)] }queryElements (e) { return Array.from(this.element.querySelectorAll(e)) } get controllerSelector () { return mo(this.schema.controllerAttribute, this.identifier) }} class bo {constructor (e, t, i) { this.element = e, this.schema = t, this.delegate = i, this.valueListObserver = new Jr(this.element, this.controllerAttribute, this), this.scopesByIdentifierByElement = new WeakMap(), this.scopeReferenceCounts = new WeakMap() }start () { this.valueListObserver.start() }stop () { this.valueListObserver.stop() } get controllerAttribute () { return this.schema.controllerAttribute }parseValueForToken (e) { const { element: t, content: i } = e; const s = this.fetchScopesByIdentifierForElement(t); let n = s.get(i); return n || (n = this.delegate.createScopeForElementAndIdentifier(t, i), s.set(i, n)), n }elementMatchedValue (e, t) { const i = (this.scopeReferenceCounts.get(t) || 0) + 1; this.scopeReferenceCounts.set(t, i), i == 1 && this.delegate.scopeConnected(t) }elementUnmatchedValue (e, t) { const i = this.scopeReferenceCounts.get(t); i && (this.scopeReferenceCounts.set(t, i - 1), i == 1 && this.delegate.scopeDisconnected(t)) }fetchScopesByIdentifierForElement (e) { let t = this.scopesByIdentifierByElement.get(e); return t || (t = new Map(), this.scopesByIdentifierByElement.set(e, t)), t }} class vo {constructor (e) { this.application = e, this.scopeObserver = new bo(this.element, this.schema, this), this.scopesByIdentifier = new Yr(), this.modulesByIdentifier = new Map() } get element () { return this.application.element } get schema () { return this.application.schema } get logger () { return this.application.logger } get controllerAttribute () { return this.schema.controllerAttribute } get modules () { return Array.from(this.modulesByIdentifier.values()) } get contexts () { return this.modules.reduce((e, t) => e.concat(t.contexts), []) }start () { this.scopeObserver.start() }stop () { this.scopeObserver.stop() }loadDefinition (e) { this.unloadIdentifier(e.identifier); const t = new lo(this.application, e); this.connectModule(t) }unloadIdentifier (e) { const t = this.modulesByIdentifier.get(e); t && this.disconnectModule(t) }getContextForElementAndIdentifier (e, t) { const i = this.modulesByIdentifier.get(t); if (i) return i.contexts.find(t => t.element == e) }handleError (e, t, i) { this.application.handleError(e, t, i) }createScopeForElementAndIdentifier (e, t) { return new go(this.schema, e, t, this.logger) }scopeConnected (e) { this.scopesByIdentifier.add(e.identifier, e); const t = this.modulesByIdentifier.get(e.identifier); t && t.connectContextForScope(e) }scopeDisconnected (e) { this.scopesByIdentifier.delete(e.identifier, e); const t = this.modulesByIdentifier.get(e.identifier); t && t.disconnectContextForScope(e) }connectModule (e) { this.modulesByIdentifier.set(e.identifier, e); this.scopesByIdentifier.getValuesForKey(e.identifier).forEach(t => e.connectContextForScope(t)) }disconnectModule (e) { this.modulesByIdentifier.delete(e.identifier); this.scopesByIdentifier.getValuesForKey(e.identifier).forEach(t => e.disconnectContextForScope(t)) }} const yo = { controllerAttribute: 'data-controller', actionAttribute: 'data-action', targetAttribute: 'data-target', targetAttributeForScope: e => `data-${e}-target` }; class wo {constructor (e = document.documentElement, t = yo) { this.logger = console, this.debug = !1, this.logDebugActivity = (e, t, i = {}) => { this.debug && this.logFormattedMessage(e, t, i) }, this.element = e, this.schema = t, this.dispatcher = new Nr(this), this.router = new vo(this) } static start (e, t) { const i = new wo(e, t); return i.start(), i } async start () { await new Promise(e => { document.readyState == 'loading' ? document.addEventListener('DOMContentLoaded', () => e()) : e() }), this.logDebugActivity('application', 'starting'), this.dispatcher.start(), this.router.start(), this.logDebugActivity('application', 'start') }stop () { this.logDebugActivity('application', 'stopping'), this.dispatcher.stop(), this.router.stop(), this.logDebugActivity('application', 'stop') }register (e, t) { this.load({ identifier: e, controllerConstructor: t }) }load (e, ...t) { (Array.isArray(e) ? e : [e, ...t]).forEach(e => { e.controllerConstructor.shouldLoad && this.router.loadDefinition(e) }) }unload (e, ...t) { (Array.isArray(e) ? e : [e, ...t]).forEach(e => this.router.unloadIdentifier(e)) } get controllers () { return this.router.contexts.map(e => e.controller) }getControllerForElementAndIdentifier (e, t) { const i = this.router.getContextForElementAndIdentifier(e, t); return i ? i.controller : null }handleError (e, t, i) { let s; this.logger.error('%s\n\n%o\n\n%o', t, e, i), (s = window.onerror) === null || void 0 === s || s.call(window, t, '', 0, 0, e) }logFormattedMessage (e, t, i = {}) { i = Object.assign({ application: this }, i), this.logger.groupCollapsed(`${e} #${t}`), this.logger.log('details:', Object.assign({}, i)), this.logger.groupEnd() }} function _o ([e, t], i) { return (function (e) { const t = `${qr(e.token)}-value`; const i = (function (e) { const t = (function (e) { const t = Eo(e.typeObject.type); if (!t) return; const i = So(e.typeObject.default); if (t !== i) { const s = e.controller ? `${e.controller}.${e.token}` : e.token; throw new Error(`The specified default value for the Stimulus Value "${s}" must match the defined type "${t}". The provided default value of "${e.typeObject.default}" is of type "${i}".`) } return t }({ controller: e.controller, token: e.token, typeObject: e.typeDefinition })); const i = So(e.typeDefinition); const s = Eo(e.typeDefinition); const n = t || i || s; if (n) return n; const r = e.controller ? `${e.controller}.${e.typeDefinition}` : e.token; throw new Error(`Unknown value type "${r}" for "${e.token}" value`) }(e)); return { type: i, key: t, name: Br(t), get defaultValue () { return (function (e) { const t = Eo(e); if (t) return Ao[t]; const i = e.default; return void 0 !== i ? i : e }(e.typeDefinition)) }, get hasCustomDefaultValue () { return void 0 !== So(e.typeDefinition) }, reader: Co[i], writer: ko[i] || ko.default } }({ controller: i, token: e, typeDefinition: t })) } function Eo (e) { switch (e) { case Array:return 'array'; case Boolean:return 'boolean'; case Number:return 'number'; case Object:return 'object'; case String:return 'string' } } function So (e) { switch (typeof e) { case 'boolean':return 'boolean'; case 'number':return 'number'; case 'string':return 'string' } return Array.isArray(e) ? 'array' : Object.prototype.toString.call(e) === '[object Object]' ? 'object' : void 0 } const Ao = { get array () { return [] }, boolean: !1, number: 0, get object () { return {} }, string: '' }; const Co = { array (e) { const t = JSON.parse(e); if (!Array.isArray(t)) throw new TypeError(`expected value of type "array" but instead got value "${e}" of type "${So(t)}"`); return t }, boolean: e => !(e == '0' || String(e).toLowerCase() == 'false'), number: e => Number(e), object (e) { const t = JSON.parse(e); if (t === null || typeof t !== 'object' || Array.isArray(t)) throw new TypeError(`expected value of type "object" but instead got value "${e}" of type "${So(t)}"`); return t }, string: e => e }; const ko = { default: function (e) { return `${e}` }, array: To, object: To }; function To (e) { return JSON.stringify(e) } class Lo {constructor (e) { this.context = e } static get shouldLoad () { return !0 } get application () { return this.context.application } get scope () { return this.context.scope } get element () { return this.scope.element } get identifier () { return this.scope.identifier } get targets () { return this.scope.targets } get classes () { return this.scope.classes } get data () { return this.scope.data }initialize () {}connect () {}disconnect () {}dispatch (e, { target: t = this.element, detail: i = {}, prefix: s = this.identifier, bubbles: n = !0, cancelable: r = !0 } = {}) { const o = new CustomEvent(s ? `${s}:${e}` : e, { detail: i, bubbles: n, cancelable: r }); return t.dispatchEvent(o), o }}Lo.blessings = [function (e) { return so(e, 'classes').reduce((e, t) => { return Object.assign(e, { [`${i = t}Class`]: { get () { const { classes: e } = this; if (e.has(i)) return e.get(i); { const t = e.getAttributeName(i); throw new Error(`Missing attribute "${t}"`) } } }, [`${i}Classes`]: { get () { return this.classes.getAll(i) } }, [`has${jr(i)}Class`]: { get () { return this.classes.has(i) } } }); let i }, {}) }, function (e) { return so(e, 'targets').reduce((e, t) => { return Object.assign(e, { [`${i = t}Target`]: { get () { const e = this.targets.find(i); if (e) return e; throw new Error(`Missing target element "${i}" for "${this.identifier}" controller`) } }, [`${i}Targets`]: { get () { return this.targets.findAll(i) } }, [`has${jr(i)}Target`]: { get () { return this.targets.has(i) } } }); let i }, {}) }, function (e) { const t = no(e, 'values'); const i = { valueDescriptorMap: { get () { return t.reduce((e, t) => { const i = _o(t, this.identifier); const s = this.data.getAttributeNameForKey(i.key); return Object.assign(e, { [s]: i }) }, {}) } } }; return t.reduce((e, t) => Object.assign(e, (function (e, t) { const i = _o(e, t); const { key: s, name: n, reader: r, writer: o } = i; return { [n]: { get () { const e = this.data.get(s); return e !== null ? r(e) : i.defaultValue }, set (e) { void 0 === e ? this.data.delete(s) : this.data.set(s, o(e)) } }, [`has${jr(n)}`]: { get () { return this.data.has(s) || i.hasCustomDefaultValue } } } }(t))), i) }], Lo.targets = [], Lo.values = {}
/** !
 * hotkeys-js v3.10.0
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
 *
 * Copyright (c) 2022 kenny wong <wowohoo@qq.com>
 * http://jaywcjlove.github.io/hotkeys
 * Licensed under the MIT license
 */
const Oo = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > 0; function Po (e, t, i, s) { e.addEventListener ? e.addEventListener(t, i, s) : e.attachEvent && e.attachEvent('on'.concat(t), function () { i(window.event) }) } function Mo (e, t) { for (var i = t.slice(0, t.length - 1), s = 0; s < i.length; s++)i[s] = e[i[s].toLowerCase()]; return i } function xo (e) { typeof e !== 'string' && (e = ''); for (var t = (e = e.replace(/\s/g, '')).split(','), i = t.lastIndexOf(''); i >= 0;)t[i - 1] += ',', t.splice(i, 1), i = t.lastIndexOf(''); return t } for (var Io = { backspace: 8, '⌫': 8, tab: 9, clear: 12, enter: 13, '↩': 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, ins: 45, insert: 45, home: 36, end: 35, pageup: 33, pagedown: 34, capslock: 20, num_0: 96, num_1: 97, num_2: 98, num_3: 99, num_4: 100, num_5: 101, num_6: 102, num_7: 103, num_8: 104, num_9: 105, num_multiply: 106, num_add: 107, num_enter: 108, num_subtract: 109, num_decimal: 110, num_divide: 111, '⇪': 20, ',': 188, '.': 190, '/': 191, '`': 192, '-': Oo ? 173 : 189, '=': Oo ? 61 : 187, ';': Oo ? 59 : 186, "'": 222, '[': 219, ']': 221, '\\': 220 }, Ro = { '⇧': 16, shift: 16, '⌥': 18, alt: 18, option: 18, '⌃': 17, ctrl: 17, control: 17, '⌘': 91, cmd: 91, command: 91 }, No = { 16: 'shiftKey', 18: 'altKey', 17: 'ctrlKey', 91: 'metaKey', shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 }, Fo = { 16: !1, 18: !1, 17: !1, 91: !1 }, Do = {}, Bo = 1; Bo < 20; Bo++)Io['f'.concat(Bo)] = 111 + Bo; let jo = []; let qo = !1; let Ho = 'all'; const Vo = []; const $o = function (e) { return Io[e.toLowerCase()] || Ro[e.toLowerCase()] || e.toUpperCase().charCodeAt(0) }; function Wo (e) { Ho = e || 'all' } function Uo () { return Ho || 'all' } const Ko = function (e) { const t = e.key; let i = e.scope; const s = e.method; const n = e.splitKey; const r = void 0 === n ? '+' : n; xo(t).forEach(function (e) { const t = e.split(r); const n = t.length; const o = t[n - 1]; const a = o === '*' ? '*' : $o(o); if (Do[a]) { i || (i = Uo()); const c = n > 1 ? Mo(Ro, t) : []; Do[a] = Do[a].filter(function (e) { return !((!s || e.method === s) && e.scope === i && (function (e, t) { for (var i = e.length >= t.length ? e : t, s = e.length >= t.length ? t : e, n = !0, r = 0; r < i.length; r++)s.indexOf(i[r]) === -1 && (n = !1); return n }(e.mods, c))) }) } }) }; function zo (e, t, i, s) { let n; if (t.element === s && (t.scope === i || t.scope === 'all')) { for (const r in n = t.mods.length > 0, Fo)Object.prototype.hasOwnProperty.call(Fo, r) && (!Fo[r] && t.mods.indexOf(+r) > -1 || Fo[r] && t.mods.indexOf(+r) === -1) && (n = !1); (t.mods.length !== 0 || Fo[16] || Fo[18] || Fo[17] || Fo[91]) && !n && t.shortcut !== '*' || !1 === t.method(e, t) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation && e.stopPropagation(), e.cancelBubble && (e.cancelBubble = !0)) } } function Qo (e, t) { const i = Do['*']; let s = e.keyCode || e.which || e.charCode; if (Go.filter.call(this, e)) { if (s !== 93 && s !== 224 || (s = 91), jo.indexOf(s) === -1 && s !== 229 && jo.push(s), ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (t) { const i = No[t]; e[t] && jo.indexOf(i) === -1 ? jo.push(i) : !e[t] && jo.indexOf(i) > -1 ? jo.splice(jo.indexOf(i), 1) : t === 'metaKey' && e[t] && jo.length === 3 && (e.ctrlKey || e.shiftKey || e.altKey || (jo = jo.slice(jo.indexOf(i)))) }), s in Fo) { for (const n in Fo[s] = !0, Ro)Ro[n] === s && (Go[n] = !0); if (!i) return } for (const r in Fo)Object.prototype.hasOwnProperty.call(Fo, r) && (Fo[r] = e[No[r]]); e.getModifierState && (!e.altKey || e.ctrlKey) && e.getModifierState('AltGraph') && (jo.indexOf(17) === -1 && jo.push(17), jo.indexOf(18) === -1 && jo.push(18), Fo[17] = !0, Fo[18] = !0); const o = Uo(); if (i) for (let a = 0; a < i.length; a++)i[a].scope === o && (e.type === 'keydown' && i[a].keydown || e.type === 'keyup' && i[a].keyup) && zo(e, i[a], o, t); if (s in Do) for (let c = 0; c < Do[s].length; c++) if ((e.type === 'keydown' && Do[s][c].keydown || e.type === 'keyup' && Do[s][c].keyup) && Do[s][c].key) { for (var l = Do[s][c], h = l.splitKey, d = l.key.split(h), u = [], p = 0; p < d.length; p++)u.push($o(d[p])); u.sort().join('') === jo.sort().join('') && zo(e, l, o, t) } } } function Go (e, t, i) { jo = []; const s = xo(e); let n = []; let r = 'all'; let o = document; let a = 0; let c = !1; let l = !0; let h = '+'; let d = !1; for (void 0 === i && typeof t === 'function' && (i = t), Object.prototype.toString.call(t) === '[object Object]' && (t.scope && (r = t.scope), t.element && (o = t.element), t.keyup && (c = t.keyup), void 0 !== t.keydown && (l = t.keydown), void 0 !== t.capture && (d = t.capture), typeof t.splitKey === 'string' && (h = t.splitKey)), typeof t === 'string' && (r = t); a < s.length; a++)n = [], (e = s[a].split(h)).length > 1 && (n = Mo(Ro, e)), (e = (e = e[e.length - 1]) === '*' ? '*' : $o(e)) in Do || (Do[e] = []), Do[e].push({ keyup: c, keydown: l, scope: r, mods: n, shortcut: s[a], method: i, key: s[a], splitKey: h, element: o }); void 0 !== o && !(function (e) { return Vo.indexOf(e) > -1 }(o)) && window && (Vo.push(o), Po(o, 'keydown', function (e) { Qo(e, o) }, d), qo || (qo = !0, Po(window, 'focus', function () { jo = [] }, d)), Po(o, 'keyup', function (e) { Qo(e, o), (function (e) { let t = e.keyCode || e.which || e.charCode; const i = jo.indexOf(t); if (i >= 0 && jo.splice(i, 1), e.key && e.key.toLowerCase() === 'meta' && jo.splice(0, jo.length), t !== 93 && t !== 224 || (t = 91), t in Fo) for (const s in Fo[t] = !1, Ro)Ro[s] === t && (Go[s] = !1) }(e)) }, d)) } const Yo = { getPressedKeyString: function () { return jo.map(function (e) { return t = e, Object.keys(Io).find(function (e) { return Io[e] === t }) || (function (e) { return Object.keys(Ro).find(function (t) { return Ro[t] === e }) }(e)) || String.fromCharCode(e); let t }) }, setScope: Wo, getScope: Uo, deleteScope: function (e, t) { let i, s; for (const n in e || (e = Uo()), Do) if (Object.prototype.hasOwnProperty.call(Do, n)) for (i = Do[n], s = 0; s < i.length;)i[s].scope === e ? i.splice(s, 1) : s++; Uo() === e && Wo(t || 'all') }, getPressedKeyCodes: function () { return jo.slice(0) }, isPressed: function (e) { return typeof e === 'string' && (e = $o(e)), jo.indexOf(e) !== -1 }, filter: function (e) { const t = e.target || e.srcElement; const i = t.tagName; let s = !0; return !t.isContentEditable && (i !== 'INPUT' && i !== 'TEXTAREA' && i !== 'SELECT' || t.readOnly) || (s = !1), s }, trigger: function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'all'; Object.keys(Do).forEach(function (i) { const s = Do[i].find(function (i) { return i.scope === t && i.shortcut === e }); s && s.method && s.method() }) }, unbind: function (e) { if (void 0 === e)Object.keys(Do).forEach(function (e) { return delete Do[e] }); else if (Array.isArray(e))e.forEach(function (e) { e.key && Ko(e) }); else if (typeof e === 'object')e.key && Ko(e); else if (typeof e === 'string') { for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)i[s - 1] = arguments[s]; let n = i[0]; let r = i[1]; typeof n === 'function' && (r = n, n = ''), Ko({ key: e, scope: n, method: r, splitKey: '+' }) } }, keyMap: Io, modifier: Ro, modifierMap: No }; for (const Xo in Yo)Object.prototype.hasOwnProperty.call(Yo, Xo) && (Go[Xo] = Yo[Xo]); if (typeof window !== 'undefined') { const Jo = window.hotkeys; Go.noConflict = function (e) { return e && window.hotkeys === Go && (window.hotkeys = Jo), Go }, window.hotkeys = Go }(class extends Lo {}).debounces = []; const Zo = (e, t = 200) => { let i = null; return function () { const s = arguments; const n = this; const r = () => e.apply(n, s); i && clearTimeout(i), i = setTimeout(r, t) } }; const ea = (e, t) => { const i = e; i.constructor.debounces.forEach(e => { if (typeof e === 'string' && (i[e] = Zo(i[e], t == null ? void 0 : t.wait)), typeof e === 'object') { const { name: s, wait: n } = e; if (!s) return; i[s] = Zo(i[s], n || (t == null ? void 0 : t.wait)) } }) }; (class extends Lo {}).throttles = []; window.Stimulus = wo.start(), Stimulus.register('bs-instance', class extends Lo {static values = { class: String, connection: String, method: String }; connect () { if (this.hasConnectionValue) { const e = bootstrap[this.classValue].getOrCreateInstance(this.element); if (e == null) return; e[this.connectionValue]() } }manipulate () { const e = bootstrap[this.classValue].getInstance(this.element); e != null && e[this.methodValue]() }}), Stimulus.register('form', class extends Lo {static targets = ['submitButton', 'radioButton', 'optionTypeContainer']; static values = { delay: { default: 0, type: Number } }; static debounces = [{ name: 'submitViaClick' }]; initialize () { this.submitViaClick = this.submitViaClick.bind(this) }connect () { ea(this, { wait: this.delayValue }), this.hasSubmitButtonTarget && (this.submitButtonTarget.style.display = 'none') }submitViaClick (e) { this.submitButtonTarget.click() }submitWithNearestSubmitButton (e) { this.submitButtonTarget.click() }removeSelection (e) { this.radioButtonTargets.forEach(t => { t.dataset.radioIndexValue >= e.target.dataset.radioIndexValue && (t.checked = !1) }) }resetRadiosWithHigherIndex (e) { this.radioButtonTargets.forEach(t => { t.dataset.radioIndexValue > e.target.dataset.radioIndexValue && (t.checked = !1, t.disabled = !0) }) }optionContainterCheck (e) { this.optionTypeContainerTargets.forEach(e => { if (e.querySelector('input[type="radio"]:checked')) { const t = e.querySelector('.reset-selection'); t && (t.style.display = 'block') } }) }}), Stimulus.register('modal', class extends Lo {connect () { if (document.documentElement.hasAttribute('data-turbo-preview')) { const e = document.querySelector('.modal-backdrop'); e && e.remove() } else this.modal = new bootstrap.Modal(this.element, { keyboard: !1 }), this.modal.show() }disconnect () { this.modal && this.modal.dispose() }submitEnd (e) { !0 !== e.detail.formSubmission.submitter.formNoValidate && e.detail.success && this.modal.hide() }}), Stimulus.register('micro-form', class extends Lo {static targets = ['submitButton', 'radioButton', 'optionTypeContainer']; static values = { delay: { default: 0, type: Number } }; static debounces = [{ name: 'submitViaClick' }]; initialize () { this.submitViaClick = this.submitViaClick.bind(this) }connect () { ea(this, { wait: this.delayValue }), this.hasSubmitButtonTarget && (this.submitButtonTarget.style.display = 'none') }submitViaClick (e) { this.submitButtonTarget.click() }}); let ta; const ia = { exports: {} }
/*!
 * jsUri
 * https://github.com/derek-watson/jsUri
 *
 * Copyright 2013, Derek Watson
 * Released under the MIT license.
 *
 * Includes parseUri regular expressions
 * http://blog.stevenlevithan.com/archives/parseuri
 * Copyright 2007, Steven Levithan
 * Released under the MIT license.
 */ta = ia, (function (e) { const t = { starts_with_slashes: /^\/+/, ends_with_slashes: /\/+$/, pluses: /\+/g, query_separator: /[&;]/, uri_parser: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*)(?::([^:@]*))?)?@)?(\[[0-9a-fA-F:.]+\]|[^:\/?#]*)(?::(\d+|(?=:)))?(:)?)((((?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ }; function i (e) { return e && (e = e.toString().replace(t.pluses, '%20'), e = decodeURIComponent(e)), e } function s (e) { let s; let n; let r; let o; let a; let c; let l; const h = []; if (e == null || e === '') return h; for (e.indexOf('?') === 0 && (e = e.substring(1)), s = 0, l = (n = e.toString().split(t.query_separator)).length; s < l; s++)(o = (r = n[s]).indexOf('=')) !== 0 && (a = i(r.substring(0, o)), c = i(r.substring(o + 1)), h.push(o === -1 ? [r, null] : [a, c])); return h } function n (e) { this.uriParts = (function (e) { const i = t.uri_parser.exec(e || ''); const s = {}; return ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'isColonUri', 'relative', 'path', 'directory', 'file', 'query', 'anchor'].forEach(function (e, t) { s[e] = i[t] || '' }), s }(e)), this.queryPairs = s(this.uriParts.query), this.hasAuthorityPrefixUserPref = null }Array.prototype.forEach || (Array.prototype.forEach = function (e, t) { let i, s; if (this == null) throw new TypeError(' this is null or not defined'); const n = Object(this); const r = n.length >>> 0; if (typeof e !== 'function') throw new TypeError(e + ' is not a function'); for (arguments.length > 1 && (i = t), s = 0; s < r;) { var o; s in n && (o = n[s], e.call(i, o, s, n)), s++ } }), ['protocol', 'userInfo', 'host', 'port', 'path', 'anchor'].forEach(function (e) { n.prototype[e] = function (t) { return void 0 !== t && (this.uriParts[e] = t), this.uriParts[e] } }), n.prototype.hasAuthorityPrefix = function (e) { return void 0 !== e && (this.hasAuthorityPrefixUserPref = e), this.hasAuthorityPrefixUserPref === null ? this.uriParts.source.indexOf('//') !== -1 : this.hasAuthorityPrefixUserPref }, n.prototype.isColonUri = function (e) { if (void 0 === e) return !!this.uriParts.isColonUri; this.uriParts.isColonUri = !!e }, n.prototype.query = function (e) { let t; let i; let n; let r = ''; for (void 0 !== e && (this.queryPairs = s(e)), t = 0, n = this.queryPairs.length; t < n; t++)i = this.queryPairs[t], r.length > 0 && (r += '&'), i[1] === null ? r += i[0] : (r += i[0], r += '=', void 0 !== i[1] && (r += encodeURIComponent(i[1]))); return r.length > 0 ? '?' + r : r }, n.prototype.getQueryParamValue = function (e) { let t, i, s; for (i = 0, s = this.queryPairs.length; i < s; i++) if (e === (t = this.queryPairs[i])[0]) return t[1] }, n.prototype.getQueryParamValues = function (e) { let t; let i; let s; const n = []; for (t = 0, s = this.queryPairs.length; t < s; t++)e === (i = this.queryPairs[t])[0] && n.push(i[1]); return n }, n.prototype.deleteQueryParam = function (e, t) { let s; let n; let r; let o; let a; const c = []; for (s = 0, a = this.queryPairs.length; s < a; s++)r = i((n = this.queryPairs[s])[0]) === i(e), o = n[1] === t, (arguments.length !== 1 || r) && (arguments.length !== 2 || r && o) || c.push(n); return this.queryPairs = c, this }, n.prototype.addQueryParam = function (e, t, i) { return arguments.length === 3 && i !== -1 ? (i = Math.min(i, this.queryPairs.length), this.queryPairs.splice(i, 0, [e, t])) : arguments.length > 0 && this.queryPairs.push([e, t]), this }, n.prototype.hasQueryParam = function (e) { let t; const i = this.queryPairs.length; for (t = 0; t < i; t++) if (this.queryPairs[t][0] == e) return !0; return !1 }, n.prototype.replaceQueryParam = function (e, t, s) { let n; let r; let o = -1; const a = this.queryPairs.length; if (arguments.length === 3) { for (n = 0; n < a; n++) if (i((r = this.queryPairs[n])[0]) === i(e) && decodeURIComponent(r[1]) === i(s)) { o = n; break }o >= 0 && this.deleteQueryParam(e, i(s)).addQueryParam(e, t, o) } else { for (n = 0; n < a; n++) if (i((r = this.queryPairs[n])[0]) === i(e)) { o = n; break } this.deleteQueryParam(e), this.addQueryParam(e, t, o) } return this }, ['protocol', 'hasAuthorityPrefix', 'isColonUri', 'userInfo', 'host', 'port', 'path', 'query', 'anchor'].forEach(function (e) { const t = 'set' + e.charAt(0).toUpperCase() + e.slice(1); n.prototype[t] = function (t) { return this[e](t), this } }), n.prototype.scheme = function () { let e = ''; return this.protocol() ? (e += this.protocol(), this.protocol().indexOf(':') !== this.protocol().length - 1 && (e += ':'), e += '//') : this.hasAuthorityPrefix() && this.host() && (e += '//'), e }, n.prototype.origin = function () { let e = this.scheme(); return this.userInfo() && this.host() && (e += this.userInfo(), this.userInfo().indexOf('@') !== this.userInfo().length - 1 && (e += '@')), this.host() && (e += this.host(), (this.port() || this.path() && this.path().substr(0, 1).match(/[0-9]/)) && (e += ':' + this.port())), e }, n.prototype.addTrailingSlash = function () { const e = this.path() || ''; return e.substr(-1) !== '/' && this.path(e + '/'), this }, n.prototype.toString = function () { let e; let i = this.origin(); return this.isColonUri() ? this.path() && (i += ':' + this.path()) : this.path() ? (e = this.path(), t.ends_with_slashes.test(i) || t.starts_with_slashes.test(e) ? (i && i.replace(t.ends_with_slashes, '/'), e = e.replace(t.starts_with_slashes, '/')) : i += '/', i += e) : this.host() && (this.query().toString() || this.anchor()) && (i += '/'), this.query().toString() && (i += this.query().toString()), this.anchor() && (this.anchor().indexOf('#') !== 0 && (i += '#'), i += this.anchor()), i }, n.prototype.clone = function () { return new n(this.toString()) }, ta.exports = n }()); const sa = ia.exports; const na = {}; window.AypexFrontend || (window.AypexFrontend = na), na.mountedAt = function () { return window.AypexPaths.mounted_at }, na.adminPath = function () { return window.AypexPaths.admin }, na.pathFor = function (e) { const t = window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : ''); return this.url('' + t + this.mountedAt() + e, this.url_params).toString() }, na.localizedPathFor = function (e) { if (typeof AYPEX_LOCALE !== 'undefined' && typeof AYPEX_CURRENCY !== 'undefined') { const t = new URL(na.pathFor(e)); const i = t.searchParams; let s = t.pathname; return i.set('currency', AYPEX_CURRENCY), s.match(/api\/v/) ? i.set('locale', AYPEX_LOCALE) : s = this.mountedAt() + AYPEX_LOCALE + '/' + e, t.origin + s + '?' + i.toString() } return na.pathFor(e) }, na.url = function (e, t) { return void 0 === e.path && (e = new sa(e)), t && Object.keys(t).forEach(i => e.addQueryParam(i, t[i])), e }, na.routes = {}, na.url_params = {}, console.log('Aypex Frontend Initialized'); const ra = { logger: self.console, WebSocket: self.WebSocket }; const oa = { log (...e) { this.enabled && (e.push(Date.now()), ra.logger.log('[ActionCable]', ...e)) } }; const aa = () => (new Date()).getTime(); const ca = e => (aa() - e) / 1e3; class la {constructor (e) { this.visibilityDidChange = this.visibilityDidChange.bind(this), this.connection = e, this.reconnectAttempts = 0 }start () { this.isRunning() || (this.startedAt = aa(), delete this.stoppedAt, this.startPolling(), addEventListener('visibilitychange', this.visibilityDidChange), oa.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`)) }stop () { this.isRunning() && (this.stoppedAt = aa(), this.stopPolling(), removeEventListener('visibilitychange', this.visibilityDidChange), oa.log('ConnectionMonitor stopped')) }isRunning () { return this.startedAt && !this.stoppedAt }recordPing () { this.pingedAt = aa() }recordConnect () { this.reconnectAttempts = 0, this.recordPing(), delete this.disconnectedAt, oa.log('ConnectionMonitor recorded connect') }recordDisconnect () { this.disconnectedAt = aa(), oa.log('ConnectionMonitor recorded disconnect') }startPolling () { this.stopPolling(), this.poll() }stopPolling () { clearTimeout(this.pollTimeout) }poll () { this.pollTimeout = setTimeout(() => { this.reconnectIfStale(), this.poll() }, this.getPollInterval()) }getPollInterval () { const { staleThreshold: e, reconnectionBackoffRate: t } = this.constructor; return 1e3 * e * Math.pow(1 + t, Math.min(this.reconnectAttempts, 10)) * (1 + (this.reconnectAttempts === 0 ? 1 : t) * Math.random()) }reconnectIfStale () { this.connectionIsStale() && (oa.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${ca(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`), this.reconnectAttempts++, this.disconnectedRecently() ? oa.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${ca(this.disconnectedAt)} s`) : (oa.log('ConnectionMonitor reopening'), this.connection.reopen())) } get refreshedAt () { return this.pingedAt ? this.pingedAt : this.startedAt }connectionIsStale () { return ca(this.refreshedAt) > this.constructor.staleThreshold }disconnectedRecently () { return this.disconnectedAt && ca(this.disconnectedAt) < this.constructor.staleThreshold }visibilityDidChange () { document.visibilityState === 'visible' && setTimeout(() => { !this.connectionIsStale() && this.connection.isOpen() || (oa.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`), this.connection.reopen()) }, 200) }}la.staleThreshold = 6, la.reconnectionBackoffRate = 0.15; const ha = la; const da = { message_types: { welcome: 'welcome', disconnect: 'disconnect', ping: 'ping', confirmation: 'confirm_subscription', rejection: 'reject_subscription' }, disconnect_reasons: { unauthorized: 'unauthorized', invalid_request: 'invalid_request', server_restart: 'server_restart' }, default_mount_path: '/cable', protocols: ['actioncable-v1-json', 'actioncable-unsupported'] }; const { message_types: ua, protocols: pa } = da; const ma = pa.slice(0, pa.length - 1); const fa = [].indexOf; class ga {constructor (e) { this.open = this.open.bind(this), this.consumer = e, this.subscriptions = this.consumer.subscriptions, this.monitor = new ha(this), this.disconnected = !0 }send (e) { return !!this.isOpen() && (this.webSocket.send(JSON.stringify(e)), !0) }open () { return this.isActive() ? (oa.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`), !1) : (oa.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${pa}`), this.webSocket && this.uninstallEventHandlers(), this.webSocket = new ra.WebSocket(this.consumer.url, pa), this.installEventHandlers(), this.monitor.start(), !0) }close ({ allowReconnect: e } = { allowReconnect: !0 }) { if (e || this.monitor.stop(), this.isOpen()) return this.webSocket.close() }reopen () { if (oa.log(`Reopening WebSocket, current state is ${this.getState()}`), !this.isActive()) return this.open(); try { return this.close() } catch (e) { oa.log('Failed to reopen WebSocket', e) } finally { oa.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`), setTimeout(this.open, this.constructor.reopenDelay) } }getProtocol () { if (this.webSocket) return this.webSocket.protocol }isOpen () { return this.isState('open') }isActive () { return this.isState('open', 'connecting') }isProtocolSupported () { return fa.call(ma, this.getProtocol()) >= 0 }isState (...e) { return fa.call(e, this.getState()) >= 0 }getState () { if (this.webSocket) for (const e in ra.WebSocket) if (ra.WebSocket[e] === this.webSocket.readyState) return e.toLowerCase(); return null }installEventHandlers () { for (const e in this.events) { const t = this.events[e].bind(this); this.webSocket[`on${e}`] = t } }uninstallEventHandlers () { for (const e in this.events) this.webSocket[`on${e}`] = function () {} }}ga.reopenDelay = 500, ga.prototype.events = { message (e) { if (!this.isProtocolSupported()) return; const { identifier: t, message: i, reason: s, reconnect: n, type: r } = JSON.parse(e.data); switch (r) { case ua.welcome:return this.monitor.recordConnect(), this.subscriptions.reload(); case ua.disconnect:return oa.log(`Disconnecting. Reason: ${s}`), this.close({ allowReconnect: n }); case ua.ping:return this.monitor.recordPing(); case ua.confirmation:return this.subscriptions.confirmSubscription(t), this.subscriptions.notify(t, 'connected'); case ua.rejection:return this.subscriptions.reject(t); default:return this.subscriptions.notify(t, 'received', i) } }, open () { if (oa.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`), this.disconnected = !1, !this.isProtocolSupported()) return oa.log('Protocol is unsupported. Stopping monitor and disconnecting.'), this.close({ allowReconnect: !1 }) }, close (e) { if (oa.log('WebSocket onclose event'), !this.disconnected) return this.disconnected = !0, this.monitor.recordDisconnect(), this.subscriptions.notifyAll('disconnected', { willAttemptReconnect: this.monitor.isRunning() }) }, error () { oa.log('WebSocket onerror event') } }; const ba = ga; class va {constructor (e, t = {}, i) { this.consumer = e, this.identifier = JSON.stringify(t), (function (e, t) { if (t != null) for (const i in t) { const s = t[i]; e[i] = s } }(this, i)) }perform (e, t = {}) { return t.action = e, this.send(t) }send (e) { return this.consumer.send({ command: 'message', identifier: this.identifier, data: JSON.stringify(e) }) }unsubscribe () { return this.consumer.subscriptions.remove(this) }} const ya = class {constructor (e) { this.subscriptions = e, this.pendingSubscriptions = [] }guarantee (e) { this.pendingSubscriptions.indexOf(e) == -1 ? (oa.log(`SubscriptionGuarantor guaranteeing ${e.identifier}`), this.pendingSubscriptions.push(e)) : oa.log(`SubscriptionGuarantor already guaranteeing ${e.identifier}`), this.startGuaranteeing() }forget (e) { oa.log(`SubscriptionGuarantor forgetting ${e.identifier}`), this.pendingSubscriptions = this.pendingSubscriptions.filter(t => t !== e) }startGuaranteeing () { this.stopGuaranteeing(), this.retrySubscribing() }stopGuaranteeing () { clearTimeout(this.retryTimeout) }retrySubscribing () { this.retryTimeout = setTimeout(() => { this.subscriptions && typeof this.subscriptions.subscribe === 'function' && this.pendingSubscriptions.map(e => { oa.log(`SubscriptionGuarantor resubscribing ${e.identifier}`), this.subscriptions.subscribe(e) }) }, 500) }}; class wa {constructor (e) { this.consumer = e, this.guarantor = new ya(this), this.subscriptions = [] }create (e, t) { const i = typeof e === 'object' ? e : { channel: e }; const s = new va(this.consumer, i, t); return this.add(s) }add (e) { return this.subscriptions.push(e), this.consumer.ensureActiveConnection(), this.notify(e, 'initialized'), this.subscribe(e), e }remove (e) { return this.forget(e), this.findAll(e.identifier).length || this.sendCommand(e, 'unsubscribe'), e }reject (e) { return this.findAll(e).map(e => (this.forget(e), this.notify(e, 'rejected'), e)) }forget (e) { return this.guarantor.forget(e), this.subscriptions = this.subscriptions.filter(t => t !== e), e }findAll (e) { return this.subscriptions.filter(t => t.identifier === e) }reload () { return this.subscriptions.map(e => this.subscribe(e)) }notifyAll (e, ...t) { return this.subscriptions.map(i => this.notify(i, e, ...t)) }notify (e, t, ...i) { let s; return s = typeof e === 'string' ? this.findAll(e) : [e], s.map(e => typeof e[t] === 'function' ? e[t](...i) : void 0) }subscribe (e) { this.sendCommand(e, 'subscribe') && this.guarantor.guarantee(e) }confirmSubscription (e) { oa.log(`Subscription confirmed ${e}`), this.findAll(e).map(e => this.guarantor.forget(e)) }sendCommand (e, t) { const { identifier: i } = e; return this.consumer.send({ command: t, identifier: i }) }} class _a {constructor (e) { this._url = e, this.subscriptions = new wa(this), this.connection = new ba(this) } get url () { return Ea(this._url) }send (e) { return this.connection.send(e) }connect () { return this.connection.open() }disconnect () { return this.connection.close({ allowReconnect: !1 }) }ensureActiveConnection () { if (!this.connection.isActive()) return this.connection.open() }} function Ea (e) { if (typeof e === 'function' && (e = e()), e && !/^wss?:/i.test(e)) { const t = document.createElement('a'); return t.href = e, t.href = t.href, t.protocol = t.protocol.replace('http', 'ws'), t.href } return e } function Sa (e) { const t = document.head.querySelector(`meta[name='action-cable-${e}']`); if (t) return t.getAttribute('content') } var Aa = Object.freeze({ __proto__: null, Connection: ba, ConnectionMonitor: ha, Consumer: _a, INTERNAL: da, Subscription: va, Subscriptions: wa, SubscriptionGuarantor: ya, adapters: ra, createWebSocketURL: Ea, logger: oa, createConsumer: function (e = Sa('url') || da.default_mount_path) { return new _a(e) }, getConfig: Sa })
// # sourceMappingURL=aypex_frontend.min.js.map
